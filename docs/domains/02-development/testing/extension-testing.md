# üß™ Chrome Extension Ê∏¨Ë©¶ÊåáÂçó

> **Èñ±ËÆÄÊôÇÈñì**: 15 ÂàÜÈêò  
> **ÈÅ©Áî®Â∞çË±°**: ÈúÄË¶ÅÂØ´ Chrome Extension Ê∏¨Ë©¶ÁöÑÈñãÁôºËÄÖ  
> **ÈáçË¶ÅÁ®ãÂ∫¶**: üü° P1 ÈáçË¶Å  
> **ÂâçÁΩÆË¶ÅÊ±Ç**: Â∑≤ÊéåÊè° [Ê∏¨Ë©¶ÈáëÂ≠óÂ°îÂØ¶Ë∏ê](./test-pyramid.md)

---

## üéØ Chrome Extension Ê∏¨Ë©¶ÊåëÊà∞

### **Extension Áí∞Â¢ÉÁöÑÁâπÊÆäÊÄß**

Chrome Extension ÁöÑÂ§öÁí∞Â¢ÉÂü∑Ë°åÊû∂ÊßãÂ∏∂‰æÜÁç®ÁâπÁöÑÊ∏¨Ë©¶ÊåëÊà¢Ôºö

```text
Ê∏¨Ë©¶Áí∞Â¢ÉË§áÈõúÊÄßÔºö
‚îú‚îÄ‚îÄ Background Service Worker (ÁÑ° DOMÔºåÊúâ Chrome APIs)
‚îú‚îÄ‚îÄ Content Script (Êúâ DOMÔºåÊúâÈôê Chrome APIs)  
‚îú‚îÄ‚îÄ Popup UI (Êúâ DOMÔºåÊúâ Chrome APIsÔºåÁü≠Êö´ÁîüÂëΩÈÄ±Êúü)
‚îú‚îÄ‚îÄ Options Page (Êúâ DOMÔºåÊúâ Chrome APIs)
‚îî‚îÄ‚îÄ Ë∑®Áí∞Â¢ÉÈÄöË®ä (Ë®äÊÅØÂÇ≥ÈÅûÔºåÁï∞Ê≠•ÔºåÂ∫èÂàóÂåñÈôêÂà∂)
```

**ÂÇ≥Áµ± Web Ê∏¨Ë©¶Â∑•ÂÖ∑ÁöÑÈôêÂà∂**Ôºö
- ‚ùå **ÁÑ°Ê≥ïÊ®°Êì¨ Chrome APIs**: `chrome.storage`„ÄÅ`chrome.runtime` Á≠â
- ‚ùå **Â§öÁí∞Â¢ÉÈöîÈõ¢**: ÁÑ°Ê≥ïÊ∏¨Ë©¶Ë∑®Áí∞Â¢ÉÈÄöË®ä
- ‚ùå **Ê¨äÈôêÈôêÂà∂**: Content Script ÁöÑÊ≤ôÁõíÁí∞Â¢É
- ‚ùå **ÁîüÂëΩÈÄ±ÊúüÂ∑ÆÁï∞**: Background ÊåÅ‰πÖ vs Popup Áü≠Êö´

**Extension ÁâπÂåñÊ∏¨Ë©¶Á≠ñÁï•**Ôºö
- ‚úÖ **Chrome API Mock**: ÂÆåÊï¥ÁöÑ Chrome Extension API Ê®°Êì¨
- ‚úÖ **Â§öÁí∞Â¢ÉÊ∏¨Ë©¶**: ÂêÑÁí∞Â¢ÉÁç®Á´ã + Êï¥ÂêàÊ∏¨Ë©¶
- ‚úÖ **Ë®äÊÅØÂÇ≥ÈÅûÊ∏¨Ë©¶**: Ë∑®Áí∞Â¢ÉÈÄöË®äÂ∞àÁî®Ê∏¨Ë©¶Ê®°Âºè
- ‚úÖ **ÁúüÂØ¶ÁÄèË¶ΩÂô®Ê∏¨Ë©¶**: Puppeteer + Extension ËºâÂÖ•

---

## üîß Chrome API Mock Á≥ªÁµ±

### **ÂÆåÊï¥ÁöÑ Chrome API Ê®°Êì¨**

```javascript
// chrome-api-mock.js - ÂÆåÊï¥ÁöÑ Chrome Extension API Ê®°Êì¨
class ChromeAPIMock {
  constructor() {
    this.storage = new ChromeStorageMock();
    this.runtime = new ChromeRuntimeMock();
    this.tabs = new ChromeTabsMock();
    this.scripting = new ChromeScriptingMock();
    this.action = new ChromeActionMock();
    
    // Ê®°Êì¨ÂÖ®Âüü chrome Áâ©‰ª∂
    this.chrome = {
      storage: this.storage,
      runtime: this.runtime,
      tabs: this.tabs,
      scripting: this.scripting,
      action: this.action
    };
  }
  
  install() {
    global.chrome = this.chrome;
    return this;
  }
  
  reset() {
    this.storage.reset();
    this.runtime.reset();
    this.tabs.reset();
    this.scripting.reset();
    this.action.reset();
  }
  
  // Ê∏¨Ë©¶ËºîÂä©ÊñπÊ≥ï
  expectStorageCall(method, args) {
    expect(this.storage[method]).toHaveBeenCalledWith(...args);
  }
  
  expectRuntimeMessage(message) {
    expect(this.runtime.sendMessage).toHaveBeenCalledWith(message);
  }
}

// ChromeStorageMock.js - Storage API Ê®°Êì¨
class ChromeStorageMock {
  constructor() {
    this.data = new Map();
    this.lastError = null;
    
    this.local = {
      get: jest.fn().mockImplementation(this.get.bind(this)),
      set: jest.fn().mockImplementation(this.set.bind(this)),
      remove: jest.fn().mockImplementation(this.remove.bind(this)),
      clear: jest.fn().mockImplementation(this.clear.bind(this))
    };
    
    this.sync = {
      get: jest.fn().mockImplementation(this.get.bind(this)),
      set: jest.fn().mockImplementation(this.set.bind(this)),
      remove: jest.fn().mockImplementation(this.remove.bind(this)),
      clear: jest.fn().mockImplementation(this.clear.bind(this))
    };
  }
  
  get(keys, callback) {
    setTimeout(() => {
      try {
        let result = {};
        
        if (typeof keys === 'string') {
          keys = [keys];
        } else if (keys === null || keys === undefined) {
          // Áç≤ÂèñÊâÄÊúâË≥áÊñô
          result = Object.fromEntries(this.data);
          callback(result);
          return;
        }
        
        if (Array.isArray(keys)) {
          keys.forEach(key => {
            if (this.data.has(key)) {
              result[key] = this.data.get(key);
            }
          });
        } else if (typeof keys === 'object') {
          // Â∏∂È†êË®≠ÂÄºÁöÑÁâ©‰ª∂Ê†ºÂºè
          Object.keys(keys).forEach(key => {
            result[key] = this.data.has(key) 
              ? this.data.get(key) 
              : keys[key];
          });
        }
        
        callback(result);
      } catch (error) {
        this.lastError = { message: error.message };
        callback({});
      }
    }, 0);
  }
  
  set(items, callback) {
    setTimeout(() => {
      try {
        // Ê®°Êì¨ÂÑ≤Â≠òÈÖçÈ°çÊ™¢Êü•
        const dataSize = JSON.stringify(items).length;
        if (dataSize > 5 * 1024 * 1024) { // 5MB ÈôêÂà∂
          this.lastError = { message: 'QUOTA_EXCEEDED' };
          callback && callback();
          return;
        }
        
        Object.keys(items).forEach(key => {
          this.data.set(key, items[key]);
        });
        
        this.lastError = null;
        callback && callback();
      } catch (error) {
        this.lastError = { message: error.message };
        callback && callback();
      }
    }, 0);
  }
  
  remove(keys, callback) {
    setTimeout(() => {
      try {
        if (typeof keys === 'string') {
          keys = [keys];
        }
        
        keys.forEach(key => {
          this.data.delete(key);
        });
        
        this.lastError = null;
        callback && callback();
      } catch (error) {
        this.lastError = { message: error.message };
        callback && callback();
      }
    }, 0);
  }
  
  clear(callback) {
    setTimeout(() => {
      this.data.clear();
      this.lastError = null;
      callback && callback();
    }, 0);
  }
  
  reset() {
    this.data.clear();
    this.lastError = null;
    jest.clearAllMocks();
  }
  
  // Ê∏¨Ë©¶ËºîÂä©ÊñπÊ≥ï
  setMockData(data) {
    this.data = new Map(Object.entries(data));
  }
  
  getMockData() {
    return Object.fromEntries(this.data);
  }
  
  simulateQuotaExceeded(exceed = true) {
    if (exceed) {
      this.set = jest.fn().mockImplementation((items, callback) => {
        setTimeout(() => {
          this.lastError = { message: 'QUOTA_EXCEEDED' };
          callback && callback();
        }, 0);
      });
    } else {
      this.set = jest.fn().mockImplementation(this.set.bind(this));
    }
  }
}

// ChromeRuntimeMock.js - Runtime API Ê®°Êì¨
class ChromeRuntimeMock {
  constructor() {
    this.id = 'test-extension-id';
    this.lastError = null;
    this.messageListeners = new Set();
    
    this.sendMessage = jest.fn().mockImplementation(this.mockSendMessage.bind(this));
    this.connect = jest.fn().mockImplementation(this.mockConnect.bind(this));
    
    this.onMessage = {
      addListener: jest.fn().mockImplementation(this.addMessageListener.bind(this)),
      removeListener: jest.fn().mockImplementation(this.removeMessageListener.bind(this)),
      hasListener: jest.fn()
    };
    
    this.onConnect = {
      addListener: jest.fn(),
      removeListener: jest.fn(),
      hasListener: jest.fn()
    };
  }
  
  mockSendMessage(message, options, responseCallback) {
    setTimeout(() => {
      // Ê®°Êì¨ÂõûÊáâ
      const response = this.generateMockResponse(message);
      
      if (responseCallback) {
        responseCallback(response);
      }
    }, 0);
  }
  
  generateMockResponse(message) {
    // Ê†πÊìöË®äÊÅØÈ°ûÂûãÁî¢ÁîüÊ®°Êì¨ÂõûÊáâ
    if (message.type === 'PING') {
      return { type: 'PONG', timestamp: Date.now() };
    }
    
    if (message.type === 'GET_DATA') {
      return { 
        success: true, 
        data: { books: [] }
      };
    }
    
    return { success: true };
  }
  
  addMessageListener(listener) {
    this.messageListeners.add(listener);
  }
  
  removeMessageListener(listener) {
    this.messageListeners.delete(listener);
  }
  
  // Ê∏¨Ë©¶ËºîÂä©ÊñπÊ≥ï
  simulateMessage(message, sender = {}, sendResponse = jest.fn()) {
    this.messageListeners.forEach(listener => {
      const result = listener(message, sender, sendResponse);
      
      // Â¶ÇÊûúÁõ£ËÅΩÂô®ËøîÂõû trueÔºåË°®Á§∫ÊúÉÁï∞Ê≠•ÂõûÊáâ
      if (result === true) {
        setTimeout(() => {
          sendResponse({ success: true, async: true });
        }, 10);
      }
    });
  }
  
  reset() {
    this.messageListeners.clear();
    this.lastError = null;
    jest.clearAllMocks();
  }
}
```

### **Ê∏¨Ë©¶Áí∞Â¢ÉË®≠ÁΩÆ**

```javascript
// test-setup/extension-setup.js - Chrome Extension Ê∏¨Ë©¶Áí∞Â¢ÉË®≠ÁΩÆ
import { ChromeAPIMock } from './chrome-api-mock';

let chromeAPIMock;

// ÂÖ®ÂüüË®≠ÁΩÆ
beforeEach(() => {
  chromeAPIMock = new ChromeAPIMock().install();
});

afterEach(() => {
  chromeAPIMock.reset();
  delete global.chrome;
});

// Ê∏¨Ë©¶Â∑•ÂÖ∑ÂáΩÊï∏
global.createExtensionTestEnvironment = (options = {}) => {
  return {
    chrome: chromeAPIMock,
    
    // Ê®°Êì¨ÂÑ≤Â≠òË≥áÊñô
    mockStorageData(data) {
      chromeAPIMock.storage.setMockData(data);
    },
    
    // Ê®°Êì¨Ë®äÊÅØÂÇ≥ÈÅû
    sendMockMessage(message, sender = {}) {
      return new Promise(resolve => {
        chromeAPIMock.runtime.simulateMessage(
          message, 
          sender, 
          resolve
        );
      });
    },
    
    // È©óË≠â Chrome API Ë™øÁî®
    expectStorageGet(key) {
      expect(chromeAPIMock.storage.local.get).toHaveBeenCalledWith(
        key, 
        expect.any(Function)
      );
    },
    
    expectStorageSet(data) {
      expect(chromeAPIMock.storage.local.set).toHaveBeenCalledWith(
        data, 
        expect.any(Function)
      );
    },
    
    expectMessageSent(message) {
      expect(chromeAPIMock.runtime.sendMessage).toHaveBeenCalledWith(message);
    }
  };
};

// Jest ÈÖçÁΩÆ
module.exports = {
  setupFilesAfterEnv: [
    '<rootDir>/tests/setup/extension-setup.js'
  ],
  testEnvironment: 'jsdom',
  testEnvironmentOptions: {
    url: 'chrome-extension://test-id/popup.html'
  }
};
```

---

## üé≠ Background Service Worker Ê∏¨Ë©¶

### **Background ÈÇèËºØÂñÆÂÖÉÊ∏¨Ë©¶**

```javascript
// background/domains/data-management/coordinator.test.js
import { DataManagementCoordinator } from '../../../src/background/domains/data-management';

describe('DataManagementCoordinator - Background Tests', () => {
  let coordinator;
  let testEnv;
  
  beforeEach(() => {
    testEnv = createExtensionTestEnvironment();
    
    coordinator = new DataManagementCoordinator({
      storageAdapter: new StorageAdapter({ 
        storageArea: chrome.storage.local 
      }),
      logger: createMockLogger(),
      eventBus: createMockEventBus()
    });
  });
  
  describe('Chrome Storage integration', () => {
    it('should save books to Chrome Storage', async () => {
      // Arrange
      const books = [
        { id: '1', title: 'Test Book 1', author: 'Author 1' },
        { id: '2', title: 'Test Book 2', author: 'Author 2' }
      ];
      
      // Act
      const result = await coordinator.processBooks(books);
      
      // Assert
      expect(result.success).toBe(true);
      testEnv.expectStorageSet({
        'readmoo_books_data': expect.arrayContaining([
          expect.objectContaining({ title: 'Test Book 1' }),
          expect.objectContaining({ title: 'Test Book 2' })
        ])
      });
    });
    
    it('should handle Chrome Storage quota exceeded', async () => {
      // Arrange
      testEnv.chrome.storage.simulateQuotaExceeded(true);
      const largeBookSet = new Array(1000).fill(null).map((_, i) => ({
        id: `book-${i}`,
        title: `Large Book ${i}`,
        content: 'A'.repeat(1000) // Â§ßÈáèË≥áÊñô
      }));
      
      // Act
      const result = await coordinator.processBooks(largeBookSet);
      
      // Assert
      expect(result.success).toBe(false);
      expect(result.error.code).toBe('STORAGE_QUOTA_EXCEEDED');
    });
  });
  
  describe('Background message handling', () => {
    it('should respond to content script requests', async () => {
      // Arrange
      await coordinator.initialize();
      
      const requestMessage = {
        type: 'DATA_MANAGEMENT_REQUEST',
        operation: 'GET_BOOKS',
        payload: { limit: 10 }
      };
      
      // Act
      const response = await testEnv.sendMockMessage(
        requestMessage,
        { tab: { id: 123 } }
      );
      
      // Assert
      expect(response.success).toBe(true);
      expect(response.data).toBeInstanceOf(Array);
    });
    
    it('should handle invalid requests gracefully', async () => {
      // Arrange
      await coordinator.initialize();
      
      const invalidRequest = {
        type: 'INVALID_REQUEST',
        operation: 'UNKNOWN_OPERATION'
      };
      
      // Act
      const response = await testEnv.sendMockMessage(invalidRequest);
      
      // Assert
      expect(response.success).toBe(false);
      expect(response.error).toEqual(
        expect.objectContaining({
          code: 'INVALID_REQUEST'
        })
      );
    });
  });
  
  describe('Background lifecycle', () => {
    it('should initialize correctly', async () => {
      // Act
      await coordinator.initialize();
      
      // Assert
      expect(coordinator.isInitialized()).toBe(true);
      
      // È©óË≠â‰∫ã‰ª∂Áõ£ËÅΩÂô®Ë®ªÂÜä
      expect(chrome.runtime.onMessage.addListener).toHaveBeenCalled();
    });
    
    it('should cleanup resources on shutdown', async () => {
      // Arrange
      await coordinator.initialize();
      
      // Act
      await coordinator.shutdown();
      
      // Assert
      expect(coordinator.isInitialized()).toBe(false);
      expect(chrome.runtime.onMessage.removeListener).toHaveBeenCalled();
    });
  });
});
```

### **Service Worker ÁâπÊÆäÊÉÖÂ¢ÉÊ∏¨Ë©¶**

```javascript
// background/service-worker-lifecycle.test.js
describe('Service Worker Lifecycle Tests', () => {
  let testEnv;
  
  beforeEach(() => {
    testEnv = createExtensionTestEnvironment();
  });
  
  it('should handle service worker restart', async () => {
    // Arrange - Ê®°Êì¨ Service Worker ÂïüÂãï
    const backgroundScript = await import('../../../src/background/background.js');
    
    // Ë®≠ÁΩÆ‰∏Ä‰∫õÁãÄÊÖã
    testEnv.mockStorageData({
      'readmoo_books_data': [
        { id: '1', title: 'Existing Book' }
      ]
    });
    
    // Act - Ëß∏Áôº Service Worker ÈáçÂïü
    await backgroundScript.initialize();
    
    // Assert - È©óË≠âÁãÄÊÖãÊÅ¢Âæ©
    const books = await backgroundScript.getBooks();
    expect(books).toHaveLength(1);
    expect(books[0].title).toBe('Existing Book');
  });
  
  it('should handle concurrent requests', async () => {
    // Arrange
    const coordinator = new DataManagementCoordinator({
      storageAdapter: new StorageAdapter({ 
        storageArea: chrome.storage.local 
      })
    });
    
    await coordinator.initialize();
    
    // Act - ÂêåÊôÇÁôºÈÄÅÂ§öÂÄãË´ãÊ±Ç
    const requests = Array.from({ length: 10 }, (_, i) => 
      testEnv.sendMockMessage({
        type: 'DATA_MANAGEMENT_REQUEST',
        operation: 'PROCESS_BOOKS',
        payload: { 
          books: [{ 
            id: `book-${i}`, 
            title: `Concurrent Book ${i}` 
          }] 
        }
      })
    );
    
    const responses = await Promise.all(requests);
    
    // Assert - ÊâÄÊúâË´ãÊ±ÇÈÉΩÊàêÂäüËôïÁêÜ
    responses.forEach((response, index) => {
      expect(response.success).toBe(true);
      expect(response.data).toHaveLength(1);
      expect(response.data[0].title).toBe(`Concurrent Book ${index}`);
    });
  });
});
```

---

## üé® Content Script Ê∏¨Ë©¶

### **DOM Êìç‰ΩúÊ∏¨Ë©¶**

```javascript
// content/extractors/book-extractor.test.js
import { BookDataExtractor } from '../../../src/content/extractors/book-data-extractor';

describe('BookDataExtractor - Content Script Tests', () => {
  let extractor;
  let testEnv;
  
  beforeEach(() => {
    testEnv = createExtensionTestEnvironment();
    extractor = new BookDataExtractor();
    
    // Ë®≠ÁΩÆÊ®°Êì¨ÁöÑ DOM Áí∞Â¢É
    document.body.innerHTML = createMockReadmooHTML();
  });
  
  afterEach(() => {
    document.body.innerHTML = '';
  });
  
  describe('DOM extraction', () => {
    it('should extract books from Readmoo page', async () => {
      // Arrange
      const mockBooks = createMockReadmooHTML();
      document.body.innerHTML = mockBooks;
      
      // Act
      const books = await extractor.extractFromPage();
      
      // Assert
      expect(books).toHaveLength(5);
      expect(books[0]).toEqual(
        expect.objectContaining({
          title: expect.any(String),
          author: expect.any(String),
          price: expect.any(Number),
          isbn: expect.stringMatching(/^\d{10}$|^\d{13}$/)
        })
      );
    });
    
    it('should handle missing book elements', async () => {
      // Arrange
      document.body.innerHTML = '<div class="no-books">Ê≤íÊúâÊõ∏Á±ç</div>';
      
      // Act & Assert
      await expect(extractor.extractFromPage())
        .rejects
        .toThrow('NO_BOOKS_FOUND');
    });
    
    it('should handle malformed book data', async () => {
      // Arrange
      document.body.innerHTML = `
        <div class="book-item">
          <h3 class="title"></h3>
          <span class="author"></span>
          <span class="price">ÁÑ°ÊïàÂÉπÊ†º</span>
        </div>
      `;
      
      // Act
      const books = await extractor.extractFromPage();
      
      // Assert
      expect(books).toHaveLength(0); // ÁÑ°ÊïàË≥áÊñôË¢´ÈÅéÊøæ
    });
  });
  
  describe('page detection', () => {
    it('should detect supported Readmoo pages', () => {
      // Arrange
      Object.defineProperty(window, 'location', {
        value: { href: 'https://readmoo.com/explore' },
        writable: true
      });
      
      // Act
      const isSupported = extractor.isSupportedPage();
      
      // Assert
      expect(isSupported).toBe(true);
    });
    
    it('should reject unsupported pages', () => {
      // Arrange
      Object.defineProperty(window, 'location', {
        value: { href: 'https://example.com' },
        writable: true
      });
      
      // Act
      const isSupported = extractor.isSupportedPage();
      
      // Assert
      expect(isSupported).toBe(false);
    });
  });
  
  describe('Content Script messaging', () => {
    it('should send extraction results to background', async () => {
      // Arrange
      document.body.innerHTML = createMockReadmooHTML();
      
      // Act
      const books = await extractor.extractFromPage();
      await extractor.sendToBackground(books);
      
      // Assert
      testEnv.expectMessageSent({
        type: 'EXTRACTION_COMPLETED',
        payload: {
          books: expect.any(Array),
          url: window.location.href,
          timestamp: expect.any(String)
        }
      });
    });
    
    it('should handle background communication errors', async () => {
      // Arrange
      testEnv.chrome.runtime.sendMessage.mockImplementation(() => {
        throw new Error('Background script not responding');
      });
      
      document.body.innerHTML = createMockReadmooHTML();
      
      // Act & Assert
      const books = await extractor.extractFromPage();
      await expect(extractor.sendToBackground(books))
        .rejects
        .toThrow('Background script not responding');
    });
  });
  
  // Ê∏¨Ë©¶Â∑•ÂÖ∑ÂáΩÊï∏
  function createMockReadmooHTML() {
    return `
      <div class="book-list">
        ${Array.from({ length: 5 }, (_, i) => `
          <div class="book-item" data-book-id="book-${i + 1}">
            <h3 class="title">JavaScript Ê¨äÂ®ÅÊåáÂçó ${i + 1}</h3>
            <span class="author">David Flanagan</span>
            <span class="price" data-price="${(i + 1) * 100}">$${(i + 1) * 100}</span>
            <span class="isbn">97812345678${i}0</span>
            <a href="/book/${i + 1}" class="book-link">Êü•ÁúãË©≥ÊÉÖ</a>
          </div>
        `).join('')}
      </div>
    `;
  }
});
```

### **Content Script Ê≥®ÂÖ•Ê∏¨Ë©¶**

```javascript
// content/content-script-injection.test.js  
describe('Content Script Injection Tests', () => {
  let testEnv;
  
  beforeEach(() => {
    testEnv = createExtensionTestEnvironment();
  });
  
  it('should inject content script correctly', async () => {
    // Arrange
    const mockTab = { id: 123, url: 'https://readmoo.com/explore' };
    
    // Ê®°Êì¨ chrome.scripting.executeScript
    testEnv.chrome.scripting = {
      executeScript: jest.fn().mockResolvedValue([{
        result: { 
          injected: true, 
          books: [
            { title: 'Test Book', author: 'Test Author' }
          ]
        }
      }])
    };
    
    // Act
    const result = await chrome.scripting.executeScript({
      target: { tabId: mockTab.id },
      files: ['content/content-modular.js']
    });
    
    // Assert
    expect(result[0].result.injected).toBe(true);
    expect(result[0].result.books).toHaveLength(1);
    expect(testEnv.chrome.scripting.executeScript).toHaveBeenCalledWith({
      target: { tabId: mockTab.id },
      files: ['content/content-modular.js']
    });
  });
  
  it('should handle injection failures', async () => {
    // Arrange
    testEnv.chrome.scripting = {
      executeScript: jest.fn().mockRejectedValue(
        new Error('Cannot access contents of url')
      )
    };
    
    // Act & Assert
    await expect(
      chrome.scripting.executeScript({
        target: { tabId: 123 },
        files: ['content/content-modular.js']
      })
    ).rejects.toThrow('Cannot access contents of url');
  });
});
```

---

## üé™ Popup UI Ê∏¨Ë©¶

### **Popup ‰ªãÈù¢‰∫íÂãïÊ∏¨Ë©¶**

```javascript
// popup/popup-ui.test.js
import { PopupController } from '../../../src/popup/popup-controller';

describe('PopupController - UI Tests', () => {
  let controller;
  let testEnv;
  
  beforeEach(() => {
    testEnv = createExtensionTestEnvironment();
    
    // Ë®≠ÁΩÆ Popup HTML
    document.body.innerHTML = createMockPopupHTML();
    
    controller = new PopupController({
      eventBus: createMockEventBus()
    });
  });
  
  describe('UI interactions', () => {
    it('should handle extract button click', async () => {
      // Arrange
      await controller.initialize();
      const extractButton = document.getElementById('extract-button');
      
      testEnv.mockStorageData({
        'readmoo_books_data': []
      });
      
      // Act
      extractButton.click();
      
      // Á≠âÂæÖÁï∞Ê≠•Êìç‰Ωú
      await new Promise(resolve => setTimeout(resolve, 50));
      
      // Assert
      expect(testEnv.chrome.runtime.sendMessage).toHaveBeenCalledWith({
        type: 'START_EXTRACTION',
        payload: expect.any(Object)
      });
      
      const statusElement = document.querySelector('.extraction-status');
      expect(statusElement.textContent).toBe('Ê≠£Âú®ÊèêÂèñÊõ∏Á±çË≥áÊñô...');
    });
    
    it('should display book count from storage', async () => {
      // Arrange
      testEnv.mockStorageData({
        'readmoo_books_data': [
          { id: '1', title: 'Book 1' },
          { id: '2', title: 'Book 2' },
          { id: '3', title: 'Book 3' }
        ]
      });
      
      // Act
      await controller.initialize();
      
      // Assert
      const bookCountElement = document.querySelector('.book-count');
      expect(bookCountElement.textContent).toBe('Â∑≤Êî∂ÈõÜ 3 Êú¨Êõ∏Á±ç');
    });
    
    it('should handle settings navigation', async () => {
      // Arrange
      await controller.initialize();
      const settingsButton = document.getElementById('settings-button');
      
      testEnv.chrome.runtime.openOptionsPage = jest.fn();
      
      // Act
      settingsButton.click();
      
      // Assert
      expect(testEnv.chrome.runtime.openOptionsPage).toHaveBeenCalled();
    });
  });
  
  describe('real-time updates', () => {
    it('should update UI when extraction completes', async () => {
      // Arrange
      await controller.initialize();
      
      // Act - Ê®°Êì¨Âæû background Êé•Êî∂ÂÆåÊàêË®äÊÅØ
      testEnv.chrome.runtime.simulateMessage({
        type: 'EXTRACTION_COMPLETED',
        payload: {
          books: [
            { id: '1', title: 'New Book 1' },
            { id: '2', title: 'New Book 2' }
          ],
          totalCount: 2
        }
      });
      
      await new Promise(resolve => setTimeout(resolve, 50));
      
      // Assert
      const statusElement = document.querySelector('.extraction-status');
      expect(statusElement.textContent).toBe('ÊèêÂèñÂÆåÊàê');
      
      const bookCountElement = document.querySelector('.book-count');
      expect(bookCountElement.textContent).toBe('Â∑≤Êî∂ÈõÜ 2 Êú¨Êõ∏Á±ç');
    });
    
    it('should show error messages', async () => {
      // Arrange
      await controller.initialize();
      
      // Act
      testEnv.chrome.runtime.simulateMessage({
        type: 'EXTRACTION_FAILED',
        payload: {
          error: {
            code: 'PAGE_NOT_SUPPORTED',
            message: '‰∏çÊîØÊè¥ÁöÑÁ∂≤Á´ô'
          }
        }
      });
      
      await new Promise(resolve => setTimeout(resolve, 50));
      
      // Assert
      const errorElement = document.querySelector('.error-message');
      expect(errorElement.textContent).toBe('‰∏çÊîØÊè¥ÁöÑÁ∂≤Á´ô');
      expect(errorElement.classList.contains('visible')).toBe(true);
    });
  });
  
  function createMockPopupHTML() {
    return `
      <div class="popup-container">
        <div class="header">
          <h1>Readmoo Êõ∏Â∫´ÁÆ°ÁêÜÂô®</h1>
          <button id="settings-button">Ë®≠ÂÆö</button>
        </div>
        
        <div class="status-section">
          <div class="book-count">Â∑≤Êî∂ÈõÜ 0 Êú¨Êõ∏Á±ç</div>
          <div class="extraction-status"></div>
          <div class="error-message"></div>
        </div>
        
        <div class="action-section">
          <button id="extract-button" class="primary">ÊèêÂèñÊõ∏Á±ç</button>
          <button id="view-books-button">Êü•ÁúãÊõ∏Á±ç</button>
        </div>
      </div>
    `;
  }
});
```

### **Popup ÁîüÂëΩÈÄ±ÊúüÊ∏¨Ë©¶**

```javascript
// popup/popup-lifecycle.test.js
describe('Popup Lifecycle Tests', () => {
  let testEnv;
  
  beforeEach(() => {
    testEnv = createExtensionTestEnvironment();
    document.body.innerHTML = createMockPopupHTML();
  });
  
  it('should initialize popup correctly', async () => {
    // Arrange
    const controller = new PopupController({
      eventBus: createMockEventBus()
    });
    
    // Act
    await controller.initialize();
    
    // Assert
    expect(controller.isInitialized()).toBe(true);
    expect(chrome.runtime.onMessage.addListener).toHaveBeenCalled();
    
    // È©óË≠â UI ÂÖÉÁ¥†‰∫ã‰ª∂Áõ£ËÅΩ
    const extractButton = document.getElementById('extract-button');
    expect(extractButton.onclick).toBeDefined();
  });
  
  it('should cleanup on popup close', async () => {
    // Arrange
    const controller = new PopupController({
      eventBus: createMockEventBus()
    });
    await controller.initialize();
    
    // Act - Ê®°Êì¨ popup ÈóúÈñâ
    window.dispatchEvent(new Event('beforeunload'));
    
    // Assert
    expect(chrome.runtime.onMessage.removeListener).toHaveBeenCalled();
  });
  
  it('should handle popup reopening', async () => {
    // Arrange
    testEnv.mockStorageData({
      'readmoo_books_data': [{ id: '1', title: 'Existing Book' }]
    });
    
    const controller = new PopupController({
      eventBus: createMockEventBus()
    });
    
    // Act
    await controller.initialize();
    
    // Assert - È©óË≠âË≥áÊñôÂæû storage Ê≠£Á¢∫ËºâÂÖ•
    const bookCountElement = document.querySelector('.book-count');
    expect(bookCountElement.textContent).toBe('Â∑≤Êî∂ÈõÜ 1 Êú¨Êõ∏Á±ç');
  });
});
```

---

## üîå Ë∑®Áí∞Â¢ÉÈÄöË®äÊ∏¨Ë©¶

### **Ë®äÊÅØÂÇ≥ÈÅûÊï¥ÂêàÊ∏¨Ë©¶**

```javascript
// integration/cross-context-communication.test.js
describe('Cross-Context Communication Tests', () => {
  let backgroundController;
  let contentController;  
  let popupController;
  let testEnv;
  
  beforeEach(() => {
    testEnv = createExtensionTestEnvironment();
    
    // ÂàùÂßãÂåñÂêÑÁí∞Â¢ÉÊéßÂà∂Âô®
    backgroundController = new BackgroundController({
      eventBus: createMockEventBus()
    });
    
    contentController = new ContentController({
      eventBus: createMockEventBus()
    });
    
    popupController = new PopupController({
      eventBus: createMockEventBus()
    });
  });
  
  it('should complete full extraction workflow', async () => {
    // Phase 1: Popup ÁôºËµ∑ÊèêÂèñË´ãÊ±Ç
    await popupController.initialize();
    document.body.innerHTML = createMockPopupHTML();
    
    // Phase 2: Background ËôïÁêÜË´ãÊ±Ç‰∏¶ËΩâÁôºÁµ¶ Content Script
    await backgroundController.initialize();
    
    // Phase 3: Content Script Âü∑Ë°åÊèêÂèñ‰∏¶ÂõûÂ†±ÁµêÊûú
    document.body.innerHTML = createMockReadmooHTML();
    await contentController.initialize();
    
    // Ê®°Êì¨ÂÆåÊï¥ÊµÅÁ®ã
    const extractButton = document.getElementById('extract-button');
    extractButton.click();
    
    // Á≠âÂæÖÁï∞Ê≠•ËôïÁêÜ
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // È©óË≠âË®äÊÅØÂÇ≥ÈÅûÈèà
    expect(testEnv.chrome.runtime.sendMessage).toHaveBeenCalledWith({
      type: 'START_EXTRACTION',
      payload: expect.any(Object)
    });
    
    // Ê®°Êì¨ Content Script ÂõûÊáâ
    testEnv.chrome.runtime.simulateMessage({
      type: 'EXTRACTION_COMPLETED',
      payload: {
        books: [
          { title: 'Book 1', author: 'Author 1' },
          { title: 'Book 2', author: 'Author 2' }
        ],
        source: 'content-script'
      }
    });
    
    await new Promise(resolve => setTimeout(resolve, 50));
    
    // È©óË≠â Popup UI Êõ¥Êñ∞
    const bookCount = document.querySelector('.book-count');
    expect(bookCount.textContent).toBe('Â∑≤Êî∂ÈõÜ 2 Êú¨Êõ∏Á±ç');
  });
  
  it('should handle communication failures gracefully', async () => {
    // Arrange
    await backgroundController.initialize();
    await popupController.initialize();
    
    // Ê®°Êì¨ Background Script ÁÑ°ÂõûÊáâ
    testEnv.chrome.runtime.sendMessage.mockImplementation(() => {
      // ‰∏çË™øÁî® callbackÔºåÊ®°Êì¨ÁÑ°ÂõûÊáâ
    });
    
    document.body.innerHTML = createMockPopupHTML();
    
    // Act
    const extractButton = document.getElementById('extract-button');
    extractButton.click();
    
    // Á≠âÂæÖË∂ÖÊôÇ
    await new Promise(resolve => setTimeout(resolve, 200));
    
    // Assert
    const errorElement = document.querySelector('.error-message');
    expect(errorElement.textContent).toMatch(/ÈÄöË®äË∂ÖÊôÇ|ÁÑ°ÂõûÊáâ/);
  });
  
  it('should handle concurrent requests from multiple sources', async () => {
    // Arrange
    await backgroundController.initialize();
    
    const requests = [
      {
        type: 'GET_BOOKS',
        source: 'popup'
      },
      {
        type: 'EXTRACT_BOOKS',  
        source: 'content-script'
      },
      {
        type: 'UPDATE_SETTINGS',
        source: 'options-page'
      }
    ];
    
    // Act
    const responses = await Promise.all(
      requests.map(request => 
        testEnv.sendMockMessage(request)
      )
    );
    
    // Assert
    responses.forEach(response => {
      expect(response.success).toBe(true);
    });
  });
});
```

---

## üöÄ ÁúüÂØ¶ÁÄèË¶ΩÂô®Ê∏¨Ë©¶ (E2E)

### **Puppeteer + Extension Êï¥Âêà**

```javascript
// e2e/extension-e2e.test.js
import puppeteer from 'puppeteer';
import path from 'path';

describe('Chrome Extension E2E Tests', () => {
  let browser;
  let page;
  const extensionPath = path.join(__dirname, '../../dist');
  
  beforeAll(async () => {
    browser = await puppeteer.launch({
      headless: false,
      args: [
        `--disable-extensions-except=${extensionPath}`,
        `--load-extension=${extensionPath}`,
        '--no-sandbox'
      ]
    });
  });
  
  afterAll(async () => {
    await browser.close();
  });
  
  beforeEach(async () => {
    page = await browser.newPage();
  });
  
  afterEach(async () => {
    await page.close();
  });
  
  it('should extract books from real Readmoo page', async () => {
    // Â∞éËà™Âà∞Ê∏¨Ë©¶È†ÅÈù¢
    await page.goto('https://readmoo.com/explore', {
      waitUntil: 'networkidle2'
    });
    
    // Á≠âÂæÖÊõ∏Á±çÂÖÉÁ¥†ËºâÂÖ•
    await page.waitForSelector('.book-item', { timeout: 5000 });
    
    // Áç≤ÂèñÊì¥Â±ï ID
    const extensionId = await getExtensionId(browser);
    
    // ÈñãÂïü Popup
    const popupPage = await browser.newPage();
    await popupPage.goto(`chrome-extension://${extensionId}/popup.html`);
    
    // ÈªûÊìäÊèêÂèñÊåâÈàï
    await popupPage.waitForSelector('#extract-button');
    await popupPage.click('#extract-button');
    
    // Á≠âÂæÖÊèêÂèñÂÆåÊàê
    await popupPage.waitForSelector('.extraction-success', { timeout: 15000 });
    
    // È©óË≠âÁµêÊûú
    const resultText = await popupPage.$eval(
      '.extraction-result', 
      el => el.textContent
    );
    
    expect(resultText).toMatch(/ÊàêÂäüÊèêÂèñ \d+ Êú¨Êõ∏Á±ç/);
    
    // È©óË≠âË≥áÊñôÂÑ≤Â≠òÂà∞ Chrome Storage
    const storedData = await popupPage.evaluate(() => {
      return new Promise(resolve => {
        chrome.storage.local.get(['readmoo_books_data'], result => {
          resolve(result.readmoo_books_data);
        });
      });
    });
    
    expect(storedData).toBeInstanceOf(Array);
    expect(storedData.length).toBeGreaterThan(0);
    
    await popupPage.close();
  });
  
  it('should handle unsupported pages', async () => {
    // Â∞éËà™Âà∞‰∏çÊîØÊè¥ÁöÑÈ†ÅÈù¢
    await page.goto('https://example.com');
    
    const extensionId = await getExtensionId(browser);
    const popupPage = await browser.newPage();
    await popupPage.goto(`chrome-extension://${extensionId}/popup.html`);
    
    // ÈªûÊìäÊèêÂèñÊåâÈàï
    await popupPage.click('#extract-button');
    
    // Á≠âÂæÖÈåØË™§Ë®äÊÅØ
    await popupPage.waitForSelector('.extraction-error', { timeout: 10000 });
    
    const errorText = await popupPage.$eval(
      '.extraction-error',
      el => el.textContent
    );
    
    expect(errorText).toMatch(/‰∏çÊîØÊè¥ÁöÑÁ∂≤Á´ô/);
    
    await popupPage.close();
  });
  
  async function getExtensionId(browser) {
    const targets = await browser.targets();
    const extensionTarget = targets.find(target => 
      target.type() === 'service_worker'
    );
    
    if (extensionTarget) {
      const url = extensionTarget.url();
      return url.split('/')[2];
    }
    
    throw new Error('Extension not found');
  }
});
```

---

## üéØ Ê∏¨Ë©¶Á≠ñÁï•Á∏ΩÁµê

### **ÂàÜÂ±§Ê∏¨Ë©¶Ë¶ÜËìã**

| Ê∏¨Ë©¶Â±§Á¥ö | Background | Content Script | Popup | Ë∑®Áí∞Â¢ÉÈÄöË®ä |
|----------|------------|----------------|--------|------------|
| **ÂñÆÂÖÉÊ∏¨Ë©¶** | ‚úÖ Ê•≠ÂãôÈÇèËºØ<br/>‚úÖ Chrome API Mock | ‚úÖ DOM Êìç‰Ωú<br/>‚úÖ Ë≥áÊñôÊèêÂèñ | ‚úÖ UI ‰∫íÂãï<br/>‚úÖ ÁãÄÊÖãÁÆ°ÁêÜ | ‚ùå |
| **Êï¥ÂêàÊ∏¨Ë©¶** | ‚úÖ Storage Êï¥Âêà<br/>‚úÖ Ë®äÊÅØËôïÁêÜ | ‚úÖ Ê≥®ÂÖ•Ê∏¨Ë©¶<br/>‚úÖ È†ÅÈù¢Ê™¢Ê∏¨ | ‚úÖ ÁîüÂëΩÈÄ±Êúü<br/>‚úÖ Âç≥ÊôÇÊõ¥Êñ∞ | ‚úÖ Ë∑®Áí∞Â¢ÉÂçî‰Ωú |
| **E2E Ê∏¨Ë©¶** | ‚úÖ ÁúüÂØ¶Áí∞Â¢ÉÈÅãË°å | ‚úÖ ÁúüÂØ¶È†ÅÈù¢ÊèêÂèñ | ‚úÖ Áî®Êà∂ÊµÅÁ®ã | ‚úÖ ÂÆåÊï¥Â∑•‰ΩúÊµÅ |

### **Chrome Extension ÁâπÊÆäÊ∏¨Ë©¶Èªû**

- [ ] **Ê¨äÈôêÁÆ°ÁêÜ**: Ê∏¨Ë©¶ÂêÑÁ®ÆÊ¨äÈôêÊÉÖÊ≥Å‰∏ãÁöÑË°åÁÇ∫
- [ ] **ÂÑ≤Â≠òÈÖçÈ°ç**: Ê∏¨Ë©¶Êé•ËøëÂíåË∂ÖÈÅéÂÑ≤Â≠òÈôêÂà∂ÁöÑÊÉÖÊ≥Å
- [ ] **Á∂≤È†ÅÁõ∏ÂÆπÊÄß**: Ê∏¨Ë©¶ÂêÑÁ®ÆÁ∂≤È†ÅÁµêÊßãÂíåÂãïÊÖãËºâÂÖ•
- [ ] **Êì¥Â±ïÁîüÂëΩÈÄ±Êúü**: Ê∏¨Ë©¶ÂÆâË£ù„ÄÅÂïüÁî®„ÄÅÂÅúÁî®„ÄÅÊõ¥Êñ∞ÊµÅÁ®ã
- [ ] **Ë∑®ÁÄèË¶ΩÂô®**: Ê∏¨Ë©¶ Chrome ‰∏çÂêåÁâàÊú¨ÁöÑÁõ∏ÂÆπÊÄß

---

## üîÑ ‰∏ã‰∏ÄÊ≠•Â≠∏Áøí

ÊéåÊè° Chrome Extension Ê∏¨Ë©¶ÂæåÔºåÂª∫Ë≠∞Ê∑±ÂÖ•Ôºö

1. **üîß [Ê∏¨Ë©¶Â∑•ÂÖ∑Èèà](./testing-tools.md)** - Jest„ÄÅPuppeteer„ÄÅMock Â∑•ÂÖ∑ÈÖçÁΩÆ
2. **üöë [Extension ÁâπÊÆäÂïèÈ°å](../../03-reference/troubleshooting/extension-specific-issues.md)** - Extension ÈñãÁôºÂ∏∏Ë¶ãÂïèÈ°å
3. **‚ö° [ÊïàËÉΩÊ∏¨Ë©¶ÊñπÊ≥ï](../../03-reference/performance/performance-testing.md)** - Extension ÊïàËÉΩÊ∏¨Ë©¶

---

**üéØ Â≠∏ÁøíÊàêÊûúÈ©óË≠â**: ËÉΩÂ§†ÁÇ∫ Chrome Extension ÁöÑÂêÑÂÄãÁí∞Â¢ÉÁ∑®ÂØ´ÂÆåÊï¥ÁöÑÊ∏¨Ë©¶ÔºåÂåÖÊã¨ÂñÆÂÖÉÊ∏¨Ë©¶„ÄÅÊï¥ÂêàÊ∏¨Ë©¶Âíå E2E Ê∏¨Ë©¶„ÄÇ