# ğŸ“Š ç›£æ§èˆ‡è­¦å ±ç³»çµ±

> **ç¬¬ä¸‰å±¤åƒè€ƒæ–‡ä»¶** - å®Œæ•´çš„ç”Ÿç”¢ç’°å¢ƒç›£æ§èˆ‡è­¦å ±æ¶æ§‹æŒ‡å—  
> **ç›®æ¨™è®€è€…**: DevOps å·¥ç¨‹å¸«ã€SRE åœ˜éšŠã€æŠ€è¡“ä¸»ç®¡  
> **æ–‡ä»¶é¡å‹**: ç›£æ§èˆ‡è­¦å ±ç³»çµ±è¨­è¨ˆæ‰‹å†Œ  

æœ¬æ–‡ä»¶æä¾› Readmoo æ›¸åº«æå–å™¨ Chrome Extension çš„å®Œæ•´ç›£æ§èˆ‡è­¦å ±ç³»çµ±è¨­è¨ˆï¼Œæ¶µè“‹ç”Ÿç”¢ç’°å¢ƒç›£æ§ã€ç•°å¸¸æª¢æ¸¬ã€è­¦å ±ç­–ç•¥åŠäº‹ä»¶å›æ‡‰æµç¨‹ã€‚

## ğŸ¯ ç›£æ§é«”ç³»ç¸½è¦½

### ç›£æ§æ¶æ§‹è¨­è¨ˆåŸå‰‡
- **å…¨é¢è¦†è“‹**: æ¶µè“‹æ‰€æœ‰é—œéµç³»çµ±å’Œç”¨æˆ¶é«”é©—æŒ‡æ¨™
- **å³æ™‚éŸ¿æ‡‰**: é—œéµç•°å¸¸åœ¨ 5 åˆ†é˜å…§è§¸ç™¼è­¦å ±
- **åˆ†å±¤è­¦å ±**: ä¸åŒç´šåˆ¥çš„å•é¡Œæ¡ç”¨ä¸åŒçš„é€šçŸ¥ç­–ç•¥
- **å¯è§€æ¸¬æ€§**: æä¾›å®Œæ•´çš„ç³»çµ±ç‹€æ…‹å¯è¦–æ€§

### å››å±¤ç›£æ§æ¶æ§‹
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     ç›£æ§é«”ç³»æ¶æ§‹                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ç¬¬ä¸€å±¤: ğŸ–¥ï¸ åŸºç¤è¨­æ–½ç›£æ§                              â”‚
â”‚    - Chrome Extension é‹è¡Œç‹€æ…‹                           â”‚
â”‚    - Extension å®‰è£/å¸è¼‰ç‡                              â”‚
â”‚    - ç³»çµ±è³‡æºä½¿ç”¨æƒ…æ³                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ç¬¬äºŒå±¤: ğŸ”§ æ‡‰ç”¨ç¨‹å¼ç›£æ§                              â”‚
â”‚    - API è«‹æ±‚æˆåŠŸç‡                                     â”‚
â”‚    - åŠŸèƒ½åŸ·è¡Œæ•ˆèƒ½                                       â”‚
â”‚    - éŒ¯èª¤ç‡å’Œç•°å¸¸åˆ†æ                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ç¬¬ä¸‰å±¤: ğŸ‘¤ ç”¨æˆ¶é«”é©—ç›£æ§                              â”‚
â”‚    - ç”¨æˆ¶äº’å‹•è¿½è¹¤                                       â”‚
â”‚    - é é¢è¼‰å…¥æ™‚é–“                                       â”‚
â”‚    - åŠŸèƒ½ä½¿ç”¨é »ç‡                                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ç¬¬å››å±¤: ğŸ’¼ æ¥­å‹™æŒ‡æ¨™ç›£æ§                              â”‚
â”‚    - Chrome Web Store è©•åˆ†                            â”‚
â”‚    - ç”¨æˆ¶å¢é•·èˆ‡ç•™å­˜                                     â”‚
â”‚    - åŠŸèƒ½æ¡ç”¨ç‡åˆ†æ                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸš¨ æ ¸å¿ƒè­¦å ±ç³»çµ±

### è­¦å ±ç­‰ç´šåˆ†é¡

#### ğŸ”´ Critical (ç·Šæ€¥)
**è§¸ç™¼æ¢ä»¶**:
- Extension å®Œå…¨ç„¡æ³•é‹è¡Œ
- éŒ¯èª¤ç‡ > 10%
- API è«‹æ±‚æˆåŠŸç‡ < 85%
- å¤§é‡ç”¨æˆ¶å›å ±ç›¸åŒå•é¡Œ (>50 å€‹/å°æ™‚)

**éŸ¿æ‡‰æ™‚é–“**: ç«‹å³ (0-5 åˆ†é˜)
**é€šçŸ¥ç®¡é“**: é›»è©±ã€ç°¡è¨Šã€Slack æ€¥è¨Š

#### ğŸŸ¡ Warning (è­¦å‘Š)
**è§¸ç™¼æ¢ä»¶**:
- éŒ¯èª¤ç‡ > 5%
- API éŸ¿æ‡‰æ™‚é–“ > 5 ç§’
- å…§å­˜ä½¿ç”¨é‡ > 80MB
- ç”¨æˆ¶è©•åˆ†ä¸‹é™ > 0.5 æ˜Ÿ

**éŸ¿æ‡‰æ™‚é–“**: 30 åˆ†é˜å…§
**é€šçŸ¥ç®¡é“**: Slackã€é›»å­éƒµä»¶

#### ğŸ”µ Info (è³‡è¨Š)
**è§¸ç™¼æ¢ä»¶**:
- æ–°ç‰ˆæœ¬ç™¼å¸ƒé€šçŸ¥
- å®šæœŸå¥åº·æª¢æŸ¥å ±å‘Š
- ç”¨æˆ¶æ•¸æ“šçµ±è¨ˆæ‘˜è¦

**éŸ¿æ‡‰æ™‚é–“**: ä¸éœ€è¦ç«‹å³å›æ‡‰
**é€šçŸ¥ç®¡é“**: é›»å­éƒµä»¶ã€Dashboard

### æ™ºæ…§è­¦å ±å¼•æ“

#### ç•°å¸¸æª¢æ¸¬ç®—æ³•
```javascript
// src/monitoring/anomaly-detector.js
class AnomalyDetector {
  constructor() {
    this.baselineWindow = 7 * 24 * 60 * 60 * 1000; // 7å¤©åŸºç·š
    this.thresholds = {
      error_rate: {
        warning: 0.05,  // 5%
        critical: 0.10  // 10%
      },
      response_time: {
        warning: 3000,   // 3ç§’
        critical: 5000   // 5ç§’
      },
      memory_usage: {
        warning: 67108864,  // 64MB
        critical: 104857600 // 100MB
      }
    };
  }
  
  analyzeMetrics(currentMetrics, historicalData) {
    const anomalies = [];
    
    // çµ±è¨ˆåŸºç·šè¨ˆç®—
    const baseline = this.calculateBaseline(historicalData);
    
    // æª¢æ¸¬éŒ¯èª¤ç‡ç•°å¸¸
    const errorRateAnomaly = this.detectErrorRateAnomaly(
      currentMetrics.error_rate, 
      baseline.error_rate
    );
    if (errorRateAnomaly) anomalies.push(errorRateAnomaly);
    
    // æª¢æ¸¬æ•ˆèƒ½å›æ­¸
    const performanceAnomaly = this.detectPerformanceRegression(
      currentMetrics.response_time,
      baseline.response_time
    );
    if (performanceAnomaly) anomalies.push(performanceAnomaly);
    
    // æª¢æ¸¬è¨˜æ†¶é«”æ´©æ¼
    const memoryAnomaly = this.detectMemoryLeak(
      currentMetrics.memory_usage,
      historicalData.memory_trend
    );
    if (memoryAnomaly) anomalies.push(memoryAnomaly);
    
    return anomalies;
  }
  
  detectErrorRateAnomaly(current, baseline) {
    const deviation = Math.abs(current - baseline.mean);
    const standardDeviation = baseline.stdDev;
    
    // Z-Score ç•°å¸¸æª¢æ¸¬
    const zScore = deviation / standardDeviation;
    
    if (current > this.thresholds.error_rate.critical || zScore > 3) {
      return {
        type: 'error_rate',
        level: 'critical',
        message: `éŒ¯èª¤ç‡ç•°å¸¸é«˜: ${(current * 100).toFixed(2)}%`,
        current_value: current,
        baseline_mean: baseline.mean,
        z_score: zScore
      };
    } else if (current > this.thresholds.error_rate.warning || zScore > 2) {
      return {
        type: 'error_rate',
        level: 'warning',
        message: `éŒ¯èª¤ç‡åé«˜: ${(current * 100).toFixed(2)}%`,
        current_value: current,
        baseline_mean: baseline.mean,
        z_score: zScore
      };
    }
    
    return null;
  }
  
  detectPerformanceRegression(currentResponseTime, baselineResponseTime) {
    const regressionThreshold = 1.5; // 50% æ•ˆèƒ½å›æ­¸é–¾å€¼
    const ratio = currentResponseTime / baselineResponseTime.mean;
    
    if (ratio > regressionThreshold && currentResponseTime > this.thresholds.response_time.critical) {
      return {
        type: 'performance_regression',
        level: 'critical',
        message: `åš´é‡æ•ˆèƒ½å›æ­¸: ${currentResponseTime}ms`,
        regression_ratio: ratio,
        baseline_mean: baselineResponseTime.mean
      };
    } else if (ratio > 1.2 && currentResponseTime > this.thresholds.response_time.warning) {
      return {
        type: 'performance_regression',
        level: 'warning',
        message: `æ•ˆèƒ½å›æ­¸è­¦å‘Š: ${currentResponseTime}ms`,
        regression_ratio: ratio,
        baseline_mean: baselineResponseTime.mean
      };
    }
    
    return null;
  }
}
```

#### è­¦å ±å»é‡èˆ‡èšåˆ
```javascript
// src/monitoring/alert-manager.js
class AlertManager {
  constructor() {
    this.activeAlerts = new Map();
    this.suppressionRules = {
      duplicate_window: 10 * 60 * 1000, // 10åˆ†é˜å»é‡
      escalation_delay: 30 * 60 * 1000  // 30åˆ†é˜å‡ç´š
    };
  }
  
  processAlert(alert) {
    const alertKey = this.generateAlertKey(alert);
    
    // æª¢æŸ¥æ˜¯å¦ç‚ºé‡è¤‡è­¦å ±
    if (this.isDuplicateAlert(alertKey, alert)) {
      this.updateAlertCount(alertKey);
      return false; // ä¸ç™¼é€é‡è¤‡è­¦å ±
    }
    
    // è¨˜éŒ„æ–°è­¦å ±
    this.activeAlerts.set(alertKey, {
      ...alert,
      first_occurrence: Date.now(),
      count: 1,
      escalated: false
    });
    
    // ç™¼é€è­¦å ±
    this.sendAlert(alert);
    
    // è¨­å®šå‡ç´šæª¢æŸ¥
    this.scheduleEscalation(alertKey, alert);
    
    return true;
  }
  
  isDuplicateAlert(alertKey, alert) {
    const existing = this.activeAlerts.get(alertKey);
    if (!existing) return false;
    
    const timeSinceFirst = Date.now() - existing.first_occurrence;
    return timeSinceFirst < this.suppressionRules.duplicate_window;
  }
  
  scheduleEscalation(alertKey, alert) {
    if (alert.level !== 'critical') return;
    
    setTimeout(() => {
      const activeAlert = this.activeAlerts.get(alertKey);
      if (activeAlert && !activeAlert.escalated) {
        // å‡ç´šè‡³æ›´é«˜ç´šåˆ¥é€šçŸ¥
        this.escalateAlert(activeAlert);
      }
    }, this.suppressionRules.escalation_delay);
  }
  
  escalateAlert(alert) {
    alert.escalated = true;
    
    // ç™¼é€å‡ç´šé€šçŸ¥ (é›»è©±/ç°¡è¨Š)
    this.sendEscalatedAlert({
      ...alert,
      message: `ğŸš¨ æœªè™•ç†çš„ç·Šæ€¥è­¦å ±: ${alert.message}`,
      escalated_at: Date.now()
    });
  }
}
```

## ğŸ“ˆ ç›£æ§æŒ‡æ¨™é«”ç³»

### Chrome Extension å°ˆç”¨æŒ‡æ¨™

#### é‹è¡Œæ™‚æŒ‡æ¨™æ”¶é›†
```javascript
// src/monitoring/extension-metrics.js
class ExtensionMetrics {
  constructor() {
    this.metricsBuffer = [];
    this.reportingInterval = 60000; // 1åˆ†é˜
    this.startPeriodicReporting();
  }
  
  collectRuntimeMetrics() {
    const metrics = {
      timestamp: Date.now(),
      extension_id: chrome.runtime.id,
      version: chrome.runtime.getManifest().version,
      
      // ç³»çµ±è³‡æºæŒ‡æ¨™
      memory: this.getMemoryUsage(),
      
      // åŠŸèƒ½ä½¿ç”¨æŒ‡æ¨™
      api_calls: this.getApiCallStats(),
      
      // éŒ¯èª¤æŒ‡æ¨™
      errors: this.getErrorStats(),
      
      // ç”¨æˆ¶äº’å‹•æŒ‡æ¨™
      user_interactions: this.getUserInteractionStats(),
      
      // Chrome Store æŒ‡æ¨™
      store_metrics: this.getStoreMetrics()
    };
    
    this.metricsBuffer.push(metrics);
    return metrics;
  }
  
  getMemoryUsage() {
    if (!performance.memory) return null;
    
    return {
      used_heap_size: performance.memory.usedJSHeapSize,
      total_heap_size: performance.memory.totalJSHeapSize,
      heap_size_limit: performance.memory.jsHeapSizeLimit,
      usage_percentage: (performance.memory.usedJSHeapSize / performance.memory.jsHeapSizeLimit) * 100
    };
  }
  
  getApiCallStats() {
    const stats = this.getStoredStats('api_calls') || {
      total_calls: 0,
      successful_calls: 0,
      failed_calls: 0,
      average_response_time: 0
    };
    
    return {
      ...stats,
      success_rate: stats.total_calls > 0 ? stats.successful_calls / stats.total_calls : 0,
      error_rate: stats.total_calls > 0 ? stats.failed_calls / stats.total_calls : 0
    };
  }
  
  getErrorStats() {
    const errors = this.getStoredStats('errors') || {
      javascript_errors: 0,
      api_errors: 0,
      extension_errors: 0
    };
    
    return {
      ...errors,
      total_errors: errors.javascript_errors + errors.api_errors + errors.extension_errors,
      error_rate: this.calculateErrorRate(errors)
    };
  }
  
  getUserInteractionStats() {
    return this.getStoredStats('user_interactions') || {
      popup_opens: 0,
      button_clicks: 0,
      feature_usage: {},
      session_duration: 0
    };
  }
  
  startPeriodicReporting() {
    setInterval(() => {
      const metrics = this.collectRuntimeMetrics();
      this.reportMetrics(metrics);
    }, this.reportingInterval);
  }
  
  reportMetrics(metrics) {
    // ç™¼é€åˆ°æœ¬åœ°å­˜å„²
    this.storeMetricsLocally(metrics);
    
    // ç™¼é€åˆ°ç›£æ§æœå‹™ (å¦‚æœæœ‰ç¶²è·¯é€£æ¥)
    if (navigator.onLine) {
      this.sendToMonitoringService(metrics);
    }
  }
}
```

#### æ¥­å‹™æŒ‡æ¨™è¿½è¹¤
```javascript
// src/monitoring/business-metrics.js
class BusinessMetrics {
  constructor() {
    this.userJourney = new UserJourneyTracker();
    this.featureAdoption = new FeatureAdoptionTracker();
  }
  
  trackUserJourney(event, data) {
    const journeyEvent = {
      timestamp: Date.now(),
      event_type: event,
      user_id: this.getUserId(),
      session_id: this.getSessionId(),
      data: data
    };
    
    this.userJourney.record(journeyEvent);
    
    // å³æ™‚åˆ†æé—œéµæ¥­å‹™æŒ‡æ¨™
    this.analyzeBusinessImpact(journeyEvent);
  }
  
  analyzeBusinessImpact(event) {
    // åˆ†æç”¨æˆ¶æµå¤±é»
    if (event.event_type === 'extension_error') {
      this.trackUserChurn(event);
    }
    
    // åˆ†æåŠŸèƒ½æ¡ç”¨ç‡
    if (event.event_type === 'feature_first_use') {
      this.featureAdoption.recordFirstUse(event.data.feature_name);
    }
    
    // åˆ†æç”¨æˆ¶æ»¿æ„åº¦æŒ‡æ¨™
    if (event.event_type === 'user_feedback') {
      this.analyzeUserSentiment(event.data);
    }
  }
  
  trackUserChurn(errorEvent) {
    const churnRisk = this.calculateChurnRisk(errorEvent);
    
    if (churnRisk > 0.7) { // 70% æµå¤±é¢¨éšªé–¾å€¼
      this.alertManager.processAlert({
        type: 'user_churn_risk',
        level: 'warning',
        message: `ç”¨æˆ¶æµå¤±é¢¨éšªè¼ƒé«˜: ${errorEvent.data.error_message}`,
        user_id: errorEvent.user_id,
        churn_risk_score: churnRisk
      });
    }
  }
}
```

### å¤–éƒ¨æœå‹™ç›£æ§

#### Chrome Web Store æŒ‡æ¨™ç›£æ§
```javascript
// src/monitoring/store-monitor.js
class ChromeStoreMonitor {
  constructor() {
    this.storeApi = new ChromeWebStoreAPI();
    this.checkInterval = 6 * 60 * 60 * 1000; // 6å°æ™‚æª¢æŸ¥ä¸€æ¬¡
    this.startMonitoring();
  }
  
  async monitorStoreMetrics() {
    try {
      const metrics = await this.fetchStoreMetrics();
      const analysis = this.analyzeStoreMetrics(metrics);
      
      // æª¢æŸ¥è©•åˆ†ä¸‹é™
      if (analysis.rating_decline > 0.5) {
        this.alertManager.processAlert({
          type: 'store_rating_decline',
          level: 'warning',
          message: `Chrome Store è©•åˆ†ä¸‹é™ ${analysis.rating_decline} æ˜Ÿ`,
          current_rating: metrics.rating,
          previous_rating: analysis.previous_rating
        });
      }
      
      // æª¢æŸ¥å®‰è£ç‡ç•°å¸¸
      if (analysis.install_rate_change < -0.2) { // 20% ä¸‹é™
        this.alertManager.processAlert({
          type: 'install_rate_decline',
          level: 'critical',
          message: `å®‰è£ç‡å¤§å¹…ä¸‹é™: ${(analysis.install_rate_change * 100).toFixed(1)}%`,
          current_installs: metrics.weekly_installs,
          change_percentage: analysis.install_rate_change * 100
        });
      }
      
      return metrics;
    } catch (error) {
      this.alertManager.processAlert({
        type: 'store_api_error',
        level: 'warning',
        message: `ç„¡æ³•ç²å– Chrome Store æŒ‡æ¨™: ${error.message}`
      });
    }
  }
  
  async fetchStoreMetrics() {
    // å¾ Chrome Web Store Developer API ç²å–æŒ‡æ¨™
    const response = await this.storeApi.getExtensionStats();
    
    return {
      rating: response.rating,
      rating_count: response.ratingCount,
      weekly_installs: response.weeklyInstalls,
      total_installs: response.totalInstalls,
      weekly_users: response.weeklyUsers,
      reviews: response.recentReviews
    };
  }
  
  startMonitoring() {
    this.monitorStoreMetrics(); // ç«‹å³åŸ·è¡Œä¸€æ¬¡
    
    setInterval(() => {
      this.monitorStoreMetrics();
    }, this.checkInterval);
  }
}
```

## ğŸ”§ ç›£æ§åŸºç¤è¨­æ–½

### æœ¬åœ°ç›£æ§å­˜å„²ç³»çµ±

#### æ•¸æ“šå­˜å„²èˆ‡ç®¡ç†
```javascript
// src/monitoring/local-storage.js
class MonitoringStorage {
  constructor() {
    this.storageQuota = 5 * 1024 * 1024; // 5MB é…é¡
    this.retentionPeriod = 30 * 24 * 60 * 60 * 1000; // 30å¤©ä¿ç•™æœŸ
    this.compressionEnabled = true;
  }
  
  async storeMetrics(metrics) {
    try {
      // å£“ç¸®æ•¸æ“šä»¥ç¯€çœç©ºé–“
      const compressedData = this.compressionEnabled 
        ? await this.compressData(metrics)
        : JSON.stringify(metrics);
      
      // ç”Ÿæˆå­˜å„²éµ
      const storageKey = `metrics_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      
      // æª¢æŸ¥å­˜å„²ç©ºé–“
      await this.ensureStorageSpace();
      
      // å­˜å„²æ•¸æ“š
      await chrome.storage.local.set({
        [storageKey]: {
          data: compressedData,
          timestamp: Date.now(),
          compressed: this.compressionEnabled
        }
      });
      
      return storageKey;
    } catch (error) {
      console.error('å­˜å„²ç›£æ§æ•¸æ“šå¤±æ•—:', error);
      throw error;
    }
  }
  
  async ensureStorageSpace() {
    const usage = await chrome.storage.local.getBytesInUse();
    
    if (usage > this.storageQuota * 0.8) { // 80% ä½¿ç”¨ç‡è§¸ç™¼æ¸…ç†
      await this.cleanupOldData();
    }
  }
  
  async cleanupOldData() {
    const allData = await chrome.storage.local.get();
    const cutoffTime = Date.now() - this.retentionPeriod;
    const keysToRemove = [];
    
    Object.entries(allData).forEach(([key, value]) => {
      if (key.startsWith('metrics_') && value.timestamp < cutoffTime) {
        keysToRemove.push(key);
      }
    });
    
    if (keysToRemove.length > 0) {
      await chrome.storage.local.remove(keysToRemove);
      console.log(`æ¸…ç†äº† ${keysToRemove.length} å€‹éæœŸçš„ç›£æ§æ•¸æ“šé …ç›®`);
    }
  }
  
  async queryMetrics(timeRange, metricTypes) {
    const allData = await chrome.storage.local.get();
    const results = [];
    
    Object.entries(allData).forEach(([key, value]) => {
      if (!key.startsWith('metrics_')) return;
      
      if (value.timestamp >= timeRange.start && value.timestamp <= timeRange.end) {
        const data = value.compressed 
          ? this.decompressData(value.data)
          : JSON.parse(value.data);
          
        // éæ¿¾æŒ‡æ¨™é¡å‹
        if (!metricTypes || metricTypes.some(type => data[type])) {
          results.push({
            timestamp: value.timestamp,
            data: data
          });
        }
      }
    });
    
    return results.sort((a, b) => a.timestamp - b.timestamp);
  }
}
```

#### ç›£æ§å„€è¡¨æ¿
```javascript
// src/monitoring/dashboard.js
class MonitoringDashboard {
  constructor() {
    this.storage = new MonitoringStorage();
    this.refreshInterval = 30000; // 30ç§’åˆ·æ–°
    this.charts = new Map();
  }
  
  async initialize() {
    await this.createDashboard();
    this.startAutoRefresh();
  }
  
  async createDashboard() {
    const dashboardHTML = `
      <div class="monitoring-dashboard">
        <div class="dashboard-header">
          <h2>ğŸ“Š Extension ç›£æ§å„€è¡¨æ¿</h2>
          <div class="last-updated">æœ€å¾Œæ›´æ–°: <span id="lastUpdated">-</span></div>
        </div>
        
        <div class="metrics-grid">
          <div class="metric-card critical-metrics">
            <h3>ğŸš¨ é—œéµæŒ‡æ¨™</h3>
            <div class="metric-value" id="errorRate">-</div>
            <div class="metric-label">éŒ¯èª¤ç‡</div>
          </div>
          
          <div class="metric-card performance-metrics">
            <h3>âš¡ æ•ˆèƒ½æŒ‡æ¨™</h3>
            <div class="metric-value" id="responseTime">-</div>
            <div class="metric-label">å¹³å‡éŸ¿æ‡‰æ™‚é–“</div>
          </div>
          
          <div class="metric-card memory-metrics">
            <h3>ğŸ§  è¨˜æ†¶é«”ä½¿ç”¨</h3>
            <div class="metric-value" id="memoryUsage">-</div>
            <div class="metric-label">è¨˜æ†¶é«”ä½¿ç”¨ç‡</div>
          </div>
          
          <div class="metric-card user-metrics">
            <h3>ğŸ‘¥ ç”¨æˆ¶æŒ‡æ¨™</h3>
            <div class="metric-value" id="activeUsers">-</div>
            <div class="metric-label">æ´»èºç”¨æˆ¶æ•¸</div>
          </div>
        </div>
        
        <div class="charts-container">
          <div class="chart-panel">
            <canvas id="errorRateChart"></canvas>
          </div>
          <div class="chart-panel">
            <canvas id="performanceChart"></canvas>
          </div>
        </div>
        
        <div class="alerts-panel">
          <h3>ğŸ”” æœ€è¿‘è­¦å ±</h3>
          <div id="recentAlerts" class="alerts-list">
            <!-- å‹•æ…‹å¡«å…… -->
          </div>
        </div>
      </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', dashboardHTML);
    await this.setupCharts();
  }
  
  async refreshDashboard() {
    const currentTime = Date.now();
    const timeRange = {
      start: currentTime - (24 * 60 * 60 * 1000), // 24å°æ™‚å‰
      end: currentTime
    };
    
    try {
      // ç²å–ç›£æ§æ•¸æ“š
      const metrics = await this.storage.queryMetrics(timeRange);
      
      if (metrics.length === 0) {
        this.showNoDataMessage();
        return;
      }
      
      // è¨ˆç®—èšåˆæŒ‡æ¨™
      const aggregated = this.aggregateMetrics(metrics);
      
      // æ›´æ–°å„€è¡¨æ¿
      this.updateMetricCards(aggregated);
      this.updateCharts(metrics);
      this.updateAlertsPanel(aggregated.alerts);
      
      // æ›´æ–°æ™‚é–“æˆ³
      document.getElementById('lastUpdated').textContent = new Date().toLocaleString();
      
    } catch (error) {
      console.error('åˆ·æ–°å„€è¡¨æ¿å¤±æ•—:', error);
      this.showErrorMessage(error.message);
    }
  }
  
  aggregateMetrics(metrics) {
    const aggregated = {
      error_rate: 0,
      avg_response_time: 0,
      memory_usage: 0,
      active_users: 0,
      alerts: []
    };
    
    if (metrics.length === 0) return aggregated;
    
    let totalErrors = 0, totalRequests = 0;
    let totalResponseTime = 0, responseTimeCount = 0;
    let totalMemoryUsage = 0;
    const uniqueUsers = new Set();
    
    metrics.forEach(metric => {
      const data = metric.data;
      
      // èšåˆéŒ¯èª¤ç‡
      if (data.errors && data.api_calls) {
        totalErrors += data.errors.total_errors;
        totalRequests += data.api_calls.total_calls;
      }
      
      // èšåˆéŸ¿æ‡‰æ™‚é–“
      if (data.api_calls && data.api_calls.average_response_time > 0) {
        totalResponseTime += data.api_calls.average_response_time;
        responseTimeCount++;
      }
      
      // èšåˆè¨˜æ†¶é«”ä½¿ç”¨
      if (data.memory && data.memory.usage_percentage) {
        totalMemoryUsage += data.memory.usage_percentage;
      }
      
      // è¨ˆç®—æ´»èºç”¨æˆ¶
      if (data.user_interactions && data.user_id) {
        uniqueUsers.add(data.user_id);
      }
    });
    
    // è¨ˆç®—å¹³å‡å€¼
    aggregated.error_rate = totalRequests > 0 ? (totalErrors / totalRequests) * 100 : 0;
    aggregated.avg_response_time = responseTimeCount > 0 ? totalResponseTime / responseTimeCount : 0;
    aggregated.memory_usage = metrics.length > 0 ? totalMemoryUsage / metrics.length : 0;
    aggregated.active_users = uniqueUsers.size;
    
    return aggregated;
  }
}
```

## ğŸ“± é€šçŸ¥èˆ‡è­¦å ±ç®¡é“

### å¤šç®¡é“é€šçŸ¥ç³»çµ±

#### Slack æ•´åˆ
```javascript
// src/monitoring/notifications/slack.js
class SlackNotifier {
  constructor(webhookUrl) {
    this.webhookUrl = webhookUrl;
    this.rateLimiter = new RateLimiter(10, 60000); // 10æ¢/åˆ†é˜
  }
  
  async sendAlert(alert) {
    if (!this.rateLimiter.isAllowed()) {
      console.warn('Slack é€šçŸ¥é »ç‡é™åˆ¶');
      return false;
    }
    
    const message = this.formatSlackMessage(alert);
    
    try {
      const response = await fetch(this.webhookUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(message)
      });
      
      return response.ok;
    } catch (error) {
      console.error('ç™¼é€ Slack é€šçŸ¥å¤±æ•—:', error);
      return false;
    }
  }
  
  formatSlackMessage(alert) {
    const emoji = this.getAlertEmoji(alert.level);
    const color = this.getAlertColor(alert.level);
    
    return {
      text: `${emoji} Extension ç›£æ§è­¦å ±`,
      attachments: [{
        color: color,
        fields: [
          {
            title: 'è­¦å ±é¡å‹',
            value: alert.type,
            short: true
          },
          {
            title: 'åš´é‡ç¨‹åº¦',
            value: alert.level.toUpperCase(),
            short: true
          },
          {
            title: 'æè¿°',
            value: alert.message,
            short: false
          },
          {
            title: 'æ™‚é–“',
            value: new Date(alert.timestamp).toLocaleString(),
            short: true
          }
        ],
        footer: 'Readmoo Extension Monitor',
        ts: Math.floor(alert.timestamp / 1000)
      }]
    };
  }
  
  getAlertEmoji(level) {
    const emojiMap = {
      'critical': 'ğŸš¨',
      'warning': 'âš ï¸',
      'info': 'â„¹ï¸'
    };
    return emojiMap[level] || 'ğŸ“Š';
  }
  
  getAlertColor(level) {
    const colorMap = {
      'critical': '#FF0000',
      'warning': '#FFA500',
      'info': '#0066CC'
    };
    return colorMap[level] || '#808080';
  }
}
```

#### é›»å­éƒµä»¶é€šçŸ¥
```javascript
// src/monitoring/notifications/email.js
class EmailNotifier {
  constructor() {
    this.templates = new EmailTemplates();
    this.rateLimiter = new RateLimiter(5, 60000); // 5å°/åˆ†é˜
  }
  
  async sendAlert(alert, recipients) {
    if (!this.rateLimiter.isAllowed()) {
      console.warn('é›»å­éƒµä»¶é€šçŸ¥é »ç‡é™åˆ¶');
      return false;
    }
    
    const template = this.templates.getAlertTemplate(alert.level);
    const htmlContent = this.renderTemplate(template, alert);
    
    const emailData = {
      to: recipients,
      subject: this.generateSubject(alert),
      html: htmlContent,
      priority: alert.level === 'critical' ? 'high' : 'normal'
    };
    
    return await this.sendEmail(emailData);
  }
  
  generateSubject(alert) {
    const prefix = alert.level === 'critical' ? 'ğŸš¨ ç·Šæ€¥' : 'âš ï¸ è­¦å ±';
    return `${prefix} - Readmoo Extension: ${alert.message}`;
  }
  
  renderTemplate(template, alert) {
    return template
      .replace('{{ALERT_LEVEL}}', alert.level)
      .replace('{{ALERT_MESSAGE}}', alert.message)
      .replace('{{ALERT_TYPE}}', alert.type)
      .replace('{{TIMESTAMP}}', new Date(alert.timestamp).toLocaleString())
      .replace('{{ADDITIONAL_DATA}}', this.formatAdditionalData(alert.data));
  }
}
```

### è­¦å ±å‡ç´šæ©Ÿåˆ¶

#### è‡ªå‹•å‡ç´šæµç¨‹
```javascript
// src/monitoring/escalation.js
class AlertEscalation {
  constructor() {
    this.escalationRules = [
      {
        level: 'critical',
        timeLimit: 15 * 60 * 1000, // 15åˆ†é˜
        actions: ['phone', 'sms', 'slack_urgent']
      },
      {
        level: 'warning',
        timeLimit: 60 * 60 * 1000, // 1å°æ™‚
        actions: ['email', 'slack']
      }
    ];
    
    this.acknowledgments = new Map();
    this.escalationTimers = new Map();
  }
  
  processAlert(alert) {
    const rule = this.escalationRules.find(r => r.level === alert.level);
    if (!rule) return;
    
    // ç«‹å³ç™¼é€åˆå§‹é€šçŸ¥
    this.sendInitialNotifications(alert, rule.actions);
    
    // è¨­ç½®å‡ç´šè¨ˆæ™‚å™¨
    if (alert.level === 'critical') {
      this.setEscalationTimer(alert, rule.timeLimit);
    }
  }
  
  setEscalationTimer(alert, timeLimit) {
    const alertKey = this.generateAlertKey(alert);
    
    const timer = setTimeout(() => {
      if (!this.isAcknowledged(alertKey)) {
        this.escalateAlert(alert);
      }
    }, timeLimit);
    
    this.escalationTimers.set(alertKey, timer);
  }
  
  escalateAlert(alert) {
    // ç™¼é€å‡ç´šé€šçŸ¥
    this.sendEscalatedNotifications(alert);
    
    // è¨˜éŒ„å‡ç´šäº‹ä»¶
    this.logEscalation(alert);
    
    // é€šçŸ¥ç®¡ç†å±¤
    if (alert.level === 'critical') {
      this.notifyManagement(alert);
    }
  }
  
  acknowledgeAlert(alertKey, acknowledger) {
    this.acknowledgments.set(alertKey, {
      acknowledger: acknowledger,
      timestamp: Date.now()
    });
    
    // å–æ¶ˆå‡ç´šè¨ˆæ™‚å™¨
    const timer = this.escalationTimers.get(alertKey);
    if (timer) {
      clearTimeout(timer);
      this.escalationTimers.delete(alertKey);
    }
  }
}
```

## ğŸ” ç›£æ§åˆ†æèˆ‡å ±å‘Š

### è‡ªå‹•åŒ–å ±å‘Šç³»çµ±

#### æ¯æ—¥ç›£æ§å ±å‘Š
```javascript
// src/monitoring/reporting.js
class MonitoringReporter {
  constructor() {
    this.storage = new MonitoringStorage();
    this.scheduler = new ReportScheduler();
  }
  
  async generateDailyReport(date = new Date()) {
    const reportData = await this.collectDailyMetrics(date);
    const analysis = await this.analyzeMetrics(reportData);
    
    const report = {
      date: date.toISOString().split('T')[0],
      summary: this.generateSummary(analysis),
      metrics: reportData,
      alerts: analysis.alerts,
      recommendations: analysis.recommendations,
      trends: analysis.trends
    };
    
    // ç”Ÿæˆä¸åŒæ ¼å¼çš„å ±å‘Š
    const htmlReport = this.generateHTMLReport(report);
    const markdownReport = this.generateMarkdownReport(report);
    
    // ç™¼é€å ±å‘Š
    await this.distributeReport(report, htmlReport, markdownReport);
    
    return report;
  }
  
  generateSummary(analysis) {
    const summary = {
      overall_health: this.calculateOverallHealth(analysis),
      key_issues: analysis.critical_issues,
      performance_score: analysis.performance_score,
      availability: analysis.availability_percentage
    };
    
    // ç”Ÿæˆå»ºè­°
    if (summary.overall_health < 0.8) {
      summary.action_required = true;
      summary.priority_actions = this.generatePriorityActions(analysis);
    }
    
    return summary;
  }
  
  calculateOverallHealth(analysis) {
    const weights = {
      error_rate: 0.3,
      performance: 0.25,
      availability: 0.25,
      user_satisfaction: 0.2
    };
    
    const scores = {
      error_rate: Math.max(0, 1 - (analysis.error_rate / 0.1)), // 10%ç‚ºæœ€ä½åˆ†
      performance: Math.max(0, 1 - (analysis.avg_response_time / 10000)), // 10sç‚ºæœ€ä½åˆ†
      availability: analysis.availability_percentage / 100,
      user_satisfaction: analysis.user_satisfaction_score / 5 // 5æ˜Ÿç‚ºæ»¿åˆ†
    };
    
    return Object.entries(weights).reduce((total, [key, weight]) => {
      return total + (scores[key] * weight);
    }, 0);
  }
  
  async distributeReport(report, htmlReport, markdownReport) {
    const recipients = await this.getReportRecipients();
    
    // ç™¼é€ HTML å ±å‘Šè‡³ç®¡ç†å±¤
    await this.emailNotifier.sendReport(
      recipients.management,
      'ğŸ“Š Readmoo Extension æ¯æ—¥ç›£æ§å ±å‘Š',
      htmlReport
    );
    
    // ç™¼é€æ‘˜è¦è‡³ Slack
    await this.slackNotifier.sendReportSummary(report.summary);
    
    // å­˜å„²å ±å‘Šä¾›å¾ŒçºŒåˆ†æ
    await this.storage.storeReport(report);
  }
}
```

#### è¶¨å‹¢åˆ†æèˆ‡é æ¸¬
```javascript
// src/monitoring/trend-analyzer.js
class TrendAnalyzer {
  constructor() {
    this.storage = new MonitoringStorage();
    this.predictionModels = new Map();
  }
  
  async analyzeTrends(metricType, timeRange = 30) {
    const historicalData = await this.getHistoricalData(metricType, timeRange);
    
    if (historicalData.length < 7) {
      return { status: 'insufficient_data' };
    }
    
    const trends = {
      direction: this.calculateTrendDirection(historicalData),
      strength: this.calculateTrendStrength(historicalData),
      prediction: await this.predictFutureTrend(historicalData),
      anomalies: this.detectAnomalies(historicalData),
      seasonality: this.analyzeSeasonality(historicalData)
    };
    
    return trends;
  }
  
  calculateTrendDirection(data) {
    const n = data.length;
    if (n < 2) return 'stable';
    
    const firstHalf = data.slice(0, Math.floor(n/2));
    const secondHalf = data.slice(Math.floor(n/2));
    
    const firstAvg = firstHalf.reduce((a, b) => a + b.value, 0) / firstHalf.length;
    const secondAvg = secondHalf.reduce((a, b) => a + b.value, 0) / secondHalf.length;
    
    const change = (secondAvg - firstAvg) / firstAvg;
    
    if (Math.abs(change) < 0.05) return 'stable';
    return change > 0 ? 'increasing' : 'decreasing';
  }
  
  async predictFutureTrend(historicalData) {
    const model = this.getOrCreatePredictionModel(historicalData);
    const prediction = model.predict(7); // é æ¸¬æœªä¾†7å¤©
    
    return {
      values: prediction.values,
      confidence: prediction.confidence,
      warning_threshold: prediction.warningThreshold
    };
  }
  
  detectAnomalies(data) {
    const values = data.map(d => d.value);
    const mean = values.reduce((a, b) => a + b, 0) / values.length;
    const stdDev = Math.sqrt(values.reduce((sq, n) => sq + Math.pow(n - mean, 2), 0) / values.length);
    
    const anomalies = data.filter(d => {
      const zScore = Math.abs((d.value - mean) / stdDev);
      return zScore > 2.5; // 2.5 æ¨™æº–å·®ç‚ºç•°å¸¸é–¾å€¼
    });
    
    return anomalies.map(a => ({
      timestamp: a.timestamp,
      value: a.value,
      severity: this.calculateAnomalySeverity(a.value, mean, stdDev)
    }));
  }
}
```

## ğŸ“š ç›¸é—œè³‡æº

### å…§éƒ¨æ–‡ä»¶é€£çµ
- [æ•ˆèƒ½ç›£æ§é«”ç³»](../performance/monitoring-system.md)
- [CI/CD æµæ°´ç·šè¨­è¨ˆ](./cicd-pipeline.md)
- [Chrome Store ä¸Šæ¶æŒ‡å—](./chrome-store-guide.md)
- [ç‰ˆæœ¬ç™¼å¸ƒç­–ç•¥](./release-strategy.md)

### å¤–éƒ¨åƒè€ƒè³‡æº
- [Chrome Extension Performance API](https://developer.chrome.com/docs/extensions/reference/performance/)
- [Web Vitals æŒ‡æ¨™èªªæ˜](https://web.dev/vitals/)
- [Slack Webhook API](https://api.slack.com/messaging/webhooks)
- [Chrome Web Store Developer API](https://developers.google.com/webstore/api/)

## âœ… ç›£æ§ç³»çµ±æª¢æŸ¥æ¸…å–®

å®Œæ•´çš„ç›£æ§ç³»çµ±è¨­ç½®æª¢æŸ¥é …ç›®ï¼š

### åŸºç¤ç›£æ§è¨­ç½®
- [ ] Extension é‹è¡Œæ™‚ç›£æ§å·²å•Ÿç”¨
- [ ] è¨˜æ†¶é«”ä½¿ç”¨é‡è¿½è¹¤æ­£å¸¸é‹è¡Œ
- [ ] API è«‹æ±‚ç›£æ§å·²é…ç½®
- [ ] éŒ¯èª¤æ•ç²èˆ‡å ±å‘Šæ©Ÿåˆ¶å°±ç·’
- [ ] ç”¨æˆ¶äº’å‹•è¿½è¹¤å·²å¯¦æ–½

### è­¦å ±ç³»çµ±é…ç½®
- [ ] è­¦å ±ç­‰ç´šèˆ‡é–¾å€¼å·²å®šç¾©
- [ ] å¤šç®¡é“é€šçŸ¥ç³»çµ±å·²è¨­ç½® (Slack, Email)
- [ ] è­¦å ±å»é‡èˆ‡èšåˆæ©Ÿåˆ¶é‹è¡Œæ­£å¸¸
- [ ] å‡ç´šæµç¨‹èˆ‡æ™‚é–“é™åˆ¶å·²é…ç½®
- [ ] è­¦å ±ç¢ºèªèˆ‡è§£é™¤æ©Ÿåˆ¶æ­£å¸¸

### ç›£æ§å„€è¡¨æ¿
- [ ] å³æ™‚ç›£æ§å„€è¡¨æ¿å¯æ­£å¸¸è¨ªå•
- [ ] é—œéµæŒ‡æ¨™é¡¯ç¤ºæ­£ç¢º
- [ ] æ­·å²æ•¸æ“šæŸ¥è©¢åŠŸèƒ½æ­£å¸¸
- [ ] åœ–è¡¨èˆ‡è¦–è¦ºåŒ–å…ƒä»¶é‹è¡Œè‰¯å¥½
- [ ] è­¦å ±é¢æ¿é¡¯ç¤ºæœ€æ–°ç‹€æ…‹

### æ•¸æ“šç®¡ç†
- [ ] æœ¬åœ°å­˜å„²ç³»çµ±é‹è¡Œæ­£å¸¸
- [ ] æ•¸æ“šå£“ç¸®èˆ‡æ¸…ç†æ©Ÿåˆ¶å•Ÿç”¨
- [ ] å­˜å„²ç©ºé–“ç›£æ§èˆ‡ç®¡ç†
- [ ] æ•¸æ“šä¿ç•™æ”¿ç­–å·²å¯¦æ–½
- [ ] å‚™ä»½èˆ‡æ¢å¾©æ©Ÿåˆ¶å°±ç·’

### å ±å‘Šèˆ‡åˆ†æ
- [ ] è‡ªå‹•åŒ–æ—¥å ±ç”Ÿæˆæ­£å¸¸
- [ ] è¶¨å‹¢åˆ†æåŠŸèƒ½é‹è¡Œ
- [ ] ç•°å¸¸æª¢æ¸¬ç®—æ³•å·²å•Ÿç”¨
- [ ] é æ¸¬æ¨¡å‹æ­£å¸¸é‹ä½œ
- [ ] å ±å‘Šåˆ†ç™¼æ©Ÿåˆ¶æ­£ç¢ºè¨­ç½®

### å¤–éƒ¨æ•´åˆ
- [ ] Chrome Web Store æŒ‡æ¨™ç›£æ§
- [ ] ç¬¬ä¸‰æ–¹æœå‹™ç‹€æ…‹ç›£æ§
- [ ] API æ•´åˆæ¸¬è©¦é€šé
- [ ] ç¶²çµ¡é€£æ¥æª¢æ¸¬æ©Ÿåˆ¶
- [ ] æ•…éšœè½‰ç§»æ©Ÿåˆ¶å°±ç·’

---

**ğŸ“Š ç›£æ§èˆ‡è­¦å ±ç³»çµ±å·²å®Œæ•´å»ºç«‹ï¼Œç¢ºä¿ Extension çš„é«˜å¯ç”¨æ€§å’Œå„ªç•°æ€§èƒ½ï¼**