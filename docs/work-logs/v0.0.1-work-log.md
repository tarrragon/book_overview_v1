# v0.0.1 工作日誌

**版本**: v0.0.1  
**開始日期**: 2025-07-29  
**狀態**: 🟡 開發中

## 📋 本版本目標

- 建立完整的TDD測試框架
- 修復現有失敗的測試（紅燈狀態）
- 確保所有測試通過後再進行功能開發

## 🔄 TDD 循環記錄

### 循環 #1: Chrome Storage 配額錯誤處理 ✅

**日期**: 2025-07-29  
**狀態**: 已完成

#### 🔴 紅燈階段

- **問題描述**: Chrome Storage 配額錯誤處理測試失敗
- **錯誤訊息**: `expect(received).rejects.toThrow() Received promise resolved instead of rejected`
- **原因分析**: Chrome Storage 模擬中 `chrome.runtime.lastError` 設置順序錯誤

#### 🟢 綠燈階段

- **修復方式**: 調整 Chrome Storage 模擬邏輯
- **具體變更**:
  ```javascript
  // 修正前
  chrome.storage.local.set.mockImplementation((items, callback) => {
    callback();
    chrome.runtime.lastError = error;
  });

  // 修正後  
  chrome.storage.local.set.mockImplementation((items, callback) => {
    chrome.runtime.lastError = error;
    callback();
  });
  ```
- **測試結果**: ✅ 通過

#### 🔵 重構階段

- **改善項目**: 
  - 加入模擬狀態清理邏輯
  - 移除不相容的 `chrome.runtime.lastError` 手動設置
- **品質提升**: 測試更穩定，模擬更準確

#### 📝 學習重點

- jest-chrome 對 `chrome.runtime.lastError` 有特殊類型檢查
- Chrome API 模擬需要注意錯誤設置的時機
- 測試清理很重要，避免測試間相互影響

---

### 循環 #2: localStorage 模擬修正 ✅

**日期**: 2025-07-29  
**狀態**: 已完成

#### 🔴 紅燈階段

- **問題描述**: localStorage 模擬機制測試失敗
- **錯誤訊息**: `Matcher error: received value must be a mock or spy function`
- **原因分析**: localStorage 方法不是 Jest 模擬函數

#### 🟢 綠燈階段

- **修復方式**: 在 test-setup.js 中建立完整的 localStorage 模擬
- **具體變更**:
  ```javascript
  // 在 test-setup.js 中新增
  const localStorageMock = {
    getItem: jest.fn(),
    setItem: jest.fn(),
    removeItem: jest.fn(),
    clear: jest.fn(),
    length: 0,
    key: jest.fn()
  };
  Object.defineProperty(window, 'localStorage', {
    value: localStorageMock
  });
  global.localStorage = localStorageMock;
  ```
- **測試變更**: 加入模擬行為設定
  ```javascript
  localStorage.getItem.mockReturnValue(testData);
  localStorage.setItem.mockImplementation(() => {});
  ```
- **測試結果**: ✅ 通過

#### 🔵 重構階段

- **改善項目**: 
  - 在 cleanup 函數中加入 localStorage 模擬清理
  - 確保測試間不會相互影響
- **品質提升**: localStorage 模擬更完整，測試更可靠

#### 📝 學習重點

- Jest 需要明確模擬 localStorage 才能在測試中使用
- 模擬物件需要提供完整的 localStorage API
- 測試清理很重要，確保每個測試都有乾淨的環境

---

### 循環 #3: 資料格式驗證功能 ✅

**日期**: 2025-07-29  
**狀態**: 已完成

#### 🔴 紅燈階段

- **問題描述**: 資料格式驗證測試失敗
- **錯誤訊息**: `expect(received).toBe(expected) Expected: true Received: "https://example.com/cover.jpg"`
- **原因分析**: 測試中的 `validateBook` 函數邏輯錯誤，`book.id && book.title && book.cover` 返回最後一個真值而非布林值

#### 🟢 綠燈階段

- **修復方式**: 重寫驗證函數邏輯，實現完整的資料格式驗證
- **具體變更**:
  ```javascript
  const validateBook = (book) => {
    // 驗證必要欄位存在且有效
    if (!book || typeof book !== 'object') return false;
    if (!book.id || typeof book.id !== 'string') return false;
    if (!book.title || typeof book.title !== 'string') return false;
    if (!book.cover || typeof book.cover !== 'string') return false;
    
    // 驗證 cover 是有效的 URL
    try {
      new URL(book.cover);
    } catch {
      return false;
    }
    
    return true;
  };
  ```
- **測試結果**: ✅ 通過

#### 🔵 重構階段

- **改善項目**: 
  - 加入完整的類型檢查
  - 加入 URL 格式驗證
  - 提升資料驗證的可靠性
- **品質提升**: 驗證邏輯更嚴謹，能正確區分有效和無效資料

#### 📝 學習重點

- JavaScript 中 `&&` 運算子返回最後一個真值，而非布林值
- 資料驗證需要明確的類型檢查和格式驗證
- URL 驗證可使用原生 `URL` 構造函數

---

### 循環 #4: 多書城支援的書籍ID處理邏輯 ✅

**日期**: 2025-07-29  
**狀態**: 已完成

#### 🔴 紅燈階段

- **問題描述**: 書籍ID處理測試失敗，單一書城設計不支援未來擴展
- **錯誤訊息**: `expect(received).toBeNull() Received: "123"`
- **原因分析**: 
  - 原測試邏輯只檢查URL模式，未考慮域名驗證
  - 缺乏多書城支援的架構設計
  - 沒有考慮未來擴展性需求
  - 用戶明確要求支援其他書城（博客來、金石堂等）

#### 🟢 綠燈階段

- **修復方式**: 重新設計支援多書城的ID提取邏輯
- **架構改進**:
  ```javascript
  const supportedBookstores = {
    'readmoo': {
      domain: 'readmoo.com',
      pattern: /\/api\/reader\/(\d+)/
    }
    // 預留其他書城擴展空間
  };
  
  const extractBookId = (href) => {
    if (!href || typeof href !== 'string') return null;
    
    try {
      const urlObj = new URL(href);
      
      // 檢查是否為支援的書城
      for (const [storeName, config] of Object.entries(supportedBookstores)) {
        if (urlObj.hostname === config.domain) {
          const match = href.match(config.pattern);
          return match ? match[1] : null;
        }
      }
      return null;
    } catch {
      return null; // 無效URL
    }
  };
  ```
- **測試增強**: 新增有效ID提取測試，確保邏輯完整性
- **測試結果**: ✅ 100% 通過 (50/50)

#### 🔵 重構階段

- **架構優化**: 
  - 設計可配置的書城支援系統
  - 預留未來擴展介面
  - 完善錯誤處理和邊界情況
- **品質提升**: 
  - 支援多書城架構
  - 更嚴格的URL和域名驗證
  - 可擴展的設計模式
- **專案目標更新**: 在 README.md 和 todolist.md 中加入多書城支援目標

#### 📝 學習重點

- 系統設計需要考慮未來擴展性
- 配置驅動的架構比硬編碼更靈活  
- URL 物件提供更可靠的域名解析
- 測試應該覆蓋正面和負面情況
- 架構設計應該預留用戶需求的擴展空間

---

### 專案結構調整：架構優先順序重組 🏗

**日期**: 2025-07-29  
**類型**: 架構決策調整  
**狀態**: 已完成

#### 📋 調整原因

- **用戶需求**: 明確要求先建立事件系統架構，再實現Chrome Extension基礎設施
- **架構考量**: 避免後期因事件系統導入而需要大幅重構現有程式碼
- **技術決策**: 事件系統作為整個專案的「神經系統」，所有模組通信都依賴它

#### 🔄 調整內容

**原順序**:
1. Chrome Extension 基礎架構 (manifest.json, background, content script)
2. 事件系統核心實現
3. 資料提取器實現

**新順序**:
1. **🎭 階段一：事件系統核心** - 系統通信基礎
2. **📚 階段二：資料提取器** - 基於事件系統的資料提取
3. **🏗 階段三：Chrome Extension 基礎架構** - 整合事件系統
4. **💾 階段四：儲存系統** - 事件驅動的資料儲存
5. **🎨 階段五：UI 組件** - 使用者界面實現

#### 🎯 架構優勢

- **避免重構風險**: 先建立核心架構，所有後續模組基於此開發
- **系統完整性**: 每個階段都有明確的依賴關係
- **TDD 友好**: 事件系統有清晰的輸入/輸出界面，容易測試
- **模組解耦**: 通過事件系統實現模組間的鬆散耦合

#### 📝 更新內容

- `docs/todolist.md`: 重新組織所有階段順序
- 新增「開發階段概覽」說明架構優先順序
- 在各階段標題中標註「基於事件系統」或「事件驅動」
- 明確事件觸發規範（如：`EXTRACTOR.DATA.EXTRACTED`）

#### 💡 學習重點

- 架構設計應該優先於功能實現
- 核心系統（如事件總線）是其他模組的基礎
- 合理的開發順序可以大幅降低重構成本
- 文檔結構調整也是重要的架構決策，需要記錄

---

### 循環 #5: 事件總線核心實現 ✅

**日期**: 2025-07-29  
**狀態**: 已完成  
**類型**: 新功能TDD循環

#### 🔴 紅燈階段

- **目標**: 實現事件系統核心 - EventBus 類別
- **測試建立**: 創建 `tests/unit/core/event-bus.test.js` 包含15個全面測試
- **涵蓋功能**:
  - 事件註冊機制（on, once, off, removeAllListeners）
  - 事件觸發機制（emit，同步/非同步支援）
  - 事件優先級處理（數字越小優先級越高）
  - 錯誤處理機制（錯誤隔離，不影響其他監聽器）
  - 統計和監控功能（執行次數、時間追蹤）
  - 記憶體管理（清理、最大監聽器限制）
- **紅燈確認**: 所有15個測試失敗 - `Cannot find module '@/core/event-bus'`

#### 🟢 綠燈階段

- **實現位置**: `src/core/event-bus.js`
- **核心架構**:
  ```javascript
  class EventBus {
    // 事件監聽器註冊表 Map<eventType, ListenerWrapper[]>
    // 支援優先級排序和一次性監聽器
    // 完整的統計追蹤和錯誤隔離機制
  }
  ```
- **關鍵功能實現**:
  - Observer模式的事件總線
  - 優先級插入排序算法
  - 非同步事件處理支援
  - 高精度時間統計（performance.now）
  - 完整的錯誤隔離機制
- **修復的問題**:
  1. Jest配置問題：`moduleNameMapping` → `moduleNameMapper`
  2. 優先級邏輯：修復falsy值問題（`priority !== undefined`）
  3. 一次性監聽器：確保異步完成後正確移除
  4. 時間統計：使用高精度時間測量
- **測試結果**: ✅ 15/15 測試通過 (100%)

#### 🔵 重構階段

- **驗證**: 完整測試套件執行 - 65/65 測試通過
- **無破壞性變更**: 所有現有測試繼續通過
- **代碼品質**: 
  - 完整的JSDoc註解
  - 清晰的錯誤處理
  - 高效的優先級排序
  - 記憶體安全的清理機制

#### 📝 學習重點

- **TDD實踐**: 完整的紅綠重構循環，測試驅動設計
- **JavaScript陷阱**: falsy值（0, false, null）在預設值設定的問題
- **Observer模式**: 事件總線的核心設計模式實現
- **優先級算法**: 插入排序在動態優先級佇列的應用
- **性能監控**: performance.now()提供更精確的時間測量
- **錯誤隔離**: Promise.resolve()確保同步/異步處理一致性

#### 🚀 建立的基礎

- **系統核心**: 所有模組通信的基礎架構
- **擴展準備**: 支援未來Chrome Extension模組整合
- **測試框架**: 建立事件系統測試的標準模式
- **架構模式**: 為後續事件處理器和橋接器奠定基礎

---

## 🐛 問題追蹤

### 已解決 ✅

1. Chrome Storage 配額錯誤處理
2. localStorage 模擬修正  
3. 資料格式驗證功能
4. 多書城書籍ID處理邏輯
5. **事件總線核心實現** - 事件系統基礎架構

## 📊 測試狀態

- **測試**: 65/65 通過 (100%)
- **新增**: EventBus核心 15個測試
- **階段**: 事件系統第一個TDD循環完成

## 🔗 相關提交

- `2da7bfb` - 測試框架建置
- `25f79fe` - Chrome Storage修復
- `6d5f6ab` - localStorage修復  
- `aa7171d` - 資料驗證修復
- （待新增）- 多書城支援實現

---

**工作日誌建立**: 2025-07-29  
**最後更新**: 2025-07-29 