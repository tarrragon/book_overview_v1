# v0.0.1 工作日誌

**版本**: v0.0.1  
**開始日期**: 2025-07-29  
**狀態**: 🟡 開發中

## 📋 本版本目標

- 建立完整的TDD測試框架
- 修復現有失敗的測試（紅燈狀態）
- 確保所有測試通過後再進行功能開發

## 🔄 TDD 循環記錄

### 循環 #1: Chrome Storage 配額錯誤處理 ✅

**日期**: 2025-07-29  
**狀態**: 已完成

#### 🔴 紅燈階段

- **問題描述**: Chrome Storage 配額錯誤處理測試失敗
- **錯誤訊息**: `expect(received).rejects.toThrow() Received promise resolved instead of rejected`
- **原因分析**: Chrome Storage 模擬中 `chrome.runtime.lastError` 設置順序錯誤

#### 🟢 綠燈階段

- **修復方式**: 調整 Chrome Storage 模擬邏輯
- **具體變更**:
  ```javascript
  // 修正前
  chrome.storage.local.set.mockImplementation((items, callback) => {
    callback();
    chrome.runtime.lastError = error;
  });

  // 修正後  
  chrome.storage.local.set.mockImplementation((items, callback) => {
    chrome.runtime.lastError = error;
    callback();
  });
  ```
- **測試結果**: ✅ 通過

#### 🔵 重構階段

- **改善項目**: 
  - 加入模擬狀態清理邏輯
  - 移除不相容的 `chrome.runtime.lastError` 手動設置
- **品質提升**: 測試更穩定，模擬更準確

#### 📝 學習重點

- jest-chrome 對 `chrome.runtime.lastError` 有特殊類型檢查
- Chrome API 模擬需要注意錯誤設置的時機
- 測試清理很重要，避免測試間相互影響

---

### 循環 #2: localStorage 模擬修正 ✅

**日期**: 2025-07-29  
**狀態**: 已完成

#### 🔴 紅燈階段

- **問題描述**: localStorage 模擬機制測試失敗
- **錯誤訊息**: `Matcher error: received value must be a mock or spy function`
- **原因分析**: localStorage 方法不是 Jest 模擬函數

#### 🟢 綠燈階段

- **修復方式**: 在 test-setup.js 中建立完整的 localStorage 模擬
- **具體變更**:
  ```javascript
  // 在 test-setup.js 中新增
  const localStorageMock = {
    getItem: jest.fn(),
    setItem: jest.fn(),
    removeItem: jest.fn(),
    clear: jest.fn(),
    length: 0,
    key: jest.fn()
  };
  Object.defineProperty(window, 'localStorage', {
    value: localStorageMock
  });
  global.localStorage = localStorageMock;
  ```
- **測試變更**: 加入模擬行為設定
  ```javascript
  localStorage.getItem.mockReturnValue(testData);
  localStorage.setItem.mockImplementation(() => {});
  ```
- **測試結果**: ✅ 通過

#### 🔵 重構階段

- **改善項目**: 
  - 在 cleanup 函數中加入 localStorage 模擬清理
  - 確保測試間不會相互影響
- **品質提升**: localStorage 模擬更完整，測試更可靠

#### 📝 學習重點

- Jest 需要明確模擬 localStorage 才能在測試中使用
- 模擬物件需要提供完整的 localStorage API
- 測試清理很重要，確保每個測試都有乾淨的環境

---

### 循環 #3: 資料格式驗證功能 ✅

**日期**: 2025-07-29  
**狀態**: 已完成

#### 🔴 紅燈階段

- **問題描述**: 資料格式驗證測試失敗
- **錯誤訊息**: `expect(received).toBe(expected) Expected: true Received: "https://example.com/cover.jpg"`
- **原因分析**: 測試中的 `validateBook` 函數邏輯錯誤，`book.id && book.title && book.cover` 返回最後一個真值而非布林值

#### 🟢 綠燈階段

- **修復方式**: 重寫驗證函數邏輯，實現完整的資料格式驗證
- **具體變更**:
  ```javascript
  const validateBook = (book) => {
    // 驗證必要欄位存在且有效
    if (!book || typeof book !== 'object') return false;
    if (!book.id || typeof book.id !== 'string') return false;
    if (!book.title || typeof book.title !== 'string') return false;
    if (!book.cover || typeof book.cover !== 'string') return false;
    
    // 驗證 cover 是有效的 URL
    try {
      new URL(book.cover);
    } catch {
      return false;
    }
    
    return true;
  };
  ```
- **測試結果**: ✅ 通過

#### 🔵 重構階段

- **改善項目**: 
  - 加入完整的類型檢查
  - 加入 URL 格式驗證
  - 提升資料驗證的可靠性
- **品質提升**: 驗證邏輯更嚴謹，能正確區分有效和無效資料

#### 📝 學習重點

- JavaScript 中 `&&` 運算子返回最後一個真值，而非布林值
- 資料驗證需要明確的類型檢查和格式驗證
- URL 驗證可使用原生 `URL` 構造函數

---

### 循環 #4: 多書城支援的書籍ID處理邏輯 ✅

**日期**: 2025-07-29  
**狀態**: 已完成

#### 🔴 紅燈階段

- **問題描述**: 書籍ID處理測試失敗，單一書城設計不支援未來擴展
- **錯誤訊息**: `expect(received).toBeNull() Received: "123"`
- **原因分析**: 
  - 原測試邏輯只檢查URL模式，未考慮域名驗證
  - 缺乏多書城支援的架構設計
  - 沒有考慮未來擴展性需求
  - 用戶明確要求支援其他書城（博客來、金石堂等）

#### 🟢 綠燈階段

- **修復方式**: 重新設計支援多書城的ID提取邏輯
- **架構改進**:
  ```javascript
  const supportedBookstores = {
    'readmoo': {
      domain: 'readmoo.com',
      pattern: /\/api\/reader\/(\d+)/
    }
    // 預留其他書城擴展空間
  };
  
  const extractBookId = (href) => {
    if (!href || typeof href !== 'string') return null;
    
    try {
      const urlObj = new URL(href);
      
      // 檢查是否為支援的書城
      for (const [storeName, config] of Object.entries(supportedBookstores)) {
        if (urlObj.hostname === config.domain) {
          const match = href.match(config.pattern);
          return match ? match[1] : null;
        }
      }
      return null;
    } catch {
      return null; // 無效URL
    }
  };
  ```
- **測試增強**: 新增有效ID提取測試，確保邏輯完整性
- **測試結果**: ✅ 100% 通過 (50/50)

#### 🔵 重構階段

- **架構優化**: 
  - 設計可配置的書城支援系統
  - 預留未來擴展介面
  - 完善錯誤處理和邊界情況
- **品質提升**: 
  - 支援多書城架構
  - 更嚴格的URL和域名驗證
  - 可擴展的設計模式
- **專案目標更新**: 在 README.md 和 todolist.md 中加入多書城支援目標

#### 📝 學習重點

- 系統設計需要考慮未來擴展性
- 配置驅動的架構比硬編碼更靈活  
- URL 物件提供更可靠的域名解析
- 測試應該覆蓋正面和負面情況
- 架構設計應該預留用戶需求的擴展空間

---

### 專案結構調整：架構優先順序重組 🏗

**日期**: 2025-07-29  
**類型**: 架構決策調整  
**狀態**: 已完成

#### 📋 調整原因

- **用戶需求**: 明確要求先建立事件系統架構，再實現Chrome Extension基礎設施
- **架構考量**: 避免後期因事件系統導入而需要大幅重構現有程式碼
- **技術決策**: 事件系統作為整個專案的「神經系統」，所有模組通信都依賴它

#### 🔄 調整內容

**原順序**:
1. Chrome Extension 基礎架構 (manifest.json, background, content script)
2. 事件系統核心實現
3. 資料提取器實現

**新順序**:
1. **🎭 階段一：事件系統核心** - 系統通信基礎
2. **📚 階段二：資料提取器** - 基於事件系統的資料提取
3. **🏗 階段三：Chrome Extension 基礎架構** - 整合事件系統
4. **💾 階段四：儲存系統** - 事件驅動的資料儲存
5. **🎨 階段五：UI 組件** - 使用者界面實現

#### 🎯 架構優勢

- **避免重構風險**: 先建立核心架構，所有後續模組基於此開發
- **系統完整性**: 每個階段都有明確的依賴關係
- **TDD 友好**: 事件系統有清晰的輸入/輸出界面，容易測試
- **模組解耦**: 通過事件系統實現模組間的鬆散耦合

#### 📝 更新內容

- `docs/todolist.md`: 重新組織所有階段順序
- 新增「開發階段概覽」說明架構優先順序
- 在各階段標題中標註「基於事件系統」或「事件驅動」
- 明確事件觸發規範（如：`EXTRACTOR.DATA.EXTRACTED`）

#### 💡 學習重點

- 架構設計應該優先於功能實現
- 核心系統（如事件總線）是其他模組的基礎
- 合理的開發順序可以大幅降低重構成本
- 文檔結構調整也是重要的架構決策，需要記錄

---

## 🐛 問題追蹤

### 已解決 ✅

1. Chrome Storage 配額錯誤處理
2. localStorage 模擬修正  
3. 資料格式驗證功能
4. 多書城書籍ID處理邏輯

## 📊 測試狀態

- **測試**: 50/50 通過 (100%)
- **階段**: TDD測試框架完成

## 🔗 相關提交

- `2da7bfb` - 測試框架建置
- `25f79fe` - Chrome Storage修復
- `6d5f6ab` - localStorage修復  
- `aa7171d` - 資料驗證修復
- （待新增）- 多書城支援實現

---

**工作日誌建立**: 2025-07-29  
**最後更新**: 2025-07-29 