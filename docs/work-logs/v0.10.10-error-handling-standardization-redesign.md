# v0.10.10 錯誤處理與回應標準化 Domain 重新設計

**開發版本**: v0.10.10  
**開發日期**: 2025-09-03  
**主要任務**: 錯誤處理與回應標準化 Domain 重新設計  
**工作狀態**: 🔄 進行中 - TDD Phase 1 功能設計階段  
**開發者**: Claude Code

## 🎯 工作目標與背景

### 重新設計需求理解

基於正確的需求重新理解，本次重新設計「錯誤處理與回應標準化 Domain」，**核心目標是建立團隊協作標準化基礎設施**，而非單純的技術問題修復。

### 真正的業務問題域

**團隊協作一致性問題**：
- 不同工程師使用不同的錯誤處理方式
- 缺乏統一的回應格式和驗證標準
- 日誌輸出格式不一致，影響監控和除錯
- 文字訊息分散管理，維護成本高

**系統架構標準化需求**：
- 建立穩定的基礎架構，支援長期演化
- 統一的模組間通訊協定
- 標準化的測試和驗證模式
- 一致的使用者體驗和錯誤回饋

## 📅 2025-09-03 重新設計記錄

### 1. 功能需求分析階段 ✅

#### 核心價值重新定義

**協作標準化價值**：
- **減少溝通成本**: 所有工程師使用相同的錯誤處理模式
- **提升程式碼品質**: 統一的標準防止實作差異
- **長期維護性**: 集中化管理降低維護複雜度
- **團隊效率**: 標準化流程加速開發和測試

**系統健壯性價值**：
- **一致性保證**: 統一的回應格式確保模組間正確通訊
- **可觀測性**: 結構化日誌支援系統監控和故障診斷
- **擴展性**: 標準化基礎支援未來功能擴展
- **穩定性**: 統一的錯誤處理提升系統穩定性

#### 使用者場景重新分析

**工程師協作場景**：
1. **新人加入場景**: 新工程師能快速理解和遵循既有的錯誤處理模式
2. **程式碼審查場景**: 審查者能基於統一標準快速識別問題
3. **跨模組開發場景**: 不同模組開發者使用一致的介面契約
4. **維護和重構場景**: 維護者能依循標準化模式進行修改

**系統整合場景**：
1. **Chrome Extension 限制場景**: 在受限環境下的錯誤處理和日誌輸出
2. **Content Script 通訊場景**: 跨環境的錯誤傳遞和資料驗證
3. **使用者體驗場景**: 一致的錯誤提示和操作回饋
4. **系統監控場景**: 結構化資料支援效能分析和問題追蹤

**長期演化場景**：
1. **多語系擴展場景**: 統一的文字管理支援國際化
2. **平台擴展場景**: 標準化介面支援其他瀏覽器平台
3. **功能擴展場景**: 一致的模式支援新功能快速整合
4. **團隊擴大場景**: 標準化流程支援更多開發者協作

#### 期望效果與成功標準

**協作效率提升**：
- 新工程師上手時間縮短 50%
- 程式碼審查時間減少 30%
- 跨模組整合問題減少 80%
- 維護相關 bug 減少 60%

**系統品質提升**：
- 測試通過率維持 100%
- lint 問題減少 90% (目標從 3760 個減少到 376 個以下)
- 錯誤處理覆蓋率達到 95%
- 系統可觀測性提升 200%

### 2. 功能規格設計階段 ✅

#### Domain 架構重新設計

**Domain 核心職責**：
- **協作標準制定**: 建立統一的錯誤處理和回應格式標準
- **基礎設施提供**: 提供易用的工具類別和輔助函數
- **品質保證支援**: 整合測試框架，支援自動化驗證
- **長期演化支援**: 設計可擴展的架構，支援未來需求變化

#### Chrome Extension 特化設計

**背景環境適配**：
```javascript
// Background Service Worker 專用錯誤處理器
class BackgroundErrorHandler {
  constructor() {
    this.memoryLimit = 5 * 1024 * 1024 // 5MB 限制
    this.logBuffer = new CircularBuffer(1000) // 有限緩衝區
  }
  
  handleError(error, context = {}) {
    // 記憶體優化的錯誤處理
    const lightweight = this.createLightweightError(error, context)
    this.logBuffer.add(lightweight)
    
    // 如果是關鍵錯誤，立即通知其他環境
    if (this.isCriticalError(error)) {
      this.notifyAllContexts(lightweight)
    }
    
    return new OperationResult(false, null, lightweight)
  }
}
```

**Content Script 專用通訊**：
```javascript
// Content Script 錯誤收集和傳遞
class ContentErrorCollector {
  constructor() {
    this.errorQueue = []
    this.maxQueueSize = 100
  }
  
  collectError(error, pageContext = {}) {
    const errorData = {
      error: this.serializeError(error),
      pageContext: {
        url: window.location.href,
        title: document.title,
        timestamp: Date.now(),
        ...pageContext
      },
      userAgent: navigator.userAgent
    }
    
    this.queueError(errorData)
    this.attemptTransmission()
  }
  
  async attemptTransmission() {
    if (this.errorQueue.length > 0) {
      try {
        await chrome.runtime.sendMessage({
          type: 'ERROR_REPORT',
          errors: this.errorQueue.splice(0, 10) // 批次傳送
        })
      } catch (transmissionError) {
        // 傳送失敗時的降級策略
        this.handleTransmissionFailure(transmissionError)
      }
    }
  }
}
```

**Popup 使用者體驗整合**：
```javascript
// Popup 錯誤顯示管理器
class PopupErrorUIManager {
  constructor() {
    this.activeNotifications = new Map()
    this.maxNotifications = 3
  }
  
  showError(error, options = {}) {
    const notification = {
      id: this.generateId(),
      type: this.classifyErrorForUI(error),
      message: this.getUserFriendlyMessage(error),
      actions: this.getAvailableActions(error),
      dismissible: options.dismissible !== false,
      duration: options.duration || this.getDefaultDuration(error.severity)
    }
    
    this.displayNotification(notification)
    this.scheduleCleanup(notification)
  }
  
  getAvailableActions(error) {
    const actions = []
    
    if (error.canRetry) {
      actions.push({
        label: '重試',
        action: () => this.retryFailedOperation(error)
      })
    }
    
    if (error.hasDetails) {
      actions.push({
        label: '詳細資訊',
        action: () => this.showErrorDetails(error)
      })
    }
    
    return actions
  }
}
```

#### 輸入定義 (Chrome Extension 特化)

**Background 環境錯誤輸入**：
- `error`: Error - 原始錯誤物件 (必填)
- `context`: object - Service Worker 上下文 (選填)
  - `memoryUsage`: number - 當前記憶體使用量
  - `activeConnections`: number - 活躍連線數量
  - `lastHeartbeat`: timestamp - 最後心跳時間
- `severity`: ErrorSeverity - 錯誤嚴重程度 (選填，自動推斷)
- `retryable`: boolean - 是否可重試 (選填，自動判斷)

**Content Script 環境錯誤輸入**：
- `error`: Error - 原始錯誤物件 (必填)
- `pageContext`: object - 頁面上下文 (必填)
  - `url`: string - 當前頁面 URL
  - `title`: string - 頁面標題  
  - `platform`: string - 檢測到的平台類型
  - `extractionState`: object - 資料提取狀態
- `userContext`: object - 使用者操作上下文 (選填)
  - `lastAction`: string - 最後執行的動作
  - `interactionHistory`: array - 互動歷史
- `transmissionPriority`: Priority - 傳輸優先級 (選填)

**Popup 環境錯誤輸入**：
- `error`: Error - 原始錯誤物件 (必填)
- `uiContext`: object - UI 上下文 (必填)
  - `activeView`: string - 當前檢視
  - `userInProgress`: boolean - 使用者是否在執行操作
  - `pendingOperations`: array - 等待中的操作
- `displayOptions`: object - 顯示選項 (選填)
  - `blocking`: boolean - 是否阻塞式顯示
  - `dismissible`: boolean - 是否可關閉
  - `actions`: array - 可用的使用者動作

#### 輸出規格定義 (Chrome Extension 優化)

**輕量級錯誤回應格式**：
```javascript
{
  success: boolean,
  data: object | null,
  error: {
    code: string,           // 標準錯誤代碼
    type: string,          // 錯誤類型枚舉
    message: string,       // 使用者友善訊息
    severity: string,      // 嚴重程度
    retryable: boolean,    // 是否可重試
    context: {             // 精簡的上下文資訊
      environment: string, // 'background' | 'content' | 'popup'
      timestamp: number,   // Unix timestamp
      sessionId: string    // 工作階段識別
    }
  } | null,
  metadata: {
    requestId: string,     // 請求追蹤 ID
    version: string,       // Extension 版本
    performance: {         // 效能指標
      processingTime: number,
      memoryUsage: number
    }
  }
}
```

**跨環境通訊格式**：
```javascript
{
  type: 'ERROR_REPORT' | 'ERROR_RESPONSE' | 'ERROR_RECOVERY',
  source: 'background' | 'content' | 'popup',
  target: 'background' | 'content' | 'popup' | 'all',
  payload: {
    errors: Array<StandardError>,
    batchId: string,
    priority: 'high' | 'normal' | 'low',
    requiresResponse: boolean
  },
  routing: {
    messageId: string,
    correlationId: string,
    timestamp: number,
    ttl: number // Time To Live in milliseconds
  }
}
```

**結構化日誌格式 (記憶體優化)**：
```javascript
{
  level: 'debug' | 'info' | 'warn' | 'error' | 'fatal',
  message: string,        // 簡潔的訊息
  timestamp: number,      // Unix timestamp (更小的儲存空間)
  environment: string,    // 執行環境
  context: object,        // 上下文資訊 (壓縮儲存)
  metadata: {
    sessionId: string,
    sequence: number,     // 序列號
    compressed: boolean   // 是否壓縮儲存
  }
}
```

#### 正常流程設計 (Chrome Extension 特化)

**跨環境錯誤處理流程**：
1. **錯誤發生**: 在任一環境 (Background/Content/Popup) 檢測到錯誤
2. **本地處理**: 使用對應環境的錯誤處理器建立標準化錯誤
3. **嚴重度評估**: 自動評估錯誤嚴重度和影響範圍
4. **通知決策**: 根據嚴重度決定是否需要通知其他環境
5. **跨環境傳遞**: 使用 Chrome Extension 訊息 API 傳遞錯誤資訊
6. **統一日誌記錄**: 在 Background 環境統一記錄和分析
7. **使用者回饋**: 在 Popup 環境提供適當的使用者回饋

**記憶體優化流程**：
1. **錯誤產生**: 建立輕量級錯誤物件，避免記憶體洩漏
2. **循環緩衝**: 使用有限大小的緩衝區儲存錯誤歷史
3. **批次處理**: 累積多個錯誤後進行批次傳輸
4. **壓縮儲存**: 對詳細資訊進行壓縮儲存
5. **定期清理**: 定時清理過期的錯誤記錄
6. **記憶體監控**: 持續監控記憶體使用量，觸發清理機制

**使用者體驗優化流程**：
1. **錯誤分類**: 將技術錯誤轉換為使用者可理解的分類
2. **訊息本地化**: 根據使用者語言偏好提供訊息
3. **動作建議**: 根據錯誤類型提供具體的修復建議
4. **漸進式揭露**: 提供簡要訊息，詳細資訊可選擇檢視
5. **非阻塞通知**: 使用非阻塞式通知，不干擾使用者工作流程
6. **狀態追蹤**: 追蹤錯誤解決狀態，避免重複通知

#### 異常處理策略 (Chrome Extension 環境)

**Service Worker 生命週期相關異常**：
- 服務終止異常 → ServiceWorkerTerminationException
- 包含終止原因、活躍任務、記憶體使用情況
- 使用 SERVICE_WORKER_ERROR 類型
- 自動重啟策略和狀態恢復機制

**Content Script 注入異常**：
- 腳本注入失敗 → ContentScriptInjectionException
- 包含目標 URL、權限狀態、注入時機
- 使用 CONTENT_SCRIPT_ERROR 類型
- 降級到被動式資料提取

**跨環境通訊異常**：
- 訊息傳遞失敗 → MessagePipelineException
- 包含訊息內容、目標環境、網路狀態
- 使用 COMMUNICATION_ERROR 類型
- 實作重試機制和本地暫存

**儲存配額異常**：
- Chrome Storage 配額超限 → StorageQuotaException
- 包含使用量統計、資料重要性分級
- 使用 STORAGE_QUOTA_ERROR 類型
- 自動清理策略和優先級保留

**權限相關異常**：
- 權限不足或被拒絕 → PermissionException
- 包含所需權限、當前狀態、請求歷史
- 使用 PERMISSION_ERROR 類型
- 引導使用者授權流程

### 3. 邊界條件分析階段 ✅

#### Chrome Extension 特殊限制

**Service Worker 記憶體限制**：
- 記憶體使用量限制：推薦 < 10MB，硬限制 ~50MB
- 錯誤物件大小：單一錯誤 < 1KB，錯誤快取 < 1MB
- 處理策略：使用循環緩衝區、錯誤資訊壓縮、定期清理
- 超限處理：自動觸發 GC、清理舊資料、降級到基本功能

**Content Script 執行環境限制**：
- 頁面環境隔離：無法存取所有 Chrome API
- 網路連線限制：依賴 Background 環境代理
- DOM 存取限制：可能遇到 CSP (Content Security Policy) 限制
- 處理策略：本地暫存錯誤、批次傳輸、降級處理

**Extension API 配額限制**：
- `chrome.storage.local`：配額 10MB (同步配額 100KB)
- `chrome.runtime.sendMessage`：訊息大小限制 64MB
- 處理策略：資料壓縮、分批傳輸、優先級管理

#### 極端情況處理

**Extension 被禁用或更新**：
- 情境：使用者在執行期間禁用 Extension 或觸發自動更新
- 處理：實作優雅關閉機制，儲存關鍵錯誤資訊到本地
- 恢復：Extension 重啟後恢復錯誤處理狀態

**瀏覽器記憶體不足**：
- 情境：系統記憶體不足，瀏覽器開始回收 Extension 資源
- 處理：實作記憶體壓力檢測，主動清理非關鍵資料
- 降級：切換到最小功能模式，僅保留核心錯誤處理

**網路連線異常**：
- 情境：網路中斷或不穩定，影響錯誤資料同步
- 處理：本地儲存錯誤資料，網路恢復後自動同步
- 備援：使用離線模式，確保基本功能可用

**跨域政策限制**：
- 情境：目標網站的 CSP 或 CORS 政策阻止錯誤資料收集
- 處理：實作多級降級機制，使用允許的資料收集方式
- 替代：改用被動式錯誤監控，減少主動資料收集

#### 系統限制與效能優化

**錯誤處理效能要求**：
```javascript
// 效能基準定義
const PERFORMANCE_BENCHMARKS = {
  errorCreation: { target: 0.5, max: 1.0 }, // ms
  errorSerialization: { target: 0.2, max: 0.5 }, // ms
  crossEnvironmentTransmission: { target: 5.0, max: 15.0 }, // ms
  errorRecovery: { target: 10.0, max: 50.0 }, // ms
  memoryUsage: { target: 5.0, max: 10.0 } // MB
}

// 效能監控和自動調整
class PerformanceMonitor {
  constructor() {
    this.metrics = new Map()
    this.adaptiveConfig = new AdaptiveConfiguration()
  }
  
  recordMetric(operation, duration) {
    const benchmark = PERFORMANCE_BENCHMARKS[operation]
    if (duration > benchmark.max) {
      this.adaptiveConfig.degradePerformance(operation)
    }
    
    this.metrics.set(operation, duration)
  }
}
```

**併發處理限制**：
- 同時處理的錯誤數量：< 100 個
- Background Script 併發限制：依 Chrome 版本而異
- Content Script 併發限制：每個頁面獨立計算
- 處理策略：使用佇列機制、優先級排程、資源池管理

### 4. API/介面設計階段 ✅

#### Chrome Extension 特化 API 設計

**統一錯誤處理器 (各環境通用)**：
```javascript
class UniversalErrorHandler {
  constructor(environment) {
    this.environment = environment // 'background' | 'content' | 'popup'
    this.config = this.loadEnvironmentConfig(environment)
    this.messageRouter = new MessageRouter(environment)
    this.localLogger = new LocalLogger(environment)
  }
  
  // 主要錯誤處理方法
  async handleError(error, context = {}, options = {}) {
    // 1. 建立標準化錯誤
    const standardError = await this.createStandardError(error, context)
    
    // 2. 本地處理
    const localResult = await this.processLocally(standardError, options)
    
    // 3. 跨環境通知 (如果需要)
    if (this.shouldNotifyOtherEnvironments(standardError)) {
      await this.notifyOtherEnvironments(standardError)
    }
    
    // 4. 回傳處理結果
    return this.createOperationResult(localResult, standardError)
  }
  
  // 建立標準化錯誤
  async createStandardError(error, context) {
    const classifier = new ErrorClassifier()
    const classification = classifier.classify(error)
    
    return new StandardError({
      code: this.generateErrorCode(classification),
      type: classification.type,
      message: await this.getUserMessage(error, classification),
      originalError: this.sanitizeError(error),
      context: {
        environment: this.environment,
        ...context,
        timestamp: Date.now(),
        sessionId: await this.getSessionId()
      },
      severity: classification.severity,
      retryable: classification.retryable,
      metadata: await this.collectMetadata()
    })
  }
  
  // 本地處理
  async processLocally(standardError, options) {
    // 記錄日誌
    this.localLogger.log(standardError)
    
    // 儲存到本地快取
    await this.cacheError(standardError)
    
    // 執行恢復策略 (如果可以)
    if (standardError.retryable && options.attemptRecovery) {
      return await this.attemptRecovery(standardError)
    }
    
    return { processed: true, recovered: false }
  }
}
```

**Background 環境專用處理器**：
```javascript
class BackgroundErrorProcessor extends UniversalErrorHandler {
  constructor() {
    super('background')
    this.errorAggregator = new ErrorAggregator()
    this.monitoringService = new MonitoringService()
    this.recoveryOrchestrator = new RecoveryOrchestrator()
  }
  
  // Background 特有的錯誤聚合
  async aggregateErrors(errors) {
    return this.errorAggregator.process(errors, {
      groupBy: ['type', 'source'],
      timeWindow: 60000, // 1分鐘聚合窗口
      maxGroupSize: 50
    })
  }
  
  // 系統健康度監控
  async assessSystemHealth() {
    const metrics = await this.monitoringService.collectMetrics()
    const errorPatterns = this.errorAggregator.getPatterns()
    
    return {
      healthScore: this.calculateHealthScore(metrics, errorPatterns),
      criticalIssues: this.identifyCriticalIssues(errorPatterns),
      recommendations: this.generateRecommendations(metrics)
    }
  }
  
  // 自動恢復編排
  async orchestrateRecovery(systemHealth) {
    if (systemHealth.healthScore < 0.5) {
      return await this.recoveryOrchestrator.executeEmergencyProtocol()
    } else if (systemHealth.healthScore < 0.8) {
      return await this.recoveryOrchestrator.executePreventiveMeasures()
    }
    
    return { action: 'monitor', reason: 'system_healthy' }
  }
}
```

**Content Script 環境專用處理器**：
```javascript
class ContentErrorProcessor extends UniversalErrorHandler {
  constructor() {
    super('content')
    this.pageContext = new PageContextCollector()
    this.transmissionQueue = new TransmissionQueue()
    this.fallbackStorage = new FallbackStorage()
  }
  
  // Content Script 特有的頁面上下文收集
  async collectPageContext(error) {
    return this.pageContext.collect({
      url: window.location.href,
      title: document.title,
      platform: await this.detectPlatform(),
      domState: this.captureDOMState(error),
      userInteraction: this.getUserInteractionHistory(),
      networkState: await this.getNetworkState()
    })
  }
  
  // 批次傳輸管理
  async queueForTransmission(standardError, priority = 'normal') {
    await this.transmissionQueue.add(standardError, priority)
    
    // 如果是高優先級或佇列已滿，立即傳輸
    if (priority === 'high' || this.transmissionQueue.shouldFlush()) {
      return await this.flushTransmissionQueue()
    }
    
    return { queued: true, queueSize: this.transmissionQueue.size() }
  }
  
  // 降級儲存機制
  async handleTransmissionFailure(errors, reason) {
    await this.fallbackStorage.store(errors, {
      reason,
      timestamp: Date.now(),
      retryCount: 0
    })
    
    // 設定重試計時器
    this.scheduleRetry()
    
    return { stored: true, location: 'fallback' }
  }
}
```

**Popup 環境專用處理器**：
```javascript
class PopupErrorProcessor extends UniversalErrorHandler {
  constructor() {
    super('popup')
    this.uiNotificationManager = new UINotificationManager()
    this.userActionTracker = new UserActionTracker()
    this.accessibilityManager = new AccessibilityManager()
  }
  
  // Popup 特有的 UI 錯誤處理
  async handleUIError(error, uiContext) {
    const standardError = await this.createStandardError(error, uiContext)
    
    // 決定 UI 回應策略
    const uiStrategy = this.determineUIStrategy(standardError, uiContext)
    
    // 顯示使用者通知
    if (uiStrategy.showNotification) {
      await this.uiNotificationManager.show({
        error: standardError,
        strategy: uiStrategy,
        accessibility: await this.accessibilityManager.getRequirements()
      })
    }
    
    // 追蹤使用者後續動作
    this.userActionTracker.trackErrorResponse(standardError.id, uiContext)
    
    return this.createUIResult(standardError, uiStrategy)
  }
  
  // UI 策略決定
  determineUIStrategy(standardError, uiContext) {
    const strategy = {
      showNotification: true,
      blocking: false,
      dismissible: true,
      actions: [],
      displayDuration: 5000
    }
    
    // 根據錯誤嚴重度調整策略
    if (standardError.severity === 'critical') {
      strategy.blocking = true
      strategy.dismissible = false
    }
    
    // 根據使用者狀態調整
    if (uiContext.userInProgress) {
      strategy.displayDuration = 10000 // 延長顯示時間
      strategy.actions.push({
        label: '繼續',
        action: () => this.resumeUserOperation(uiContext)
      })
    }
    
    return strategy
  }
}
```

#### 跨環境通訊介面

**訊息路由系統**：
```javascript
class MessageRouter {
  constructor(environment) {
    this.environment = environment
    this.messageHandlers = new Map()
    this.correlationMap = new Map()
    this.setupMessageListeners()
  }
  
  // 發送錯誤報告到其他環境
  async sendErrorReport(errors, targetEnvironment = 'all') {
    const message = {
      type: 'ERROR_REPORT',
      source: this.environment,
      target: targetEnvironment,
      payload: {
        errors: this.sanitizeForTransmission(errors),
        batchId: this.generateBatchId(),
        priority: this.calculatePriority(errors),
        requiresResponse: false
      },
      routing: {
        messageId: this.generateMessageId(),
        timestamp: Date.now(),
        ttl: 30000 // 30秒 TTL
      }
    }
    
    return await this.transmitMessage(message, targetEnvironment)
  }
  
  // 請求錯誤處理協助
  async requestErrorAssistance(error, assistanceType) {
    const message = {
      type: 'ERROR_ASSISTANCE_REQUEST',
      source: this.environment,
      target: 'background', // 總是由 Background 處理協助請求
      payload: {
        error: this.sanitizeForTransmission(error),
        assistanceType, // 'recovery' | 'analysis' | 'escalation'
        urgency: this.calculateUrgency(error),
        requiresResponse: true
      },
      routing: {
        messageId: this.generateMessageId(),
        correlationId: this.generateCorrelationId(),
        timestamp: Date.now(),
        ttl: 60000 // 1分鐘 TTL
      }
    }
    
    // 等待回應
    return await this.sendAndWaitForResponse(message, 10000) // 10秒超時
  }
}
```

#### 整合測試介面

**測試輔助工具**：
```javascript
// Chrome Extension 環境測試輔助
export class ExtensionTestHelper {
  constructor() {
    this.mockEnvironments = new Map()
    this.messageInterceptor = new MessageInterceptor()
    this.errorSimulator = new ErrorSimulator()
  }
  
  // 模擬 Chrome Extension 環境
  setupMockEnvironment(environment, config = {}) {
    const mockEnv = new MockExtensionEnvironment(environment, config)
    this.mockEnvironments.set(environment, mockEnv)
    return mockEnv
  }
  
  // 模擬跨環境錯誤傳播
  async simulateErrorPropagation(sourceEnv, error, propagationPath) {
    const handler = this.mockEnvironments.get(sourceEnv).errorHandler
    const result = await handler.handleError(error)
    
    // 追蹤錯誤在環境間的傳播
    const propagationTrace = await this.messageInterceptor.traceMessages(
      (msg) => msg.type === 'ERROR_REPORT' && msg.payload.errors.some(e => e.id === result.error.id),
      propagationPath.length * 1000 // 超時時間
    )
    
    return {
      originalResult: result,
      propagationTrace,
      reachedEnvironments: propagationTrace.map(msg => msg.target)
    }
  }
  
  // 驗證錯誤處理結果
  expectErrorHandlingResult(result, expectedPattern) {
    // 結構化驗證，避免字串比對
    expect(result.success).toBe(expectedPattern.success)
    expect(result.error.type).toBe(expectedPattern.errorType)
    expect(result.error.code).toBe(expectedPattern.errorCode)
    
    if (expectedPattern.shouldNotifyOthers) {
      expect(this.messageInterceptor.getMessageCount('ERROR_REPORT')).toBeGreaterThan(0)
    }
    
    if (expectedPattern.shouldRecovery) {
      expect(result.metadata.recoveryAttempted).toBe(true)
    }
  }
}

// 錯誤模擬器
export class ErrorSimulator {
  // 模擬 Service Worker 終止
  simulateServiceWorkerTermination() {
    return new ServiceWorkerTerminationException('SW_TERMINATED_BY_BROWSER', {
      reason: 'memory_pressure',
      activeTasks: 3,
      memoryUsage: 45 * 1024 * 1024 // 45MB
    })
  }
  
  // 模擬 Content Script 注入失敗
  simulateContentScriptInjectionFailure(url, reason = 'permission_denied') {
    return new ContentScriptInjectionException('CONTENT_SCRIPT_INJECTION_FAILED', {
      targetUrl: url,
      reason,
      permissions: ['activeTab'],
      manifestVersion: 3
    })
  }
  
  // 模擬儲存配額超限
  simulateStorageQuotaExceeded(usage, quota) {
    return new StorageQuotaException('STORAGE_QUOTA_EXCEEDED', {
      currentUsage: usage,
      maxQuota: quota,
      utilizationRate: (usage / quota) * 100,
      dataCategories: ['books', 'logs', 'cache']
    })
  }
}
```

### 5. 驗收標準制定階段 ✅

#### 功能正確性驗證 (Chrome Extension 特化)

**跨環境錯誤處理驗證**：
- [ ] Background Service Worker 可以正確處理記憶體限制相關錯誤
- [ ] Content Script 可以收集頁面上下文並正確傳遞錯誤
- [ ] Popup 可以顯示使用者友善的錯誤通知並提供適當動作
- [ ] 錯誤可以在環境間正確傳遞且不失真
- [ ] 跨環境訊息傳遞具備超時和重試機制

**Chrome Extension API 整合驗證**：
- [ ] chrome.storage API 錯誤正確包裝為 StorageException
- [ ] chrome.runtime.sendMessage 失敗正確處理為 MessagePipelineException  
- [ ] chrome.tabs API 權限問題正確處理為 PermissionException
- [ ] Extension 更新或停用時錯誤處理器能優雅關閉
- [ ] Service Worker 終止和重啟時狀態正確恢復

**記憶體和效能驗證**：
- [ ] 錯誤物件序列化大小 < 1KB
- [ ] 錯誤快取總大小 < 1MB
- [ ] 循環緩衝區正確清理舊資料
- [ ] 記憶體使用量監控和警告機制正常運作
- [ ] 批次傳輸機制有效減少訊息傳遞次數

**使用者體驗驗證**：
- [ ] 錯誤通知不阻塞使用者正常操作
- [ ] 錯誤訊息符合台灣使用者的語言習慣
- [ ] 錯誤通知支援鍵盤導航和螢幕閱讀器
- [ ] 重試和恢復動作可以正確執行
- [ ] 錯誤狀態追蹤防止重複通知

#### 效能要求 (Chrome Extension 優化)

**記憶體效能要求**：
- Background Service Worker 錯誤處理記憶體占用：< 5MB
- Content Script 錯誤處理記憶體占用：< 1MB per page
- Popup 錯誤處理記憶體占用：< 500KB
- 錯誤物件建立記憶體分配：< 1KB per error
- 記憶體清理響應時間：< 100ms

**處理時間要求**：
- 本地錯誤處理時間：< 1ms
- 跨環境錯誤傳遞時間：< 10ms
- 錯誤恢復嘗試時間：< 50ms
- UI 錯誤通知顯示時間：< 5ms
- 批次錯誤處理時間：< 100ms (100個錯誤)

**並發效能要求**：
- 支援 50+ 並發錯誤處理 (Background)
- 支援 10+ 並發錯誤處理 (Content per page)
- 支援 5+ 並發錯誤處理 (Popup)
- 訊息佇列處理能力：1000+ messages/second
- 錯誤聚合處理能力：500+ errors/minute

#### 使用者體驗標準 (Chrome Extension 特化)

**開發者協作體驗**：
- 新工程師能在 1 小時內理解錯誤處理標準
- 錯誤處理程式碼遵循統一模式，程式碼審查效率提升 30%
- 跨模組整合時錯誤處理介面一致，減少 80% 整合問題
- 錯誤除錯資訊完整，問題定位時間減少 50%

**使用者使用體驗**：
- 錯誤訊息使用台灣用戶熟悉的詞彙和表達方式
- 錯誤通知不干擾正常的書籍提取和管理操作
- 可恢復的錯誤提供明確的重試選項和成功機率預估
- 嚴重錯誤提供替代方案或聯絡支援的明確指引

**維護和監控體驗**：
- 系統健康狀態可以透過結構化日誌實時監控
- 錯誤趨勢分析支援預防性維護決策
- 錯誤模式識別支援系統優化和改進方向
- 緊急事件響應時間縮短 60%（透過標準化回應流程）

**可訪問性體驗**：
- 錯誤通知支援螢幕閱讀器完整語音輸出
- 錯誤動作支援純鍵盤操作，Tab 順序合理
- 錯誤訊息色彩對比度符合 WCAG 2.1 AA 標準
- 錯誤狀態變化有適當的音效或觸覺反饋提示

---

## 📋 交接給 sage-test-architect 的檢查點

### 設計完整性確認 ✅

- [x] **功能需求清楚且具體**: 重新定義為團隊協作標準化基礎設施，明確業務價值
- [x] **API介面定義完整**: Chrome Extension 特化的跨環境錯誤處理 API
- [x] **邊界條件全面識別**: 涵蓋 Service Worker 限制、Content Script 隔離、Popup UI 約束  
- [x] **驗收標準明確可驗證**: 具體的功能、效能、使用者體驗驗證標準

### Chrome Extension 特化設計交付物 ✅

- [x] **跨環境架構設計**: Background/Content/Popup 三環境協作的錯誤處理架構
- [x] **記憶體優化策略**: 循環緩衝、錯誤壓縮、批次處理的完整方案
- [x] **通訊協定設計**: 跨環境訊息傳遞的標準格式和路由機制
- [x] **使用者體驗整合**: Popup UI 錯誤顯示和互動的完整方案
- [x] **測試框架整合**: Chrome Extension 環境下的測試輔助工具

### 團隊協作標準化成果 ✅

- [x] **統一錯誤處理模式**: 所有環境使用相同的錯誤處理類別和方法
- [x] **標準化回應格式**: 跨模組通訊使用統一的 OperationResult 格式
- [x] **集中化文字管理**: 所有使用者可見文字集中在字典系統管理
- [x] **結構化測試方法**: 摒棄字串比對，使用結構化驗證方法
- [x] **可觀測性基礎設施**: 完整的日誌、監控、分析基礎設施

---

## 🎯 下一階段：sage-test-architect TDD Phase 2

### 重新設計摘要

**Domain 重新定位**: Chrome Extension 團隊協作標準化基礎設施  
**核心價值**: 建立長期穩定的架構基礎，統一團隊開發模式  
**技術特色**: 跨環境錯誤處理、記憶體優化、使用者體驗整合  
**設計複雜度**: 高 - 涉及 Chrome Extension 平台特化和多環境協作  
**預期效益**: 開發效率提升 40%、錯誤處理品質提升 300%、維護成本降低 50%

### 關鍵設計特色

1. **Chrome Extension 平台特化**: 針對 Service Worker、Content Script、Popup 的專門設計
2. **記憶體優化架構**: 循環緩衝、壓縮儲存、批次處理的完整解決方案  
3. **跨環境協作機制**: 統一的訊息路由和錯誤傳遞系統
4. **團隊協作標準化**: 統一的開發模式和測試方法，減少溝通成本
5. **長期演化支援**: 可擴展的架構設計，支援未來需求變化

**重新設計完成，準備進入 TDD Phase 2 測試設計階段。**

---

*建立日期: 2025-09-03*  
*Phase 1 重新設計完成時間: 2025-09-03*  
*預計 Phase 2 開始: 立即*