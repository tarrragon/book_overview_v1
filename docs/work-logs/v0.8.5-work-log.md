# v0.8.5 工作日誌 — 事件系統就緒屏障與 Pre-init 佇列

## 目標與背景

- 目標：解決冷啟動時事件先於監聽器註冊抵達所導致的「emit 成功但無監聽器執行」問題，並統一 EventBus 介面以提升穩定性與可測試性。
- 背景：在背景 `background.js` 日誌觀察到 `EXTRACTION.COMPLETED` 成功轉發，但「EventBus 是否有此事件的監聽器」顯示為 `undefined`，顯示初始化時序與介面封裝存在問題。

## 問題發現過程

- 症狀：事件資料量正常（96 筆），但檢查監聽器時得到不穩定值。
- 根因：
  1. 訊息入口未等待監聽器註冊完成便開始處理事件（初始化競態）。
  2. 使用 `eventBus.listeners?.has?.()` 檢查監聽器，外部依賴內部結構導致不穩定且破壞抽象。

## 解決方案設計

- 就緒屏障：
  - 建立 `globalThis.__bgInitPromise = initializeBackgroundServiceWorker()`，涵蓋事件系統建立與監聽器註冊。
  - 訊息入口與安裝/啟動流程一律 `await __bgInitPromise` 後再分派事件。
- Pre-init 佇列：
  - 未就緒且無監聽器時的 `emit()` 暫存事件於 `preInitQueue`。
  - `on(eventType, handler)` 註冊後非阻塞重放相符事件；`eventBus.markReady()` 觸發全量重放。
- 介面封裝與統一：
  - 監聽檢查改為 `hasListener(eventType)`、`getListenerCount(eventType)`。
  - 統一 `emit(eventType, data)`：處理器接收 `{ type, data, timestamp }`；回傳陣列（每個處理器的處理結果）。

## 處理流程（摘要）

1. Background 初始化註冊監聽器。
2. 完成後呼叫 `eventBus.markReady()` 並發送 `SYSTEM.READY`。
3. 訊息入口 `onMessage` 先等待 `__bgInitPromise` 再路由與 `emit()`。
4. 未就緒時到達的事件被暫存並在監聽器註冊或 `markReady()` 後重放。

## 變更內容

- 程式碼：`src/background/background.js`
  - 新增 pre-init 佇列與 `markReady()`。
  - `emit()` 回傳型別改為陣列；處理器接收標準事件物件。
  - 訊息入口與安裝/啟動流程加入就緒屏障等待。
  - 監聽檢查改為 `hasListener()` / `getListenerCount()`。
- 文件：`docs/architecture/event-system.md` 新增「Pre-init 佇列與就緒屏障」章節與驗收準則；介面示例補充。
- 清單：`docs/todolist.md` 更新至 v0.8.5 狀態與後續工作項目。
- 版本：`CHANGELOG.md` 新增 v0.8.5 記錄。

## 測試狀態

- 新增整合測試：監聽器註冊前 emit，`markReady()` 後重放 — 通過。
- 既有紅燈：兩個 Content Script DOM 解析測試維持（與本次變更無關）。

## 架構決策與影響

- 決策：就緒屏障 + pre-init 佇列，確保事件不丟失且處理時序一致，維持 API 抽象邊界。
- 影響：
  - 正向：消除冷啟動競態、提升穩定性與可測試性。
  - 風險：事件量極大時佇列記憶體佔用；目前事件量低，風險可控。

## 後續工作（v0.8.6 提案）

- 修復 Content Script DOM 解析兩項紅燈（ReadmooAdapter 情境）。
- EventBus 診斷 `getStats()` 文件化與測試補強。
- 事件優先級與壅塞控制策略（可選）。
