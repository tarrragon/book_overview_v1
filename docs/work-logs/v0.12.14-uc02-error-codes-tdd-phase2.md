# 🧪 v0.12.14 - UC-02 ErrorCodes 遷移 TDD Phase 2 測試設計

## 📋 版本資訊

- **版本號**: v0.12.14
- **開始時間**: 2025-09-16
- **基於版本**: v0.12.13 (StandardError 語意化重構完成)
- **TDD 階段**: 🔴 Phase 2 - 測試設計階段
- **開發重點**: UC-02 日常書籍資料提取的 ErrorCodes 遷移測試設計

## 🎯 TDD Phase 2 核心目標

### 主要任務
1. **UC-02 測試案例設計**: 基於 UC-02 驗收資料夾的 15 個 StandardError 設計新的測試案例
2. **ErrorCodes 映射分析**: 將 15 個 StandardError 映射到 15 個核心 ErrorCodes
3. **測試覆蓋策略**: 設計正常流程、邊界條件、異常情況的完整測試
4. **Mock 物件設計**: 為 UC-02 的增量更新、去重處理設計測試環境

### TDD Red Phase 設計原則
- **測試優先**: 在任何實作前設計測試案例
- **失敗驅動**: 確保所有測試在新架構下初始失敗 (Red 狀態)
- **覆蓋完整**: 測試覆蓋所有功能點和邊界條件
- **簡化架構**: 採用 `原生 Error + ErrorCodes` 模式

---

## 📊 UC-02 錯誤映射分析

### UC-02 StandardError → ErrorCodes 完整映射表

基於 `docs/acceptance/uc-02/exceptions.md` 的 15 個錯誤定義：

| 序號 | StandardError | 映射 ErrorCodes | 分類 | 優先級 |
|------|---------------|----------------|------|--------|
| 1 | `DATA_DUPLICATE_DETECTION_FAILED` | `VALIDATION_ERROR` | 資料驗證 | 🔴 High |
| 2 | `DATA_INCREMENTAL_UPDATE_CONFLICT` | `BOOK_ERROR` | 書籍處理 | 🔴 High |
| 3 | `DATA_PROGRESS_VALIDATION_ERROR` | `VALIDATION_ERROR` | 資料驗證 | 🟡 Medium |
| 4 | `DOM_PAGE_STRUCTURE_CHANGED` | `DOM_ERROR` | DOM操作 | 🔴 High |
| 5 | `DOM_INFINITE_SCROLL_DETECTION_FAILED` | `DOM_ERROR` | DOM操作 | 🟡 Medium |
| 6 | `DOM_DYNAMIC_CONTENT_TIMEOUT` | `TIMEOUT_ERROR` | 逾時處理 | 🟡 Medium |
| 7 | `SYSTEM_INCREMENTAL_PROCESSING_OVERLOAD` | `OPERATION_ERROR` | 操作執行 | 🔴 High |
| 8 | `SYSTEM_BACKGROUND_SYNC_FAILURE` | `OPERATION_ERROR` | 操作執行 | 🟢 Low |
| 9 | `NETWORK_RATE_LIMITING_DETECTED` | `NETWORK_ERROR` | 網路處理 | 🔴 High |
| 10 | `NETWORK_PARTIAL_CONNECTIVITY` | `CONNECTION_ERROR` | 連線錯誤 | 🟡 Medium |
| 11 | `PLATFORM_TAB_SWITCHING_INTERFERENCE` | `CHROME_ERROR` | Chrome Extension | 🟢 Low |
| 12 | `PLATFORM_CHROME_EXTENSION_CONFLICT` | `CHROME_ERROR` | Chrome Extension | 🟡 Medium |

### 新增的 ErrorCodes 類型分析

**高頻使用的 ErrorCodes (UC-02)**:
- `VALIDATION_ERROR`: 資料驗證相關錯誤 (2個)
- `DOM_ERROR`: DOM 操作相關錯誤 (2個)  
- `OPERATION_ERROR`: 操作執行相關錯誤 (2個)
- `CHROME_ERROR`: Chrome Extension 相關錯誤 (2個)

**中頻使用的 ErrorCodes**:
- `BOOK_ERROR`, `NETWORK_ERROR`, `TIMEOUT_ERROR`, `CONNECTION_ERROR`: 各1個

---

## 🧪 TDD Phase 2 測試案例設計

### 測試策略規劃

#### 1. 測試架構設計
```javascript
// ✅ 新的錯誤處理測試模式 (基於 ErrorCodes v5.0.0)
expect(() => operation()).toThrow(ErrorCodes.VALIDATION_ERROR)
expect(() => operation()).toThrow(/duplicate detection failed/)

// ✅ 結果物件測試模式
const result = await operation()
expect(result).toEqual({
  success: false,
  error: 'Specific error message',
  code: ErrorCodes.VALIDATION_ERROR
})

// ✅ 錯誤物件詳細驗證
try {
  await operation()
} catch (error) {
  expect(error.code).toBe(ErrorCodes.BOOK_ERROR)
  expect(error.message).toContain('incremental update conflict')
  expect(error).toBeInstanceOf(Error)
}
```

#### 2. 重點測試案例設計

### 🔴 High Priority 測試案例 (6個核心錯誤)

#### Test Case 1: DATA_DUPLICATE_DETECTION_FAILED → VALIDATION_ERROR
```javascript
describe('書籍重複檢測失敗', () => {
  test('應該在重複檢測機制失敗時拋出 VALIDATION_ERROR', async () => {
    // Given: 設定重複檢測失敗的條件
    const mockBooks = [
      { id: 'book_123', title: '測試書籍', metadata: { version: 1 } },
      { id: 'book_456', title: '測試書籍', metadata: { version: 2 } }
    ]
    
    const duplicateDetector = new BookDuplicateDetector()
    mockDuplicateDetector.detectDuplicates = jest.fn().mockRejectedValue(
      new Error(`${ErrorCodes.VALIDATION_ERROR}: 重複書籍檢測機制失敗`)
    )

    // When: 執行重複檢測
    // Then: 應該拋出 VALIDATION_ERROR
    await expect(duplicateDetector.detectDuplicates(mockBooks))
      .rejects.toMatchObject({
        code: ErrorCodes.VALIDATION_ERROR,
        message: expect.stringContaining('重複書籍檢測機制失敗')
      })
  })

  test('邊界條件 - 應該處理不穩定 ID 生成的情況', async () => {
    // Given: ID 生成不穩定的條件
    const unstableBooks = [
      { id: 'book_unstable_1', reason: 'unstable_id_generation' },
      { id: 'book_unstable_2', reason: 'metadata_mismatch' }
    ]

    // When & Then: 檢測失敗應拋出 VALIDATION_ERROR
    expect(() => {
      throw new Error(`${ErrorCodes.VALIDATION_ERROR}: ID生成不穩定導致檢測失敗`)
    }).toThrow(ErrorCodes.VALIDATION_ERROR)
  })
})
```

#### Test Case 2: DATA_INCREMENTAL_UPDATE_CONFLICT → BOOK_ERROR  
```javascript
describe('增量更新衝突處理', () => {
  test('應該在增量更新衝突時拋出 BOOK_ERROR', async () => {
    // Given: 設定進度衝突的條件
    const conflictedBook = {
      id: 'book_789',
      storedProgress: '45%',
      newProgress: '40%',
      conflictReason: 'progress_regression'
    }

    const incrementalUpdater = new IncrementalBookUpdater()
    mockIncrementalUpdater.updateBookProgress = jest.fn().mockRejectedValue(
      new Error(`${ErrorCodes.BOOK_ERROR}: 增量更新時發生資料衝突`)
    )

    // When: 執行增量更新
    // Then: 應該拋出 BOOK_ERROR
    await expect(incrementalUpdater.updateBookProgress(conflictedBook))
      .rejects.toMatchObject({
        code: ErrorCodes.BOOK_ERROR,
        message: expect.stringContaining('增量更新時發生資料衝突')
      })
  })

  test('異常情況 - 應該處理進度回退的衝突', () => {
    // Given: 進度回退情況
    const progressRegression = {
      storedProgress: 60,
      newProgress: 45,
      conflictType: 'progress_regression'
    }

    // When & Then: 應該拋出 BOOK_ERROR
    expect(() => {
      if (progressRegression.newProgress < progressRegression.storedProgress) {
        throw new Error(`${ErrorCodes.BOOK_ERROR}: 檢測到進度回退衝突`)
      }
    }).toThrow(ErrorCodes.BOOK_ERROR)
  })
})
```

#### Test Case 3: DOM_PAGE_STRUCTURE_CHANGED → DOM_ERROR
```javascript
describe('頁面結構變化適應', () => {
  test('應該在 Readmoo 頁面結構更新時拋出 DOM_ERROR', async () => {
    // Given: 頁面結構已變化的條件
    const pageChangeDetector = new ReadmooPageChangeDetector()
    const obsoleteSelectors = [
      '.book-item',
      '.progress-bar', 
      '[data-book-id]'
    ]

    mockPageChangeDetector.detectChanges = jest.fn().mockRejectedValue(
      new Error(`${ErrorCodes.DOM_ERROR}: Readmoo 頁面結構已更新`)
    )

    // When: 檢測頁面變化
    // Then: 應該拋出 DOM_ERROR
    await expect(pageChangeDetector.detectChanges(obsoleteSelectors))
      .rejects.toMatchObject({
        code: ErrorCodes.DOM_ERROR,
        message: expect.stringContaining('頁面結構已更新')
      })
  })

  test('邊界條件 - 應該嘗試回退選擇器策略', async () => {
    // Given: 回退選擇器設定
    const fallbackSelectors = ['.library-book', '.reading-progress']
    
    // When: 使用回退策略
    const result = await pageStructureAdapter.adaptToChanges(fallbackSelectors)
    
    // Then: 如果回退也失敗，應拋出 DOM_ERROR
    if (!result.success) {
      expect(() => {
        throw new Error(`${ErrorCodes.DOM_ERROR}: 回退選擇器策略也失敗`)
      }).toThrow(ErrorCodes.DOM_ERROR)
    }
  })
})
```

### 🟡 Medium Priority 測試案例 (4個錯誤)

#### Test Case 4: DATA_PROGRESS_VALIDATION_ERROR → VALIDATION_ERROR
```javascript
describe('閱讀進度驗證', () => {
  test('應該在進度格式無效時拋出 VALIDATION_ERROR', () => {
    // Given: 無效進度資料
    const invalidProgressData = [
      { bookId: 'book_321', progress: '150%', issue: 'exceeds_maximum' },
      { bookId: 'book_654', progress: 'chapter 5', issue: 'non_numeric_format' },
      { bookId: 'book_987', progress: null, issue: 'missing_data' }
    ]

    const progressValidator = new BookProgressValidator()

    // When & Then: 每個無效進度都應拋出 VALIDATION_ERROR
    invalidProgressData.forEach(data => {
      expect(() => {
        progressValidator.validateProgress(data.progress)
      }).toThrow(new RegExp(ErrorCodes.VALIDATION_ERROR))
    })
  })

  test('邊界條件 - 進度百分比邊界測試', () => {
    const boundaryTests = [
      { progress: -1, shouldFail: true },
      { progress: 0, shouldFail: false },
      { progress: 100, shouldFail: false },
      { progress: 101, shouldFail: true }
    ]

    boundaryTests.forEach(({ progress, shouldFail }) => {
      if (shouldFail) {
        expect(() => {
          if (progress < 0 || progress > 100) {
            throw new Error(`${ErrorCodes.VALIDATION_ERROR}: 進度超出有效範圍`)
          }
        }).toThrow(ErrorCodes.VALIDATION_ERROR)
      }
    })
  })
})
```

#### Test Case 5: NETWORK_RATE_LIMITING_DETECTED → NETWORK_ERROR
```javascript
describe('網路頻率限制處理', () => {
  test('應該在檢測到頻率限制時拋出 NETWORK_ERROR', async () => {
    // Given: 頻率限制條件
    const rateLimitDetector = new NetworkRateLimitDetector()
    const requestStats = {
      requestsInWindow: 50,
      rateLimit: 30,
      timeWindow: '60s'
    }

    mockRateLimitDetector.checkRateLimit = jest.fn().mockRejectedValue(
      new Error(`${ErrorCodes.NETWORK_ERROR}: 檢測到 Readmoo 頻率限制`)
    )

    // When: 檢查頻率限制
    // Then: 應該拋出 NETWORK_ERROR
    await expect(rateLimitDetector.checkRateLimit(requestStats))
      .rejects.toMatchObject({
        code: ErrorCodes.NETWORK_ERROR,
        message: expect.stringContaining('頻率限制')
      })
  })

  test('異常情況 - 應該提供退避延遲建議', () => {
    // Given: 頻率限制檢測
    const backoffCalculator = new ExponentialBackoffCalculator()
    
    // When: 計算退避延遲
    const result = backoffCalculator.calculateBackoff(50, 30)
    
    // Then: 應該包含建議的延遲時間
    expect(result.backoffDelay).toBeGreaterThan(0)
    expect(result.strategy).toBe('exponential_backoff')
  })
})
```

### 🟢 Low Priority 測試案例 (2個錯誤)

#### Test Case 6: PLATFORM_TAB_SWITCHING_INTERFERENCE → CHROME_ERROR
```javascript
describe('分頁切換干擾處理', () => {
  test('應該在分頁切換影響提取時拋出 CHROME_ERROR', async () => {
    // Given: 分頁切換檢測
    const tabSwitchDetector = new TabSwitchingDetector()
    
    mockTabSwitchDetector.detectTabSwitch = jest.fn().mockRejectedValue(
      new Error(`${ErrorCodes.CHROME_ERROR}: 分頁切換影響資料提取`)
    )

    // When: 檢測分頁切換
    // Then: 應該拋出 CHROME_ERROR
    await expect(tabSwitchDetector.detectTabSwitch())
      .rejects.toMatchObject({
        code: ErrorCodes.CHROME_ERROR,
        message: expect.stringContaining('分頁切換影響')
      })
  })

  test('邊界條件 - 應該提供暫停和恢復機制', () => {
    // Given: 提取狀態管理
    const extractionManager = new ExtractionStateManager()
    
    // When: 暫停提取
    extractionManager.pauseExtraction('tab_switching')
    
    // Then: 應該能夠恢復
    expect(extractionManager.canResume()).toBe(true)
    expect(extractionManager.getResumeStrategy()).toBe('continue_from_last_position')
  })
})
```

---

## 🛠 Mock 物件和測試環境設計

### Mock 策略設計

#### 1. 核心 Mock 物件
```javascript
// BookDuplicateDetector Mock
const mockDuplicateDetector = {
  detectDuplicates: jest.fn(),
  generateStableBookId: jest.fn(),
  compareMetadata: jest.fn()
}

// IncrementalBookUpdater Mock  
const mockIncrementalUpdater = {
  updateBookProgress: jest.fn(),
  resolveProgressConflict: jest.fn(),
  validateProgressData: jest.fn()
}

// ReadmooPageChangeDetector Mock
const mockPageChangeDetector = {
  detectChanges: jest.fn(),
  adaptToNewStructure: jest.fn(),
  getFallbackSelectors: jest.fn()
}

// NetworkRateLimitDetector Mock
const mockRateLimitDetector = {
  checkRateLimit: jest.fn(),
  calculateBackoff: jest.fn(),
  scheduleRetry: jest.fn()
}
```

#### 2. 測試資料準備
```javascript
// 測試書籍資料
const testBookData = {
  validBooks: [
    {
      id: 'book_valid_1',
      title: '有效書籍 1',
      progress: '45%',
      metadata: { version: 1, lastUpdate: '2025-01-15' }
    }
  ],
  
  duplicateBooks: [
    {
      id: 'book_dup_1',
      title: '重複書籍',
      metadata: { isbn: '123456789' }
    },
    {
      id: 'book_dup_2', 
      title: '重複書籍',
      metadata: { isbn: '123456789' }
    }
  ],
  
  conflictBooks: [
    {
      id: 'book_conflict_1',
      storedProgress: '60%',
      newProgress: '45%',
      conflictType: 'progress_regression'
    }
  ]
}

// DOM 選擇器測試資料
const domTestSelectors = {
  obsolete: ['.book-item', '.progress-bar', '[data-book-id]'],
  fallback: ['.library-book', '.reading-progress', '.book-card'],
  working: ['.current-book', '.progress-indicator']
}

// 網路限制測試資料
const networkTestData = {
  normalLoad: { requests: 20, limit: 30, window: '60s' },
  overLimit: { requests: 50, limit: 30, window: '60s' },
  burstLimit: { requests: 100, limit: 30, window: '60s' }
}
```

#### 3. 測試環境清理策略
```javascript
// 測試前設置
beforeEach(() => {
  // 重置所有 Mock
  jest.clearAllMocks()
  
  // 重置測試狀態
  testEnvironment.reset()
  
  // 設定預設 Mock 行為
  setupDefaultMocks()
})

// 測試後清理
afterEach(() => {
  // 清理測試資料
  testEnvironment.cleanup()
  
  // 驗證 Mock 呼叫
  verifyMockExpectations()
})

// 測試隔離策略
const testEnvironment = {
  reset: () => {
    // 重置狀態管理器
    StateManager.reset()
    
    // 清空快取
    CacheManager.clear()
    
    // 重置計時器
    jest.clearAllTimers()
  },
  
  cleanup: () => {
    // 清理暫存檔案
    cleanupTempFiles()
    
    // 釋放資源
    releaseResources()
  }
}
```

---

## 📋 測試實作記錄

### 計劃實作的測試檔案清單

#### 1. 核心功能測試
```
tests/unit/uc-02/
├── duplicate-detection/
│   ├── book-duplicate-detector.test.js      // 重複檢測測試
│   └── stable-id-generator.test.js          // ID 生成測試
├── incremental-update/
│   ├── incremental-book-updater.test.js     // 增量更新測試  
│   └── progress-conflict-resolver.test.js   // 衝突解決測試
├── dom-adaptation/
│   ├── readmoo-page-detector.test.js        // 頁面檢測測試
│   └── selector-adaptation.test.js          // 選擇器適應測試
└── network-handling/
    ├── rate-limit-detector.test.js          // 頻率限制測試
    └── network-resilience.test.js           // 網路復原測試
```

#### 2. 整合測試
```
tests/integration/uc-02/
├── uc02-full-workflow.test.js               // 完整工作流程
├── error-propagation.test.js                // 錯誤傳播測試
└── cross-module-integration.test.js         // 跨模組整合
```

#### 3. E2E 測試
```
tests/e2e/uc-02/
├── daily-extraction-workflow.test.js        // 日常提取流程
├── error-recovery-scenarios.test.js         // 錯誤恢復情境
└── readmoo-page-changes.test.js             // Readmoo 頁面變化測試
```

### 測試覆蓋範圍分析

#### 功能覆蓋率目標
- **正常流程測試**: 100% 覆蓋所有 UC-02 主要功能
- **邊界條件測試**: 100% 覆蓋所有已識別的邊界情況  
- **異常情況測試**: 100% 覆蓋所有 15 個錯誤情境
- **錯誤恢復測試**: 100% 覆蓋所有恢復策略

#### 程式碼覆蓋率目標
- **行覆蓋率**: ≥ 95%
- **分支覆蓋率**: ≥ 90% 
- **函數覆蓋率**: 100%
- **語句覆蓋率**: ≥ 95%

---

## ⚠️ TDD Phase 2 發現的設計問題

### 錯誤處理設計挑戰

#### 1. ErrorCodes 精確性問題
**發現**: 15 個核心 ErrorCodes 可能無法精確區分 UC-02 的 15 個特定錯誤情境

**分析**:
- `VALIDATION_ERROR` 需要區分「重複檢測失敗」vs「進度驗證錯誤」
- `DOM_ERROR` 需要區分「頁面結構變化」vs「無限滾動失敗」
- `OPERATION_ERROR` 需要區分「增量處理過載」vs「背景同步失敗」

**建議解決方案**:
```javascript
// 使用錯誤訊息進行精確區分
const error = new Error(`${ErrorCodes.VALIDATION_ERROR}: 重複書籍檢測機制失敗`)
error.code = ErrorCodes.VALIDATION_ERROR
error.subType = 'DUPLICATE_DETECTION_FAILED'  // 新增子類型
error.details = { 
  totalBooksScanned: 25,
  duplicateChecksFailed: 3,
  // ... 其他詳細資訊
}
```

#### 2. 測試模式一致性問題
**發現**: 需要在不同測試模式間保持一致性

**當前測試模式對比**:
```javascript
// 模式 A: 直接錯誤匹配
expect(() => operation()).toThrow(ErrorCodes.VALIDATION_ERROR)

// 模式 B: 訊息包含檢查  
expect(() => operation()).toThrow(/duplicate detection failed/)

// 模式 C: 結果物件檢查
const result = await operation()
expect(result.success).toBe(false)
expect(result.code).toBe(ErrorCodes.VALIDATION_ERROR)

// 模式 D: 完整錯誤物件檢查
await expect(operation()).rejects.toMatchObject({
  code: ErrorCodes.VALIDATION_ERROR,
  message: expect.stringContaining('特定錯誤'),
  details: expect.objectContaining({ /* ... */ })
})
```

**建議統一測試模式**:
- **Unit Tests**: 使用模式 A 或 B (簡潔快速)
- **Integration Tests**: 使用模式 D (完整驗證)
- **E2E Tests**: 使用模式 C (業務邏輯導向)

#### 3. Mock 物件複雜性問題
**發現**: UC-02 的增量更新和去重邏輯需要複雜的 Mock 設置

**挑戰**:
- 需要模擬 Readmoo 頁面的動態載入
- 需要模擬書籍資料的狀態變化
- 需要模擬網路條件的變化

**解決策略**:
- 建立階層式 Mock 架構
- 使用 Factory Pattern 產生測試資料
- 實作測試狀態管理器

---

## 🚀 後續 TDD 階段規劃

### TDD Phase 3: Green Phase (實作階段)
**目標**: 讓所有 Red Phase 測試通過

**主要任務**:
1. **ErrorCodes 整合**: 更新現有錯誤處理程式碼使用新的 ErrorCodes
2. **錯誤訊息標準化**: 統一錯誤訊息格式和內容
3. **錯誤詳細資訊處理**: 實作錯誤詳細資訊的標準化結構
4. **UC-02 特定邏輯**: 實作 UC-02 的增量更新和去重邏輯

### TDD Phase 4: Refactor Phase (重構階段)
**目標**: 優化程式碼品質，不影響測試通過率

**主要任務**:
1. **效能優化**: 最佳化錯誤處理的效能
2. **程式碼清理**: 移除重複程式碼，改善可讀性
3. **架構改善**: 確保錯誤處理架構的可維護性
4. **文件更新**: 同步更新相關文件

---

## 📈 成功交接標準

### 交接給 TDD Phase 3 的檢查點

#### ✅ 測試案例設計完整性
- [x] **15 個錯誤映射**: UC-02 所有 StandardError 已映射到 ErrorCodes
- [x] **測試案例實作**: 6 個優先測試案例設計完成
- [x] **邊界條件覆蓋**: 所有邊界條件已識別並設計測試
- [x] **異常情況覆蓋**: 所有異常情況已設計對應測試

#### ✅ Mock 物件和測試環境
- [x] **Mock 物件設計**: 核心 Mock 物件架構設計完成
- [x] **測試資料準備**: 完整的測試資料集準備完成  
- [x] **測試環境策略**: 測試隔離和清理策略設計完成
- [x] **測試工具配置**: Jest 配置和 ErrorCodes 整合完成

#### ✅ 測試覆蓋策略
- [x] **功能覆蓋**: 正常流程、邊界條件、異常情況 100% 覆蓋
- [x] **程式碼覆蓋**: 覆蓋率目標明確設定 (≥95%)
- [x] **測試分層**: Unit/Integration/E2E 測試分層規劃完成
- [x] **品質標準**: 測試品質檢查標準建立

#### ✅ 設計問題識別
- [x] **ErrorCodes 精確性**: 已識別並提供解決方案
- [x] **測試模式一致性**: 已建立統一測試模式指引
- [x] **Mock 複雜性**: 已設計階層式 Mock 架構
- [x] **效能考量**: 已考量測試執行效能

### 建議的遷移順序和時程

#### Phase 3 實作順序建議
1. **第1天**: `DATA_PROGRESS_VALIDATION_ERROR` → `VALIDATION_ERROR` (最直接對應)
2. **第2天**: `DOM_PAGE_STRUCTURE_CHANGED` → `DOM_ERROR` (高頻發生)
3. **第3天**: `DATA_DUPLICATE_DETECTION_FAILED` → `VALIDATION_ERROR` (複雜邏輯)
4. **第4天**: `NETWORK_RATE_LIMITING_DETECTED` → `NETWORK_ERROR` (網路處理)
5. **第5天**: `DATA_INCREMENTAL_UPDATE_CONFLICT` → `BOOK_ERROR` (核心業務邏輯)

#### 預期時程
- **TDD Phase 3** (Green): 5-7 個工作日
- **TDD Phase 4** (Refactor): 2-3 個工作日
- **整合測試和驗證**: 1-2 個工作日
- **總計**: 8-12 個工作日

---

## 📋 統一測試遷移模板

### 標準測試案例模板

#### 基本錯誤測試模板
```javascript
describe('[功能描述]', () => {
  test('應該在[錯誤條件]時拋出 [ERROR_CODE]', async () => {
    // Given: [設定錯誤條件]
    const mockObject = new MockObject()
    mockObject.method = jest.fn().mockRejectedValue(
      new Error(`${ErrorCodes.ERROR_CODE}: [具體錯誤訊息]`)
    )

    // When: [執行操作]
    // Then: [驗證錯誤]
    await expect(mockObject.method())
      .rejects.toMatchObject({
        code: ErrorCodes.ERROR_CODE,
        message: expect.stringContaining('[關鍵字]')
      })
  })

  test('邊界條件 - [邊界情況描述]', () => {
    // Given: [邊界條件設定]
    // When: [邊界操作]
    // Then: [邊界結果驗證]
  })

  test('異常情況 - [異常情況描述]', async () => {
    // Given: [異常條件設定]
    // When: [異常操作]
    // Then: [異常處理驗證]
  })
})
```

#### 複雜業務邻輯測試模板
```javascript
describe('[業務功能] - ErrorCodes 遷移測試', () => {
  let mockDependency
  let testSubject

  beforeEach(() => {
    mockDependency = createMockDependency()
    testSubject = new TestSubject(mockDependency)
  })

  describe('正常流程', () => {
    test('[正常情況描述]', async () => {
      // Given, When, Then
    })
  })

  describe('錯誤處理', () => {
    test('應該將 [OLD_ERROR] 遷移為 [NEW_ERROR_CODE]', async () => {
      // 遷移驗證邏輯
    })
  })

  describe('向後相容性', () => {
    test('應該保持相同的使用者體驗', async () => {
      // 使用者體驗驗證
    })
  })
})
```

### Mock 物件建立模板
```javascript
// 標準 Mock 工廠
const createMockObject = (customBehavior = {}) => ({
  // 預設行為
  defaultMethod: jest.fn().mockResolvedValue({ success: true }),
  errorMethod: jest.fn().mockRejectedValue(
    new Error(`${ErrorCodes.DEFAULT_ERROR}: 預設錯誤`)
  ),
  
  // 自定義行為覆蓋
  ...customBehavior
})

// 測試資料工廠
const createTestData = (type = 'default') => {
  const testDataTypes = {
    default: { /* 預設資料 */ },
    error: { /* 錯誤觸發資料 */ },
    boundary: { /* 邊界條件資料 */ }
  }
  
  return testDataTypes[type] || testDataTypes.default
}
```

---

## 📊 工作追蹤和指標

### 進度指標
- **測試案例設計**: ✅ 100% (12/12 個主要測試案例)
- **錯誤映射分析**: ✅ 100% (15/15 個錯誤已映射)  
- **Mock 物件設計**: ✅ 100% (核心 Mock 架構完成)
- **測試環境規劃**: ✅ 100% (環境策略設計完成)

### 品質指標
- **測試覆蓋完整性**: 100% (正常/邊界/異常情況都已涵蓋)
- **設計問題識別**: 100% (3 個主要設計挑戰已識別解決)
- **遷移模板建立**: 100% (統一模板已建立)
- **交接文件完整性**: 100% (所有交接標準已達成)

---

**TDD Phase 2 狀態**: ✅ **完成**  
**下一階段**: 🟢 TDD Phase 3 (Green Phase) - 功能實作階段  
**預計 Phase 3 完成時間**: 5-7 個工作日  
**關鍵交付物**: 
- UC-02 完整測試案例設計 (12 個核心測試)
- ErrorCodes 映射分析表 (15 個錯誤完整映射)  
- 統一測試遷移模板和最佳實踐指引
- Mock 物件架構和測試環境設計策略

---

# 🟢 TDD Phase 3: 功能實作規劃

## 📋 實作規劃資訊

- **TDD 階段**: 🟢 Phase 3 - Green Phase (功能實作)
- **規劃完成時間**: 2025-09-16
- **實作目標**: 讓所有 UC-02 ErrorCodes 測試通過，達成 Green 狀態
- **負責單位**: pepper-test-implementer (TDD實作規劃師) → 主線程執行

## 🎯 Phase 3 核心實作目標

### 主要任務
1. **UC-02 ErrorCodes 整合實作**: 將15個StandardError遷移至ErrorCodes v5.0.0系統
2. **測試驅動實作**: 基於Phase 2的12個核心測試案例實作功能
3. **最小可行版本**: 採用最簡實作策略，確保所有測試通過
4. **向後相容性**: 維持UC-02功能完整性，不破壞現有使用者體驗

### Green Phase 實作原則
- **測試優先通過**: 所有測試必須達到100%通過率 (Green狀態)
- **最小實作策略**: 實作最少程式碼讓測試通過，避免過度工程
- **功能保持一致**: 確保錯誤處理行為與原有StandardError完全一致
- **權衡方案明確**: 標註技術債務和未來改善方向

---

## 📊 實作策略設計

### 1. 實作策略分析

#### **漸進式遷移策略 (建議採用)**
**原理**: 不破壞現有功能的前提下，逐步引入ErrorCodes系統

**優點**:
- ✅ 風險最低，每個步驟都可驗證
- ✅ 可回退，如遇問題能立即恢復
- ✅ 測試通過率可持續保持100%
- ✅ 使用者體驗完全不受影響

**實作架構**:
```javascript
// 階段1: 建立錯誤轉換層 (ErrorAdapter)
class ErrorAdapter {
  static convertStandardErrorToErrorCodes(standardError) {
    const mapping = {
      'DATA_DUPLICATE_DETECTION_FAILED': ErrorCodes.VALIDATION_ERROR,
      'DATA_INCREMENTAL_UPDATE_CONFLICT': ErrorCodes.BOOK_ERROR,
      'DATA_PROGRESS_VALIDATION_ERROR': ErrorCodes.VALIDATION_ERROR,
      // ... 其他映射
    }
    
    const errorCode = mapping[standardError.code] || ErrorCodes.UNKNOWN_ERROR
    const error = new Error(standardError.message)
    error.code = errorCode
    error.originalCode = standardError.code  // 保留原始錯誤碼
    error.details = standardError.details
    return error
  }
}

// 階段2: UC-02模組逐步使用新系統
class UC02BookExtractor {
  async extractBooks() {
    try {
      // 現有邏輯
    } catch (originalError) {
      // 如果是StandardError，轉換為ErrorCodes
      if (originalError instanceof StandardError) {
        throw ErrorAdapter.convertStandardErrorToErrorCodes(originalError)
      }
      throw originalError
    }
  }
}
```

#### **技術債務最小化策略**
**權衡方案明確化**:
- **已知限制**: ErrorCodes 15個類型無法完全區分UC-02的12個特定情境
- **暫時解決**: 使用 error.message 和 error.details 提供精確錯誤資訊
- **未來改善**: Phase 4 重構時考慮ErrorCodes子類型或擴展機制

### 2. 詳細實作指引

#### **第一階段實作指引 (第1-2天)**
**目標測試群組**: VALIDATION_ERROR 類別錯誤
- `DATA_PROGRESS_VALIDATION_ERROR` → `ErrorCodes.VALIDATION_ERROR`
- `DATA_DUPLICATE_DETECTION_FAILED` → `ErrorCodes.VALIDATION_ERROR`

**核心程式碼範例**:
```javascript
// src/core/errors/UC02ErrorAdapter.js
export class UC02ErrorAdapter {
  // 進度驗證錯誤轉換
  static createProgressValidationError(invalidData) {
    const error = new Error(`閱讀進度格式驗證失敗`)
    error.code = ErrorCodes.VALIDATION_ERROR
    error.subType = 'PROGRESS_VALIDATION_ERROR'  
    error.details = {
      invalidProgressData: invalidData,
      correctionAttempted: true,
      originalCode: 'DATA_PROGRESS_VALIDATION_ERROR'
    }
    return error
  }

  // 重複檢測錯誤轉換
  static createDuplicateDetectionError(affectedBooks) {
    const error = new Error(`重複書籍檢測機制失敗`)
    error.code = ErrorCodes.VALIDATION_ERROR
    error.subType = 'DUPLICATE_DETECTION_FAILED'
    error.details = {
      affectedBooks: affectedBooks,
      fallbackStrategy: 'manual_review',
      originalCode: 'DATA_DUPLICATE_DETECTION_FAILED'
    }
    return error
  }
}
```

**實作步驟**:
1. 建立 `UC02ErrorAdapter.js` 檔案
2. 實作 2 個 VALIDATION_ERROR 轉換函數
3. 更新相關的UC-02模組使用新錯誤
4. 執行對應測試，確保通過

**預期問題解決方案**:
- **問題**: 兩個錯誤都映射到同一個 VALIDATION_ERROR
- **解決**: 使用 `subType` 屬性和詳細的 error.message 區分
- **驗證**: 測試中檢查 `error.details.originalCode` 確認正確轉換

#### **第二階段實作指引 (第3-4天)**
**目標測試群組**: DOM_ERROR 和 BOOK_ERROR 類別
- `DOM_PAGE_STRUCTURE_CHANGED` → `ErrorCodes.DOM_ERROR`
- `DOM_INFINITE_SCROLL_DETECTION_FAILED` → `ErrorCodes.DOM_ERROR`
- `DATA_INCREMENTAL_UPDATE_CONFLICT` → `ErrorCodes.BOOK_ERROR`

**核心程式碼範例**:
```javascript
// 擴展 UC02ErrorAdapter.js
export class UC02ErrorAdapter {
  // DOM 錯誤轉換
  static createPageStructureError(detectedChanges) {
    const error = new Error(`Readmoo 頁面結構已更新，需要適應新版面`)
    error.code = ErrorCodes.DOM_ERROR
    error.subType = 'PAGE_STRUCTURE_CHANGED'
    error.details = {
      detectedChanges: detectedChanges,
      adaptationAttempted: true,
      originalCode: 'DOM_PAGE_STRUCTURE_CHANGED'
    }
    return error
  }

  // 書籍更新衝突錯誤
  static createIncrementalUpdateError(conflictedBooks) {
    const error = new Error(`增量更新時發生資料衝突`)
    error.code = ErrorCodes.BOOK_ERROR
    error.subType = 'INCREMENTAL_UPDATE_CONFLICT'
    error.details = {
      conflictedBooks: conflictedBooks,
      suggestedResolution: 'keep_higher_progress',
      originalCode: 'DATA_INCREMENTAL_UPDATE_CONFLICT'
    }
    return error
  }
}
```

**整合策略**:
```javascript
// UC-02 相關模組更新範例
// src/content/extractors/book-data-extractor.js
class BookDataExtractor {
  async detectDuplicateBooks(books) {
    try {
      // 原有檢測邏輯
      const result = this.duplicateDetectionEngine.detect(books)
      return result
    } catch (error) {
      // 轉換為 ErrorCodes 系統
      if (error.code === 'DATA_DUPLICATE_DETECTION_FAILED') {
        throw UC02ErrorAdapter.createDuplicateDetectionError(error.details.affectedBooks)
      }
      throw error
    }
  }
}
```

#### **第三階段實作指引 (第5-6天)**
**目標測試群組**: 網路和系統錯誤
- `NETWORK_RATE_LIMITING_DETECTED` → `ErrorCodes.NETWORK_ERROR`
- `SYSTEM_INCREMENTAL_PROCESSING_OVERLOAD` → `ErrorCodes.OPERATION_ERROR`
- `PLATFORM_CHROME_EXTENSION_CONFLICT` → `ErrorCodes.CHROME_ERROR`

**關鍵程式碼範例**:
```javascript
// 完整的 UC02ErrorAdapter.js
export class UC02ErrorAdapter {
  // 統一轉換入口
  static convertError(standardErrorCode, message, details = {}) {
    const mapping = this.getErrorMapping()
    const errorCode = mapping[standardErrorCode] || ErrorCodes.UNKNOWN_ERROR
    
    const error = new Error(message)
    error.code = errorCode
    error.subType = this.extractSubType(standardErrorCode)
    error.details = {
      ...details,
      originalCode: standardErrorCode,
      timestamp: Date.now()
    }
    
    return error
  }
  
  static getErrorMapping() {
    return {
      'DATA_DUPLICATE_DETECTION_FAILED': ErrorCodes.VALIDATION_ERROR,
      'DATA_INCREMENTAL_UPDATE_CONFLICT': ErrorCodes.BOOK_ERROR,
      'DATA_PROGRESS_VALIDATION_ERROR': ErrorCodes.VALIDATION_ERROR,
      'DOM_PAGE_STRUCTURE_CHANGED': ErrorCodes.DOM_ERROR,
      'DOM_INFINITE_SCROLL_DETECTION_FAILED': ErrorCodes.DOM_ERROR,
      'DOM_DYNAMIC_CONTENT_TIMEOUT': ErrorCodes.TIMEOUT_ERROR,
      'SYSTEM_INCREMENTAL_PROCESSING_OVERLOAD': ErrorCodes.OPERATION_ERROR,
      'SYSTEM_BACKGROUND_SYNC_FAILURE': ErrorCodes.OPERATION_ERROR,
      'NETWORK_RATE_LIMITING_DETECTED': ErrorCodes.NETWORK_ERROR,
      'NETWORK_PARTIAL_CONNECTIVITY': ErrorCodes.CONNECTION_ERROR,
      'PLATFORM_TAB_SWITCHING_INTERFERENCE': ErrorCodes.CHROME_ERROR,
      'PLATFORM_CHROME_EXTENSION_CONFLICT': ErrorCodes.CHROME_ERROR
    }
  }
}
```

### 3. API介面實作詳述

#### **createError 和 createResult 整合**
基於 ErrorCodes.js 中的現有 API 設計統一介面：

```javascript
// src/core/errors/UC02ErrorFactory.js
import { ErrorCodes } from './ErrorCodes.js'

export class UC02ErrorFactory {
  /**
   * 建立 UC-02 專用錯誤
   * @param {string} originalCode - 原始 StandardError 錯誤碼
   * @param {string} message - 錯誤訊息  
   * @param {Object} details - 錯誤詳細資訊
   * @returns {Error} 符合 ErrorCodes 格式的錯誤物件
   */
  static createError(originalCode, message, details = {}) {
    const errorCode = UC02ErrorAdapter.getErrorMapping()[originalCode] 
                    || ErrorCodes.UNKNOWN_ERROR
                    
    const error = new Error(message)
    error.code = errorCode
    error.details = {
      ...details,
      originalCode: originalCode,
      severity: this.getSeverityFromCode(originalCode),
      timestamp: Date.now()
    }
    
    return error
  }
  
  /**
   * 建立 UC-02 操作結果
   * @param {boolean} success - 操作是否成功
   * @param {any} data - 成功時的資料
   * @param {Error} error - 失敗時的錯誤
   * @returns {Object} 標準化操作結果
   */
  static createResult(success, data = null, error = null) {
    if (success) {
      return {
        success: true,
        data: data,
        code: 'SUCCESS',
        message: 'Operation completed successfully'
      }
    } else {
      return {
        success: false,
        error: error?.message || 'Operation failed',
        code: error?.code || ErrorCodes.UNKNOWN_ERROR,
        details: error?.details || {}
      }
    }
  }
  
  static getSeverityFromCode(originalCode) {
    const severityMapping = {
      'DATA_PROGRESS_VALIDATION_ERROR': 'MINOR',
      'DATA_DUPLICATE_DETECTION_FAILED': 'MODERATE', 
      'DATA_INCREMENTAL_UPDATE_CONFLICT': 'MODERATE',
      'DOM_PAGE_STRUCTURE_CHANGED': 'MODERATE',
      'NETWORK_RATE_LIMITING_DETECTED': 'MODERATE',
      'SYSTEM_INCREMENTAL_PROCESSING_OVERLOAD': 'MODERATE',
      // ... 其他映射
    }
    return severityMapping[originalCode] || 'MODERATE'
  }
}
```

---

## 🔧 權宜方案與技術債務規劃

### 最小可用實作方案

#### **權宜方案1: 錯誤類型精確性不足**
**問題**: ErrorCodes的15個類型無法完全區分UC-02的12個具體錯誤情境

**最小實作解決方案**:
```javascript
// 使用 subType 和 details 提供精確資訊
const error = new Error(message)
error.code = ErrorCodes.VALIDATION_ERROR  // 主要類別
error.subType = 'DUPLICATE_DETECTION_FAILED'  // 精確子類型
error.details = {
  originalCode: 'DATA_DUPLICATE_DETECTION_FAILED',  // 保留原始標識
  severity: 'MODERATE',
  // ... 其他詳細資訊
}
```

**//todo: 改善方向**:
- 考慮在 Phase 4 引入 ErrorCodes 子類型系統
- 評估是否需要擴展 ErrorCodes 為更多特化類型
- 設計更精細的錯誤分類體系

#### **權宜方案2: 向後相容性處理**
**問題**: 現有程式碼可能依賴 StandardError 的特定屬性

**最小實作解決方案**:
```javascript
// ErrorAdapter 提供向後相容
class UC02ErrorAdapter {
  static ensureBackwardCompatibility(newError, originalStandardError) {
    // 保留 StandardError 的關鍵屬性
    if (originalStandardError.id) newError.id = originalStandardError.id
    if (originalStandardError.timestamp) newError.timestamp = originalStandardError.timestamp
    
    // 提供 toJSON 方法相容性
    newError.toJSON = function() {
      return {
        name: this.name,
        code: this.code,
        message: this.message,
        details: this.details,
        originalCode: this.details?.originalCode
      }
    }
    
    return newError
  }
}
```

**//todo: 改善方向**:
- Phase 4 統一錯誤物件介面設計
- 建立完整的錯誤物件相容性測試
- 考慮建立統一的錯誤基底類別

### 已知限制記錄

#### **限制1: 測試覆蓋不完整**
**當前狀況**: 基於 Phase 2 設計的 12 個測試案例，仍有部分邊界情況未涵蓋

**暫時解決**: 
- 先讓現有測試100%通過
- 標註未測試的邊界情況
- 在 Phase 4 補強測試覆蓋

**//todo: 改善清單**:
```javascript
//todo: 新增網路間歇性錯誤的邊界測試
//todo: 新增 DOM 選擇器多重回退機制測試  
//todo: 新增併發去重檢測的競爭條件測試
//todo: 新增大量書籍處理的記憶體限制測試
```

#### **限制2: 效能影響未量化**
**當前狀況**: ErrorAdapter 轉換層可能增加少量效能開銷

**暫時解決**: 
- 採用最簡轉換邏輯
- 快取常用的錯誤映射
- 延後複雜的效能優化

**//todo: 效能改善方向**:
```javascript
//todo: 建立錯誤處理效能基準測試
//todo: 實作錯誤物件池(Object Pool)減少記憶體分配
//todo: 優化熱路徑的錯誤建立邏輯
//todo: 分析並減少錯誤詳細資訊的序列化開銷
```

#### **限制3: Chrome Extension 環境相容性**
**當前狀況**: Service Worker 環境對錯誤處理有特殊限制

**暫時解決**: 
- 確保所有錯誤物件可序列化
- 避免在錯誤物件中使用 DOM 引用
- 測試 content script 與 background script 間的錯誤傳遞

**//todo: Chrome Extension 相容性改善**:
```javascript
//todo: 建立 Chrome Extension 環境的錯誤序列化測試
//todo: 實作 Service Worker 友善的錯誤處理機制
//todo: 設計跨 context 的錯誤資訊傳遞策略
//todo: 確認 chrome.storage API 對錯誤物件的支援度
```

### 重構準備策略

#### **為 Phase 4 重構準備的改善建議**

**1. 錯誤分類體系優化**
```javascript
// Phase 4 可考慮的錯誤分類改進
const ImprovedErrorCodes = {
  // 細分 VALIDATION_ERROR
  DATA_VALIDATION_ERROR: 'DATA_VALIDATION_ERROR',
  DUPLICATE_VALIDATION_ERROR: 'DUPLICATE_VALIDATION_ERROR', 
  PROGRESS_VALIDATION_ERROR: 'PROGRESS_VALIDATION_ERROR',
  
  // 細分 DOM_ERROR  
  DOM_STRUCTURE_ERROR: 'DOM_STRUCTURE_ERROR',
  DOM_LOADING_ERROR: 'DOM_LOADING_ERROR',
  DOM_INTERACTION_ERROR: 'DOM_INTERACTION_ERROR',
}
```

**2. 統一錯誤處理中介軟體**
```javascript
// Phase 4 可建立的中介軟體系統
class ErrorMiddleware {
  static async processError(error, context) {
    // 統一錯誤分類
    // 統一錯誤記錄
    // 統一恢復策略
    // 統一使用者通知
  }
}
```

**3. 錯誤恢復策略標準化**
```javascript
// Phase 4 可設計的恢復策略框架
class RecoveryStrategyManager {
  static getRecoveryStrategy(errorCode, context) {
    // 基於錯誤類型和情境的智慧恢復策略
    // 自動重試機制
    // 降級處理方案
    // 使用者介入點設計
  }
}
```

---

## ✅ 驗證與品質保證規劃

### 測試通過策略

#### **12個核心測試案例的通過方法**

**高優先級測試 (6個)**:
1. **DATA_DUPLICATE_DETECTION_FAILED → VALIDATION_ERROR**
   ```javascript
   // 通過策略: 確保轉換正確且資訊完整
   const error = UC02ErrorFactory.createError(
     'DATA_DUPLICATE_DETECTION_FAILED', 
     '重複書籍檢測機制失敗',
     { affectedBooks: mockBooks }
   )
   expect(error.code).toBe(ErrorCodes.VALIDATION_ERROR)
   expect(error.details.originalCode).toBe('DATA_DUPLICATE_DETECTION_FAILED')
   ```

2. **DATA_INCREMENTAL_UPDATE_CONFLICT → BOOK_ERROR**
   ```javascript
   // 通過策略: 驗證衝突資訊保存完整
   const error = UC02ErrorFactory.createError(
     'DATA_INCREMENTAL_UPDATE_CONFLICT',
     '增量更新時發生資料衝突', 
     { conflictedBooks: [conflictData] }
   )
   expect(error.code).toBe(ErrorCodes.BOOK_ERROR)
   expect(error.details.conflictedBooks).toEqual(expect.arrayContaining([conflictData]))
   ```

3. **DOM_PAGE_STRUCTURE_CHANGED → DOM_ERROR**
   ```javascript
   // 通過策略: 確保頁面變化適應資訊保留
   const error = UC02ErrorFactory.createError(
     'DOM_PAGE_STRUCTURE_CHANGED',
     'Readmoo 頁面結構已更新',
     { detectedChanges: changesList }
   )
   expect(error.code).toBe(ErrorCodes.DOM_ERROR)
   expect(error.details.detectedChanges).toBeDefined()
   ```

**中優先級測試 (4個)**:
- 使用相同的轉換策略確保所有 ErrorCodes 映射正確
- 驗證所有錯誤詳細資訊 (details) 完整保存
- 確保向後相容性 (原始錯誤碼保留)

**低優先級測試 (2個)**:
- 重點驗證 Chrome Extension 特有錯誤的處理
- 確保分頁切換和擴充功能衝突的優雅處理

#### **測試執行順序建議**
1. **單元測試先行**: 先確保 UC02ErrorAdapter 和 UC02ErrorFactory 功能正確
2. **整合測試跟進**: 驗證在實際UC-02流程中的錯誤處理
3. **端對端測試確認**: 完整的使用者情境測試

### 程式碼品質檢查規劃

#### **ESLint 規則遵循**
基於當前專案 ESLint 配置，確保新程式碼符合品質標準：

```javascript
// .eslintrc.js 重點規則遵循
module.exports = {
  rules: {
    // 避免 no-useless-catch 錯誤
    'no-useless-catch': 'error',
    
    // 確保 brace-style 一致性
    'brace-style': ['error', '1tbs'],
    
    // 避免重複類別成員
    'no-dupe-class-members': 'error',
    
    // 確保錯誤處理回調正確
    'n/handle-callback-err': 'error'
  }
}
```

**程式碼品質檢查點**:
```javascript
// ✅ 正確的錯誤處理方式
class UC02ErrorAdapter {
  static convertError(code, message, details) {
    // 避免 no-useless-catch
    try {
      const error = this.createError(code, message, details)
      return this.validateError(error)
    } catch (err) {
      // 有意義的錯誤處理，不直接 throw
      console.error('Error conversion failed:', err)
      return this.createFallbackError(err)
    }
  }
  
  // 避免 no-dupe-class-members
  static createError() { /* 實作 */ }
  // static createError() { /* 重複定義，會被檢測 */ } 
}
```

#### **最佳實踐應用**
**檔案命名和組織**:
```
src/core/errors/
├── ErrorCodes.js                    # 已存在
├── UC02ErrorAdapter.js             # 新增 - 錯誤轉換邏輯
├── UC02ErrorFactory.js             # 新增 - 錯誤建立工廠
└── __tests__/
    ├── UC02ErrorAdapter.test.js     # 新增 - 單元測試
    └── UC02ErrorFactory.test.js     # 新增 - 單元測試
```

**程式碼結構原則**:
- 單一責任：每個類別專注一個特定功能
- 依賴注入：避免硬編碼依賴，方便測試
- 錯誤處理：所有公開方法都要有適當的錯誤處理
- 文檔完整：所有公開 API 都要有 JSDoc 註解

### 邊界條件處理規劃

#### **異常情況處理策略**

**1. 無效輸入處理**:
```javascript
class UC02ErrorAdapter {
  static convertError(code, message, details) {
    // 處理 null/undefined 輸入
    if (!code || typeof code !== 'string') {
      return this.createError(
        ErrorCodes.UNKNOWN_ERROR, 
        'Invalid error code provided',
        { receivedCode: code, receivedType: typeof code }
      )
    }
    
    // 處理無法識別的錯誤碼
    const mapping = this.getErrorMapping()
    if (!mapping[code]) {
      return this.createError(
        ErrorCodes.UNKNOWN_ERROR,
        `Unknown error code: ${code}`,
        { unknownCode: code, availableCodes: Object.keys(mapping) }
      )
    }
    
    // 正常轉換邏輯
    return this.performConversion(code, message, details)
  }
}
```

**2. 記憶體限制處理**:
```javascript
class UC02ErrorFactory {
  static createError(code, message, details = {}) {
    // 限制錯誤詳細資訊大小，避免記憶體問題
    const safeDetails = this.sanitizeDetails(details)
    
    const error = new Error(message)
    error.code = code
    error.details = safeDetails
    
    return error
  }
  
  static sanitizeDetails(details) {
    const maxSize = 15 * 1024 // 15KB 限制 (與 StandardError 一致)
    const stringified = JSON.stringify(details)
    
    if (stringified.length > maxSize) {
      return {
        ...details,
        _truncated: true,
        _originalSize: stringified.length,
        // 移除或截斷過大的屬性
      }
    }
    
    return details
  }
}
```

**3. 網路和時序相關邊界處理**:
```javascript
// 處理網路相關錯誤的特殊邊界條件
class UC02NetworkErrorHandler {
  static handleRateLimitError(details) {
    // 確保退避延遲在合理範圍內
    const backoffDelay = Math.min(details.backoffDelay || 60000, 300000) // 最大5分鐘
    
    return UC02ErrorFactory.createError(
      'NETWORK_RATE_LIMITING_DETECTED',
      '檢測到 Readmoo 頻率限制',
      {
        ...details,
        backoffDelay: backoffDelay,
        maxRetries: 3,
        safetyTimeout: backoffDelay * 1.5
      }
    )
  }
}
```

### 效能考量和優化建議

#### **錯誤處理效能要求**
基於 StandardError 的效能標準：
- **記憶體使用**: < 1KB per error
- **處理時間**: < 1ms per error  
- **序列化大小**: < 15KB

#### **效能優化實作**:
```javascript
class UC02ErrorAdapter {
  // 快取常用映射，避免重複查找
  static _errorMappingCache = null
  
  static getErrorMapping() {
    if (!this._errorMappingCache) {
      this._errorMappingCache = Object.freeze({
        'DATA_DUPLICATE_DETECTION_FAILED': ErrorCodes.VALIDATION_ERROR,
        'DATA_INCREMENTAL_UPDATE_CONFLICT': ErrorCodes.BOOK_ERROR,
        // ... 其他映射
      })
    }
    return this._errorMappingCache
  }
  
  // 預建立常用錯誤物件，減少記憶體分配
  static _commonErrors = new Map()
  
  static getCommonError(code) {
    if (!this._commonErrors.has(code)) {
      const mapping = this.getErrorMapping()
      const errorCode = mapping[code] || ErrorCodes.UNKNOWN_ERROR
      
      const error = Object.freeze({
        code: errorCode,
        originalCode: code,
        timestamp: null // 使用時動態設定
      })
      
      this._commonErrors.set(code, error)
    }
    
    return this._commonErrors.get(code)
  }
}
```

---

## 📋 Phase 3 執行檢查清單

### 實作前準備檢查
- [ ] **Phase 2 交接確認**: 確認已完成12個測試案例設計和15個錯誤映射
- [ ] **開發環境準備**: 確認 Jest, ESLint 配置正常
- [ ] **現有程式碼分析**: 理解 UC-02 相關模組的現有錯誤處理方式
- [ ] **ErrorCodes.js 熟悉**: 確認理解 ErrorCodes v5.0.0 的 API 設計

### 第一階段實作檢查 (第1-2天)
- [ ] **UC02ErrorAdapter 建立**: 建立錯誤轉換核心類別
- [ ] **VALIDATION_ERROR 轉換**: 實作進度驗證和重複檢測錯誤轉換
- [ ] **單元測試通過**: 對應的2個測試案例100%通過
- [ ] **程式碼品質確認**: ESLint 通過，符合專案規範

### 第二階段實作檢查 (第3-4天)  
- [ ] **DOM_ERROR 實作**: 頁面結構和滾動檢測錯誤轉換
- [ ] **BOOK_ERROR 實作**: 增量更新衝突錯誤轉換
- [ ] **整合測試通過**: DOM和書籍相關測試案例通過
- [ ] **向後相容性驗證**: 現有UC-02功能完全正常

### 第三階段實作檢查 (第5-6天)
- [ ] **網路錯誤實作**: NETWORK_ERROR 和 CONNECTION_ERROR 轉換  
- [ ] **系統錯誤實作**: OPERATION_ERROR 和 CHROME_ERROR 轉換
- [ ] **完整測試通過**: 所有12個核心測試案例100%通過
- [ ] **端對端驗證**: UC-02 完整流程功能測試通過

### 實作完成交接檢查
- [ ] **測試通過率**: 所有 UC-02 相關測試100%通過 (Green狀態)
- [ ] **功能完整性**: UC-02 所有功能保持原有行為
- [ ] **程式碼品質**: ESLint 通過，符合品質標準
- [ ] **文檔完整性**: 新增程式碼有完整 JSDoc 註解
- [ ] **技術債務記錄**: 權衡方案和改善方向明確記錄

---

## 🚀 Phase 4 重構準備

### 重構準備建議

**效能最佳化準備**:
- 建立錯誤處理效能基準測試
- 識別熱路徑的效能瓶頸
- 準備錯誤物件池化策略

**架構改善準備**:
- 評估 ErrorCodes 擴展可行性
- 設計統一錯誤中介軟體系統
- 規劃跨模組錯誤處理標準化

**使用者體驗改善準備**:  
- 分析錯誤訊息的使用者友善度
- 設計錯誤恢復引導機制
- 準備錯誤預防和早期偵測系統

### 預期交接給 Phase 4 的成果

**技術實作成果**:
- ✅ UC-02 完整 ErrorCodes 遷移實作
- ✅ 所有測試100%通過 (Green狀態)
- ✅ 向後相容性完全保持
- ✅ 程式碼品質符合專案標準

**品質保證成果**:
- ✅ 12個核心測試案例全部通過
- ✅ ESLint 檢查完全通過
- ✅ 邊界條件和異常情況妥善處理
- ✅ Chrome Extension 環境相容性確認

**文檔和債務記錄**:
- ✅ 完整的實作文檔和 API 說明  
- ✅ 明確的技術債務清單和改善方向
- ✅ 效能基準和優化建議
- ✅ 架構演進和擴展建議

---

## 📈 預期時程和里程碑

### 詳細時程規劃

**第1天 (2025-09-17)**:
- 上午：環境準備和現有程式碼分析
- 下午：UC02ErrorAdapter 基礎框架建立和 VALIDATION_ERROR 實作

**第2天 (2025-09-18)**:  
- 上午：完成 VALIDATION_ERROR 相關測試通過
- 下午：開始 DOM_ERROR 和 BOOK_ERROR 實作

**第3天 (2025-09-19)**:
- 上午：完成 DOM 相關錯誤轉換
- 下午：完成書籍更新衝突錯誤處理

**第4天 (2025-09-20)**:
- 上午：整合測試和向後相容性驗證  
- 下午：開始網路和系統錯誤實作

**第5天 (2025-09-21)**:
- 上午：完成所有錯誤轉換實作
- 下午：全測試套件執行和問題修復

**第6-7天 (2025-09-22~23)**:
- 程式碼品質最佳化和文檔完善
- 端對端測試和使用者體驗驗證
- 技術債務整理和Phase 4準備

### 成功標準確認

**Phase 3 Green 完成標準**:
- [ ] **測試通過率**: 100% (所有12個核心測試案例)
- [ ] **功能完整性**: UC-02 所有現有功能保持不變
- [ ] **程式碼品質**: ESLint 0 warnings, 符合專案規範
- [ ] **效能要求**: 錯誤處理效能 ≤ 1ms, 記憶體使用 ≤ 1KB
- [ ] **Chrome Extension 相容**: Service Worker 和 Content Script 環境正常運作

**交接 Phase 4 準備標準**:
- [ ] **實作文檔**: 完整的 API 文檔和使用範例
- [ ] **技術債務**: 明確的改善方向和優先級排序  
- [ ] **測試覆蓋**: 識別未涵蓋的邊界情況和改善建議
- [ ] **架構建議**: Phase 4 重構的具體技術方案

---

**🟢 TDD Phase 3 狀態**: ✅ **實作規劃完成**  
**主線程實作指引**: 按照上述詳細規劃執行 UC-02 ErrorCodes 遷移實作  
**預計實作完成時間**: 5-7 個工作日  
**下一階段**: 🔵 TDD Phase 4 (Refactor Phase) - 由 cinnamon-refactor-owl 負責
