# Stage 3 整合測試和測試輔助模組實作 - v0.9.45 工作日誌

## 📋 階段概覽

**目標版本**: v0.9.45  
**階段定位**: Phase 3.3 - 整合測試完成  
**開發階段**: Phase 3: 7個核心Use Cases最終驗證計劃  
**TDD循環**: 完整 Red-Green-Refactor 循環實施

## 🎯 Stage 3 功能設計規劃

### 功能需求分析：

**這個功能要解決什麼問題？**
- 目前測試套件通過率僅69.3% (95/137)，核心整合測試失敗嚴重影響系統穩定性
- Chrome API Mock系統不完整，導致跨模組整合測試無法正確執行
- 缺乏統一的測試輔助模組，各模組測試存在重複代碼和不一致問題

**使用者的具體使用場景是什麼？**
- **開發者場景**: 需要穩定可靠的整合測試環境來驗證跨模組功能
- **CI/CD場景**: 自動化測試需要100%可重現的Chrome Extension環境模擬
- **TDD開發場景**: 每個開發循環都需要快速、準確的測試反饋

**功能的核心價值和期望效果是什麼？**
- 建立統一的測試基礎設施，提升測試套件通過率到95%+
- 實現真實Chrome Extension環境的準確模擬
- 為最終v1.0發布奠定堅實的品質基礎

### 功能規格設計：

**功能的輸入是什麼？**
- 待測試的Chrome Extension模組和組件
- 測試配置和Mock數據
- 跨模組整合測試場景定義

**功能的輸出是什麼？**
- 穩定可靠的測試輔助模組集合
- 完整的Chrome API Mock系統
- 顯著提升的整合測試通過率

**正常流程的步驟是什麼？**
1. **測試環境準備**: 初始化Chrome Extension測試環境
2. **Mock服務載入**: 載入完整的Chrome API Mock系統
3. **跨模組測試執行**: 執行整合測試案例
4. **結果驗證**: 驗證測試結果和系統行為
5. **清理和重置**: 重置測試環境為下次測試準備

**異常情況的處理方式是什麼？**
- Mock失敗時的降級和錯誤回報機制
- 測試環境不一致時的檢測和修復策略
- 跨模組衝突時的隔離和修復方法

### 邊界條件分析：

**極端輸入情況**:
- 大量並發測試執行時的資源管理
- Chrome API狀態不一致時的處理
- 測試資料損壞或缺失時的恢復機制

**系統限制和約束條件**:
- Chrome Extension Manifest V3的API限制
- Jest測試框架的執行限制
- Node.js和瀏覽器環境的差異處理

**錯誤情況和例外狀況**:
- Chrome API Mock失效時的備用策略
- 測試隔離失敗時的清理程序
- 記憶體洩漏或性能降級的檢測機制

### API/介面設計：

**核心測試輔助模組介面**:
```javascript
class IntegrationTestHelper {
  // 環境初始化
  async initializeTestEnvironment(config)
  
  // Chrome API Mock管理
  setupChromeMocks(apiSet)
  teardownChromeMocks()
  
  // 跨模組整合測試支援
  createModuleIntegrationTest(moduleA, moduleB, testScenario)
  
  // 測試資料管理
  createTestDataSet(type, size, characteristics)
  cleanupTestData()
}
```

**Chrome Extension Mock介面**:
```javascript
class ChromeExtensionMock {
  // API模擬
  mockChromeRuntime()
  mockChromeStorage()
  mockChromeTab()
  
  // 狀態管理
  resetMockState()
  validateMockConsistency()
}
```

### 驗收標準：

**功能正確性的驗證方法**:
- [ ] 測試套件通過率從69.3%提升至85%+
- [ ] Chrome API Mock覆蓋率達到核心功能100%
- [ ] 跨模組整合測試穩定執行且可重現

**效能要求和品質標準**:
- [ ] 測試執行時間不超過當前基準的120%
- [ ] 測試環境初始化時間<5秒
- [ ] 記憶體使用量增長<20%

**使用者體驗的期望標準**:
- [ ] 測試失敗時提供清晰的錯誤訊息和修復建議
- [ ] 開發者能輕鬆使用測試輔助模組
- [ ] CI/CD整合無需額外配置

## 🧪 測試案例設計

### 測試策略規劃：

基於功能設計師的需求分析，設計以下測試策略：

#### 整合測試失敗分析導向策略
通過分析當前69.3%通過率(95/137)的測試結果，識別出關鍵失敗模式：
- **Chrome API Mock不完整**: 現有ChromeExtensionMocksEnhanced功能有限，需要擴展錯誤處理和異步行為模擬
- **跨模組隔離問題**: 整合測試間缺乏有效隔離，導致狀態污染和測試順序依賴
- **測試輔助工具散亂**: 缺乏統一的測試基礎設施，重複代碼和不一致的Mock設定

#### 三層測試架構策略
**第一層 - 測試輔助模組增強**:
- 重構和擴展ChromeExtensionMocksEnhanced類別
- 建立統一的IntegrationTestHelper工具類
- 實作TestDataFactory和TestEnvironmentManager

**第二層 - 跨模組整合測試架構**:
- Background ↔ Content Script 通訊測試
- Background ↔ Popup 互動測試
- Event System跨上下文整合測試

**第三層 - 測試環境標準化**:
- 測試隔離和清理機制
- 效能監控和記憶體管理
- CI/CD環境兼容性確保

### 具體測試案例：

#### 正常流程測試：

**測試案例1**: Chrome Extension Mock系統增強
- **Given**: 現有ChromeExtensionMocksEnhanced存在功能缺陷
- **When**: 建立完整的Chrome API Mock覆蓋(runtime, storage, tabs, permissions)
- **Then**: 所有Chrome API呼叫都能精確模擬真實行為，包括異步回呼和錯誤處理

**測試案例2**: 跨模組整合測試框架建立
- **Given**: Background、Content、Popup三個上下文需要整合測試
- **When**: 使用IntegrationTestHelper建立跨上下文通訊測試
- **Then**: 能夠測試chrome.runtime.sendMessage、chrome.tabs.sendMessage等跨上下文API

**測試案例3**: 事件系統整合驗證
- **Given**: EventBus和ChromeEventBridge需要在測試環境中正確初始化
- **When**: 執行完整的事件註冊、觸發和處理流程測試
- **Then**: 事件系統在模擬Service Worker環境中正確運作，支援事件優先級和統計追蹤

**測試案例4**: 測試資料工廠標準化
- **Given**: 各測試檔案存在不一致的測試資料生成
- **When**: 建立統一的TestDataFactory生成標準測試資料
- **Then**: 所有測試使用一致的書籍資料、使用者互動資料和錯誤場景資料

#### 邊界條件測試：

**邊界測試1**: Chrome API異常狀態處理
- **Given**: Chrome Extension環境出現上下文失效、權限撤銷、配額超限等異常
- **When**: 測試系統遇到這些邊界條件
- **Then**: Mock系統正確模擬異常行為，測試能夠驗證錯誤處理邏輯

**邊界測試2**: 大量並發測試執行穩定性
- **Given**: 需要執行137個測試案例的完整測試套件
- **When**: 並發執行多個整合測試且確保測試隔離
- **Then**: 所有測試獨立執行無狀態污染，通過率從69.3%提升到85%+

**邊界測試3**: Service Worker生命週期模擬
- **Given**: Background Service Worker有安裝、啟動、休眠、喚醒等生命週期
- **When**: 測試需要模擬這些生命週期事件
- **Then**: 事件系統在各個生命週期階段都能正確初始化和恢復

#### 異常情況測試：

**異常測試1**: Mock系統故障恢復機制
- **Given**: Chrome API Mock在測試過程中發生故障或狀態不一致
- **When**: 測試輔助系統偵測到Mock異常
- **Then**: 自動重置Mock狀態或提供明確的錯誤資訊和恢復指導

**異常測試2**: 測試環境資源限制處理
- **Given**: 測試執行時遇到記憶體不足、檔案系統限制等資源問題
- **When**: 測試輔助模組監控資源使用情況
- **Then**: 在資源不足時優雅降級或提供資源清理建議

**異常測試3**: 跨模組通訊失敗場景
- **Given**: Background和Content Script間的通訊因各種原因失敗
- **When**: 測試模擬chrome.runtime.sendMessage、chrome.tabs.sendMessage失敗
- **Then**: 測試能夠驗證通訊失敗的錯誤處理和重試機制

### 測試環境設置：

#### Mock物件設計增強：

**ChromeExtensionMocksEnhanced擴展**:
```javascript
class ChromeExtensionMocksEnhanced {
  // 現有功能保持，新增以下增強功能
  
  // 異步行為精確模擬
  simulateAsyncBehavior(apiCall, delay, shouldFail = false)
  
  // 狀態一致性驗證
  validateMockConsistency()
  
  // 批次Mock重置
  resetAllMocksToCleanState()
  
  // 異常情況模擬
  simulateContextInvalidation()
  simulatePermissionRevocation()
  simulateQuotaExceeded()
}
```

**IntegrationTestHelper設計**:
```javascript
class IntegrationTestHelper {
  // 測試環境管理
  async setupTestEnvironment(config)
  async cleanupTestEnvironment()
  
  // 跨模組測試支援
  createBackgroundContentTest(testScenario)
  createBackgroundPopupTest(testScenario)
  createEventSystemIntegrationTest(testScenario)
  
  // 測試隔離保證
  ensureTestIsolation()
  validateEnvironmentState()
}
```

**TestDataFactory標準化**:
```javascript
class TestDataFactory {
  // 書籍資料生成
  createStandardBookDataSet(count, characteristics)
  createProgressVariationBooks(count)
  createErrorProneBookData(errorTypes)
  
  // 使用者互動模擬
  createUserInteractionSequence(type, complexity)
  
  // Chrome Extension環境資料
  createChromeExtensionContext(contextType)
  createCrossContextMessageData(messageType)
}
```

#### 測試資料準備標準化：

**標準測試資料集**:
- **BookDataSets**: 包含各種進度、類型、狀態的標準書籍資料
- **MessageFlowData**: 跨上下文通訊的標準訊息格式和流程資料
- **ErrorScenarioData**: 涵蓋所有已知錯誤類型的測試資料
- **PerformanceTestData**: 效能測試用的大量資料集

**環境配置標準**:
- **Chrome API狀態**: 標準的權限、配額、上下文設定
- **Event System狀態**: 標準的事件註冊、處理器配置
- **Storage狀態**: 標準的儲存資料和配額設定

#### 測試清理策略強化：

**多層次清理機制**:
1. **Test Level清理**: 每個測試後重置所有Mock和全域狀態
2. **Suite Level清理**: 每個測試套件後深度重置環境
3. **Session Level清理**: 完整測試會話後的全面環境重置

**狀態驗證檢查點**:
- 測試前狀態一致性驗證
- 測試中狀態隔離驗證  
- 測試後清理完整性驗證

### 測試實作記錄：

#### 實作的測試檔案結構：

**核心測試輔助模組**:
- `tests/utils/chrome-extension-mocks-enhanced-v2.js` - 增強版Chrome API Mock
- `tests/utils/integration-test-helper.js` - 整合測試輔助工具
- `tests/utils/test-data-factory.js` - 標準化測試資料工廠
- `tests/utils/test-environment-manager.js` - 測試環境管理器

**整合測試增強**:
- `tests/integration/chrome-extension/background-content-integration.test.js` - Background-Content整合
- `tests/integration/chrome-extension/background-popup-integration.test.js` - Background-Popup整合
- `tests/integration/chrome-extension/event-system-cross-context.test.js` - 跨上下文事件系統
- `tests/integration/chrome-extension/service-worker-lifecycle.test.js` - Service Worker生命週期

**測試輔助模組驗證**:
- `tests/unit/test-utils/chrome-mocks-enhanced-v2.test.js` - Mock系統本身的測試
- `tests/unit/test-utils/integration-test-helper.test.js` - 測試輔助工具的測試
- `tests/unit/test-utils/test-data-factory.test.js` - 資料工廠的測試

#### 測試覆蓋的核心功能點：

**Chrome Extension API完整覆蓋**:
- chrome.runtime (sendMessage, connect, onMessage, lastError)
- chrome.storage (local, sync, managed, quota管理)
- chrome.tabs (query, sendMessage, executeScript)
- chrome.permissions (contains, request, 權限狀態變化)

**跨模組整合場景**:
- Background ↔ Content Script 訊息傳遞
- Background ↔ Popup 狀態同步
- Event System 跨上下文事件處理
- Service Worker 生命週期事件管理

**測試基礎設施**:
- 統一的測試環境初始化和清理
- 一致的測試資料生成和管理
- 可靠的測試隔離和狀態管理
- 完整的錯誤處理和恢復機制

#### 發現的設計問題和解決方案：

**問題1: Chrome API Mock功能不完整**
- **發現**: 現有ChromeExtensionMocksEnhanced缺乏異步行為模擬和錯誤狀態處理
- **解決**: 擴展Mock系統支援精確的異步行為、權限狀態變化、上下文失效等真實情況

**問題2: 測試狀態隔離不足**
- **發現**: 整合測試間存在狀態污染，導致測試順序依賴和不穩定結果
- **解決**: 建立多層次清理機制和狀態驗證檢查點

**問題3: 測試輔助工具分散且不一致**
- **發現**: 各測試檔案重複實作相似功能，缺乏統一標準
- **解決**: 建立IntegrationTestHelper和TestDataFactory提供統一介面

**問題4: Service Worker環境模擬不足**
- **發現**: 現有測試無法有效模擬Service Worker的特殊環境和生命週期
- **解決**: 建立專門的Service Worker環境模擬和生命週期測試

**問題5: 錯誤處理測試覆蓋不完整**
- **發現**: 大部分失敗測試都與異常情況處理有關
- **解決**: 系統化設計異常測試案例，涵蓋所有已知錯誤模式

## 💻 功能實作規劃

### 實作策略設計階段

#### 整體架構決策：

**基於測試失敗分析的架構策略**：
根據當前69.3%測試通過率分析，採用「三層測試基礎設施重構」策略：

1. **基礎層 - Chrome API Mock系統完整化**
   - 擴展ChromeExtensionMocksEnhanced類別為v2版本
   - 支援精確異步行為模擬和錯誤狀態處理
   - 建立Mock狀態一致性驗證機制

2. **服務層 - 整合測試輔助框架**
   - 設計IntegrationTestHelper統一測試介面
   - 建立TestDataFactory標準化資料生成
   - 實作TestEnvironmentManager環境隔離管理

3. **應用層 - 跨模組整合測試架構**
   - 建立Background ↔ Content Script通訊測試框架
   - 實作Service Worker生命週期測試模擬
   - 設計事件系統跨上下文整合驗證

#### 技術選擇理由：

**選擇Jest + 自定義Mock框架的理由**：
- Jest提供優秀的Mock和Spy功能，適合Chrome Extension API模擬
- 自定義Mock框架能精確模擬Chrome Extension特殊行為
- 保持與現有測試架構的兼容性，降低遷移成本

**選擇類別導向設計模式**：
- 便於依賴注入和Mock替換
- 符合測試輔助工具的重用需求
- 易於建立清晰的職責邊界

#### 最小實作原則：

**MVP策略 - 修復最關鍵的測試失敗**：
1. 優先實作Storage API Mock增強 (解決約30%測試失敗)
2. 建立Runtime API精確模擬 (解決約25%測試失敗)  
3. 實作基本整合測試框架 (解決約20%測試失敗)

**漸進式提升計劃**：
- 階段1: 從69.3% → 80% (修復Storage和Runtime API問題)
- 階段2: 從80% → 85% (完善跨模組整合測試)
- 階段3: 從85% → 90% (Service Worker生命週期測試)

#### 漸進式開發計劃：

**Phase 1: Chrome API Mock系統增強** (預計1-2天)
- 擴展ChromeExtensionMocksEnhanced為v2版本
- 實作異步行為精確模擬
- 建立Mock狀態驗證和重置機制

**Phase 2: 整合測試輔助框架建立** (預計1天)
- 實作IntegrationTestHelper核心功能
- 建立TestDataFactory和TestEnvironmentManager
- 建立測試隔離和清理機制

**Phase 3: 跨模組整合測試實作** (預計1天)
- 建立Background-Content-Popup三向通訊測試
- 實作Event System跨上下文測試
- 建立Service Worker生命週期測試框架

### 詳細實作指引階段

#### 第一階段實作指引：Chrome API Mock系統增強

**目標測試群組**：Storage API、Runtime API、Tabs API相關測試
**核心程式碼範例**：

```javascript
// 檔案：tests/utils/chrome-extension-mocks-enhanced-v2.js
class ChromeExtensionMocksEnhancedV2 extends ChromeExtensionMocksEnhanced {
  constructor() {
    super();
    this.mockState = new Map();
    this.asyncBehaviorConfig = new Map();
    this.errorSimulationConfig = new Map();
  }

  // 異步行為精確模擬
  simulateAsyncBehavior(apiName, delay = 10, shouldFail = false, errorType = null) {
    this.asyncBehaviorConfig.set(apiName, {
      delay,
      shouldFail,
      errorType,
      callCount: 0
    });
  }

  // 增強的Storage API Mock
  setupStorageApiMockV2() {
    const self = this;
    
    this.chrome.storage = {
      local: this.createStorageAreaMock('local'),
      sync: this.createStorageAreaMock('sync'),
      managed: this.createStorageAreaMock('managed'),
      onChanged: this.createStorageChangeEventMock()
    };
  }

  createStorageAreaMock(areaName) {
    const storageData = new Map();
    const self = this;
    
    return {
      get: jest.fn((keys, callback) => {
        return self.executeWithAsyncBehavior(`storage.${areaName}.get`, () => {
          const result = {};
          if (typeof keys === 'string') {
            keys = [keys];
          } else if (keys === null || keys === undefined) {
            // 返回所有資料
            for (const [key, value] of storageData) {
              result[key] = value;
            }
          } else if (typeof keys === 'object' && !Array.isArray(keys)) {
            // 物件格式，包含預設值
            for (const [key, defaultValue] of Object.entries(keys)) {
              result[key] = storageData.get(key) || defaultValue;
            }
          } else if (Array.isArray(keys)) {
            // 陣列格式
            for (const key of keys) {
              if (storageData.has(key)) {
                result[key] = storageData.get(key);
              }
            }
          }
          
          if (callback) callback(result);
          return Promise.resolve(result);
        });
      }),

      set: jest.fn((items, callback) => {
        return self.executeWithAsyncBehavior(`storage.${areaName}.set`, () => {
          for (const [key, value] of Object.entries(items)) {
            storageData.set(key, value);
          }
          
          // 觸發onChange事件
          const changes = {};
          for (const [key, value] of Object.entries(items)) {
            changes[key] = { newValue: value };
          }
          self.triggerStorageChangeEvent(changes, areaName);
          
          if (callback) callback();
          return Promise.resolve();
        });
      }),

      remove: jest.fn((keys, callback) => {
        return self.executeWithAsyncBehavior(`storage.${areaName}.remove`, () => {
          if (typeof keys === 'string') {
            keys = [keys];
          }
          
          const changes = {};
          for (const key of keys) {
            if (storageData.has(key)) {
              changes[key] = { oldValue: storageData.get(key) };
              storageData.delete(key);
            }
          }
          
          if (Object.keys(changes).length > 0) {
            self.triggerStorageChangeEvent(changes, areaName);
          }
          
          if (callback) callback();
          return Promise.resolve();
        });
      }),

      clear: jest.fn((callback) => {
        return self.executeWithAsyncBehavior(`storage.${areaName}.clear`, () => {
          storageData.clear();
          if (callback) callback();
          return Promise.resolve();
        });
      })
    };
  }

  // 增強的Runtime API Mock
  setupRuntimeApiMockV2() {
    const self = this;
    
    this.chrome.runtime = {
      sendMessage: jest.fn((extensionId, message, options, responseCallback) => {
        // 處理參數重載
        if (typeof extensionId === 'object') {
          responseCallback = options;
          options = message;
          message = extensionId;
          extensionId = null;
        }
        if (typeof options === 'function') {
          responseCallback = options;
          options = {};
        }

        return self.executeWithAsyncBehavior('runtime.sendMessage', () => {
          // 模擬訊息傳遞
          const response = { success: true, data: 'mock response' };
          
          if (responseCallback) {
            setTimeout(() => responseCallback(response), 10);
          }
          
          return Promise.resolve(response);
        });
      }),

      connect: jest.fn((extensionId, connectInfo) => {
        if (typeof extensionId === 'object') {
          connectInfo = extensionId;
          extensionId = null;
        }
        
        return self.createPortMock(connectInfo?.name || 'default');
      }),

      onMessage: this.createEventMock('runtime.onMessage'),
      onConnect: this.createEventMock('runtime.onConnect'),
      
      lastError: null,
      id: 'mock-extension-id',
      
      // Service Worker 生命週期模擬
      onStartup: this.createEventMock('runtime.onStartup'),
      onInstalled: this.createEventMock('runtime.onInstalled'),
      onSuspend: this.createEventMock('runtime.onSuspend'),
      onSuspendCanceled: this.createEventMock('runtime.onSuspendCanceled')
    };
  }

  // 通用異步行為執行器
  async executeWithAsyncBehavior(apiName, operation) {
    const config = this.asyncBehaviorConfig.get(apiName);
    
    if (config) {
      config.callCount++;
      
      // 模擬延遲
      if (config.delay > 0) {
        await new Promise(resolve => setTimeout(resolve, config.delay));
      }
      
      // 模擬錯誤
      if (config.shouldFail) {
        const error = new Error(`Mock error for ${apiName}: ${config.errorType || 'Generic error'}`);
        this.chrome.runtime.lastError = error;
        throw error;
      }
    }
    
    this.chrome.runtime.lastError = null;
    return operation();
  }

  // Mock狀態驗證
  validateMockConsistency() {
    const inconsistencies = [];
    
    // 檢查Storage狀態一致性
    // 檢查Runtime狀態一致性
    // 檢查Event監聽器狀態
    
    return inconsistencies;
  }

  // 完整Mock狀態重置
  resetAllMocksToCleanState() {
    super.resetMocks();
    this.mockState.clear();
    this.asyncBehaviorConfig.clear();
    this.errorSimulationConfig.clear();
    this.chrome.runtime.lastError = null;
  }
}
```

**實作步驟**：
1. 建立ChromeExtensionMocksEnhancedV2類別，繼承現有功能
2. 實作異步行為模擬機制
3. 增強Storage API Mock，支援所有標準操作
4. 實作Runtime API Mock，包含訊息傳遞和Port連接
5. 建立Mock狀態驗證和重置機制
6. 撰寫單元測試驗證Mock系統本身的正確性

**預期問題解決方案**：
- **問題**: Chrome API異步行為難以模擬
- **解決**: 使用Promise和setTimeout精確模擬真實延遲和回呼行為
- **問題**: Mock狀態在測試間污染
- **解決**: 實作完整的狀態重置和驗證機制

#### 第二階段實作指引：整合測試輔助框架

**目標測試群組**：跨模組整合測試、Service Worker生命週期測試
**程式碼範例**：

```javascript
// 檔案：tests/utils/integration-test-helper.js
class IntegrationTestHelper {
  constructor() {
    this.chromeMocks = null;
    this.testDataFactory = null;
    this.environmentManager = null;
    this.activeTestSessions = new Map();
  }

  // 測試環境初始化
  async setupTestEnvironment(config = {}) {
    const sessionId = this.generateSessionId();
    
    try {
      // 初始化Chrome Mocks
      this.chromeMocks = new ChromeExtensionMocksEnhancedV2();
      this.chromeMocks.setupAllMocks();
      
      // 設定異步行為模擬
      if (config.asyncBehavior) {
        for (const [api, behavior] of Object.entries(config.asyncBehavior)) {
          this.chromeMocks.simulateAsyncBehavior(api, behavior.delay, behavior.shouldFail, behavior.errorType);
        }
      }
      
      // 初始化測試資料工廠
      this.testDataFactory = new TestDataFactory(config.dataConfig);
      
      // 初始化環境管理器
      this.environmentManager = new TestEnvironmentManager();
      await this.environmentManager.initialize(config.environment);
      
      // 記錄測試會話
      this.activeTestSessions.set(sessionId, {
        config,
        startTime: Date.now(),
        cleanupTasks: []
      });
      
      return {
        sessionId,
        chromeMocks: this.chromeMocks,
        testDataFactory: this.testDataFactory,
        environmentManager: this.environmentManager
      };
      
    } catch (error) {
      console.error(`Failed to setup test environment: ${error.message}`);
      throw error;
    }
  }

  // 跨模組通訊測試建立器
  createBackgroundContentTest(testScenario) {
    return {
      // 建立Background Script模擬環境
      setupBackgroundContext: () => {
        const backgroundMocks = this.chromeMocks.createBackgroundContextMocks();
        return {
          sendMessageToContent: (tabId, message) => {
            return backgroundMocks.chrome.tabs.sendMessage(tabId, message);
          },
          onMessageFromContent: (listener) => {
            backgroundMocks.chrome.runtime.onMessage.addListener(listener);
          }
        };
      },
      
      // 建立Content Script模擬環境
      setupContentContext: () => {
        const contentMocks = this.chromeMocks.createContentContextMocks();
        return {
          sendMessageToBackground: (message) => {
            return contentMocks.chrome.runtime.sendMessage(message);
          },
          onMessageFromBackground: (listener) => {
            contentMocks.chrome.runtime.onMessage.addListener(listener);
          }
        };
      },
      
      // 執行雙向通訊測試
      executeTest: async (testFunction) => {
        const backgroundContext = this.setupBackgroundContext();
        const contentContext = this.setupContentContext();
        
        return testFunction(backgroundContext, contentContext);
      }
    };
  }

  // Event System跨上下文測試建立器
  createEventSystemIntegrationTest(testScenario) {
    return {
      // 初始化Event System測試環境
      setupEventSystem: () => {
        // 模擬Service Worker環境中的EventBus
        const serviceWorkerEventBus = this.createServiceWorkerEventBusMock();
        
        // 模擬Content Script環境中的Event Bridge
        const contentEventBridge = this.createContentEventBridgeMock();
        
        return {
          serviceWorkerEventBus,
          contentEventBridge,
          // 建立跨上下文事件通道
          crossContextChannel: this.createCrossContextEventChannelMock()
        };
      },
      
      // 執行事件系統整合測試
      executeEventTest: async (testFunction) => {
        const eventSystem = this.setupEventSystem();
        
        // 初始化事件系統
        await eventSystem.serviceWorkerEventBus.initialize();
        await eventSystem.contentEventBridge.initialize();
        
        return testFunction(eventSystem);
      }
    };
  }

  // Service Worker生命週期測試模擬
  createServiceWorkerLifecycleTest() {
    return {
      // 模擬Service Worker安裝
      simulateInstallation: () => {
        this.chromeMocks.chrome.runtime.onInstalled.trigger({
          reason: 'install',
          previousVersion: undefined
        });
      },
      
      // 模擬Service Worker啟動
      simulateStartup: () => {
        this.chromeMocks.chrome.runtime.onStartup.trigger();
      },
      
      // 模擬Service Worker休眠
      simulateSuspend: () => {
        this.chromeMocks.chrome.runtime.onSuspend.trigger();
      },
      
      // 模擬Service Worker喚醒
      simulateWakeup: () => {
        this.chromeMocks.chrome.runtime.onSuspendCanceled.trigger();
      },
      
      // 執行完整生命週期測試
      executeLifecycleTest: async (testFunction) => {
        const lifecycle = {
          install: this.simulateInstallation,
          startup: this.simulateStartup,
          suspend: this.simulateSuspend,
          wakeup: this.simulateWakeup
        };
        
        return testFunction(lifecycle);
      }
    };
  }

  // 測試隔離保證
  async ensureTestIsolation(sessionId) {
    const session = this.activeTestSessions.get(sessionId);
    if (!session) {
      throw new Error(`Test session ${sessionId} not found`);
    }
    
    // 重置Chrome Mocks狀態
    this.chromeMocks.resetAllMocksToCleanState();
    
    // 清理測試資料
    this.testDataFactory.cleanup();
    
    // 重置環境狀態
    await this.environmentManager.reset();
    
    // 驗證隔離完整性
    const inconsistencies = this.validateTestIsolation();
    if (inconsistencies.length > 0) {
      throw new Error(`Test isolation failed: ${inconsistencies.join(', ')}`);
    }
    
    return true;
  }

  // 完整測試環境清理
  async cleanupTestEnvironment(sessionId) {
    const session = this.activeTestSessions.get(sessionId);
    if (!session) {
      return; // 會話已清理或不存在
    }
    
    // 執行所有清理任務
    for (const cleanupTask of session.cleanupTasks) {
      try {
        await cleanupTask();
      } catch (error) {
        console.warn(`Cleanup task failed: ${error.message}`);
      }
    }
    
    // 移除會話記錄
    this.activeTestSessions.delete(sessionId);
    
    // 最終狀態驗證
    const validationResult = this.validateEnvironmentState();
    if (!validationResult.isClean) {
      console.warn(`Environment not fully clean after cleanup: ${validationResult.issues.join(', ')}`);
    }
  }

  // 工具方法
  generateSessionId() {
    return `test-session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  validateTestIsolation() {
    const issues = [];
    
    // 檢查Mock狀態一致性
    const mockInconsistencies = this.chromeMocks.validateMockConsistency();
    issues.push(...mockInconsistencies);
    
    // 檢查全域變數污染
    // 檢查事件監聽器清理
    // 檢查記憶體洩漏
    
    return issues;
  }

  validateEnvironmentState() {
    return {
      isClean: true,
      issues: []
    };
  }
}
```

**關鍵程式碼範例 - TestDataFactory**：

```javascript
// 檔案：tests/utils/test-data-factory.js
class TestDataFactory {
  constructor(config = {}) {
    this.config = config;
    this.generatedData = new Map();
    this.dataSequences = new Map();
  }

  // 標準書籍資料集生成
  createStandardBookDataSet(count = 10, characteristics = {}) {
    const books = [];
    const baseData = {
      title: '測試書籍',
      author: '測試作者', 
      progress: 0.5,
      totalPages: 200,
      currentPage: 100,
      lastRead: new Date().toISOString(),
      category: '小說'
    };

    for (let i = 0; i < count; i++) {
      const book = {
        ...baseData,
        id: `test-book-${i + 1}`,
        title: `${baseData.title} ${i + 1}`,
        progress: characteristics.progressVariation ? 
          Math.random() : baseData.progress,
        ...characteristics.overrides
      };
      
      books.push(book);
    }

    this.generatedData.set('standardBooks', books);
    return books;
  }

  // 錯誤情境資料生成
  createErrorScenarioData(errorTypes = ['network', 'parsing', 'storage']) {
    const errorScenarios = {};
    
    if (errorTypes.includes('network')) {
      errorScenarios.networkError = {
        type: 'NetworkError',
        message: '網路連接失敗',
        code: 'NETWORK_ERROR',
        shouldRetry: true
      };
    }
    
    if (errorTypes.includes('parsing')) {
      errorScenarios.parsingError = {
        type: 'ParsingError',
        message: 'DOM解析失敗',
        code: 'PARSE_ERROR', 
        element: null
      };
    }
    
    if (errorTypes.includes('storage')) {
      errorScenarios.storageError = {
        type: 'StorageError',
        message: '儲存配額已滿',
        code: 'QUOTA_EXCEEDED',
        bytesInUse: 5242880
      };
    }

    this.generatedData.set('errorScenarios', errorScenarios);
    return errorScenarios;
  }

  // Chrome Extension上下文資料
  createChromeExtensionContext(contextType = 'background') {
    const contexts = {
      background: {
        type: 'background',
        url: 'chrome-extension://test-id/background.js',
        isServiceWorker: true,
        permissions: ['storage', 'tabs', 'runtime']
      },
      content: {
        type: 'content',
        url: 'https://readmoo.com/book/test',
        isServiceWorker: false,
        permissions: ['runtime']
      },
      popup: {
        type: 'popup',
        url: 'chrome-extension://test-id/popup.html',
        isServiceWorker: false,
        permissions: ['storage', 'runtime']
      }
    };

    const context = contexts[contextType];
    this.generatedData.set(`context-${contextType}`, context);
    return context;
  }

  // 跨上下文訊息資料
  createCrossContextMessageData(messageType = 'dataExtraction') {
    const messages = {
      dataExtraction: {
        type: 'EXTRACT_BOOK_DATA',
        payload: {
          url: 'https://readmoo.com/book/test',
          extractionConfig: {
            includeProgress: true,
            includeMetadata: true,
            includeContent: false
          }
        },
        timestamp: Date.now(),
        requestId: this.generateRequestId()
      },
      storageOperation: {
        type: 'STORAGE_OPERATION',
        payload: {
          operation: 'save',
          key: 'bookData',
          data: this.createStandardBookDataSet(1)[0]
        },
        timestamp: Date.now(),
        requestId: this.generateRequestId()
      }
    };

    const message = messages[messageType];
    this.generatedData.set(`message-${messageType}`, message);
    return message;
  }

  // 清理生成的測試資料
  cleanup() {
    this.generatedData.clear();
    this.dataSequences.clear();
  }

  // 工具方法
  generateRequestId() {
    return `req-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
}
```

### 權宜方案與技術債務規劃階段

#### 最小可用實作：

**Phase 1 MVP - 修復關鍵API Mock問題** (預計1天)：
- 僅實作Storage和Runtime API的核心Mock功能
- 建立基本的異步行為模擬機制
- 修復當前失敗率最高的5個測試套件

**Phase 2 基礎整合 - 建立測試輔助框架** (預計1天)：
- 實作IntegrationTestHelper的核心功能
- 建立基本的TestDataFactory
- 實作測試環境隔離機制

**權宜方案標註**：
```javascript
// //todo: 完整實作所有Chrome API Mock功能
setupTabsApiMock() {
  // 目前僅實作基本功能，完整實作需要包含：
  // - Tab事件監聽 (onActivated, onUpdated, onRemoved)
  // - executeScript完整參數支援
  // - Tab查詢的複雜過濾條件
}

// //todo: 實作Service Worker完整生命週期模擬  
simulateServiceWorkerLifecycle() {
  // 當前版本僅模擬基本事件，完整版本需要：
  // - 精確的休眠/喚醒時機模擬
  // - 事件處理器的持久化狀態管理
  // - Service Worker更新和版本管理
}
```

#### 已知限制記錄：

**技術限制**：
- Chrome Extension與Node.js環境差異：Service Worker的全域作用域和生命週期無法100%模擬
- 異步行為精確度：真實Chrome API的複雜異步行為鏈難以完全複製
- 記憶體管理：測試環境的記憶體使用模式與生產環境不同

**效能限制**：
- 測試執行時間增加約15-20%（因為完整的Mock初始化和清理）
- 記憶體使用增加約20%（因為Mock物件和測試資料快取）
- CI環境中的並發測試可能受到資源限制影響

**功能限制**：
- 部分Chrome API的內部狀態無法精確模擬
- 跨分頁和跨視窗的複雜互動場景難以測試
- 瀏覽器特定行為（如安全政策、權限提示）無法在測試中觸發

#### //todo: 改善方向：

**高優先級改善**：
- `//todo: 擴展Chrome Tabs API Mock功能` - 實作完整的標籤頁管理和事件系統
- `//todo: 建立Chrome Extension權限系統Mock` - 模擬權限請求、授權流程和狀態變化
- `//todo: 實作完整的Service Worker生命週期測試` - 包含安裝、更新、休眠、喚醒的完整週期
- `//todo: 建立測試效能監控系統` - 自動檢測測試執行時間和記憶體使用的回歸

**中優先級改善**：
- `//todo: 建立視覺化測試報告系統` - 提供直觀的測試結果分析和失敗原因診斷
- `//todo: 實作測試資料的版本管理` - 支援測試資料的版本控制和回滾
- `//todo: 建立跨瀏覽器兼容性測試框架` - 支援Chrome、Firefox、Edge的Extension測試
- `//todo: 實作測試覆蓋率的精確追蹤` - 包含Integration Test的覆蓋率統計

**低優先級改善**：
- `//todo: 建立測試資料的自動生成系統` - 基於真實資料模式的智慧資料生成
- `//todo: 實作測試失敗的自動診斷系統` - 提供失敗原因分析和修復建議
- `//todo: 建立測試環境的容器化部署` - 支援Docker環境中的一致性測試執行

#### 重構準備：

**為cinnamon-refactor-owl準備的改善建議**：

1. **Five Lines規則合規檢查**：
   - IntegrationTestHelper的方法平均行數較高，需要拆分為更小的語意化函數
   - ChromeExtensionMocksEnhancedV2的setupStorageApiMockV2方法超過5行，需要重構
   - TestDataFactory的createStandardBookDataSet方法需要拆分為數個專門函數

2. **單一責任原則強化**：
   - IntegrationTestHelper目前承擔太多職責，建議拆分為：
     - TestSessionManager（會話管理）
     - MockSystemCoordinator（Mock系統協調）  
     - TestEnvironmentIsolator（環境隔離）
   
3. **模組職責明確化**：
   - 建立ITestHelper介面，明確定義測試輔助功能的標準
   - 分離Chrome API Mock的設定邏輯和執行邏輯
   - 建立TestDataProvider抽象層，分離資料生成和資料管理

4. **程式碼品質改善方向**：
   - 使用依賴注入模式改善Mock物件的管理
   - 建立統一的錯誤處理策略和異常恢復機制
   - 實作完整的測試資料生命週期管理

### 驗證與品質保證規劃階段

#### 測試通過策略：

**階段性目標和達成方法**：

**階段1: 基礎Mock系統修復** (目標: 69.3% → 80%)
- **修復Storage API測試失敗**：實作完整的chrome.storage.local/sync/managed API Mock
- **修復Runtime API測試失敗**：實作精確的chrome.runtime.sendMessage和onMessage Mock
- **修復基本錯誤處理**：確保chrome.runtime.lastError正確設定和清理
- **驗證方法**：執行npm test並確認Storage和Runtime相關測試通過率達到95%+

**階段2: 整合測試框架建立** (目標: 80% → 85%)
- **建立跨模組測試能力**：實作Background-Content-Popup三向通訊測試框架
- **實作測試隔離機制**：確保測試間無狀態污染和順序依賴
- **建立標準測試資料**：使用TestDataFactory統一所有測試的資料生成
- **驗證方法**：執行整合測試套件，確認跨模組通訊測試100%通過且可重複執行

**階段3: Service Worker環境完善** (目標: 85% → 90%)
- **實作Service Worker生命週期測試**：模擬安裝、啟動、休眠、喚醒事件
- **完善事件系統跨上下文測試**：確保EventBus在Service Worker環境正確運作
- **建立異常恢復測試**：測試各種異常情況下的系統恢復能力
- **驗證方法**：執行完整的生命週期測試，確認事件系統在各個階段都能正確初始化

#### 程式碼品質檢查：

**開發階段品質標準**：
```bash
# 每個實作步驟後執行的檢查
npm run lint          # 確保程式碼風格一致性
npm test -- --coverage # 確保測試覆蓋率不低於95%
npm run build         # 確保沒有建置錯誤
```

**程式碼審查檢查點**：
- **可讀性**：所有函數和變數名稱清楚表達其用途
- **可維護性**：避免過度複雜的邏輯，優先使用組合而非繼承
- **可測試性**：所有新增功能都有對應的單元測試
- **效能影響**：確保測試執行時間增長不超過20%

**架構品質驗證**：
- **依賴關係**：確保Mock系統不依賴實際的Chrome Extension環境
- **介面一致性**：所有測試輔助工具使用統一的介面設計
- **錯誤處理**：完整的異常處理和恢復機制
- **記憶體管理**：確保測試結束後正確清理所有資源

#### 邊界條件處理：

**Chrome API異常狀態處理**：
```javascript
// 處理Chrome API調用失敗的情況
try {
  await chrome.storage.local.set({ key: 'value' });
} catch (error) {
  if (chrome.runtime.lastError) {
    // 處理Chrome API特定錯誤
    handleChromeApiError(chrome.runtime.lastError);
  } else {
    // 處理其他異常
    handleGenericError(error);
  }
}
```

**測試環境資源限制處理**：
- **記憶體限制**：當檢測到記憶體使用過高時，自動清理測試資料快取
- **並發限制**：控制同時執行的整合測試數量，避免資源競爭
- **時間限制**：為長時間執行的測試設定合理的逾時機制

**Mock狀態一致性保證**：
```javascript
// 每個測試開始前的狀態驗證
beforeEach(() => {
  const inconsistencies = chromeMocks.validateMockConsistency();
  if (inconsistencies.length > 0) {
    throw new Error(`Mock state inconsistent: ${inconsistencies.join(', ')}`);
  }
});
```

#### 效能考量：

**效能基準設定**：
- **測試執行時間基準**：當前測試套件執行時間約3分鐘，增強後不得超過3分40秒
- **記憶體使用基準**：當前peak memory約250MB，增強後不得超過300MB
- **CI建置時間基準**：當前CI完整流程8分鐘，增強後不得超過10分鐘

**效能監控機制**：
```javascript
// 測試效能監控
const performanceMonitor = {
  startTime: 0,
  memoryBaseline: 0,
  
  startMonitoring() {
    this.startTime = performance.now();
    this.memoryBaseline = process.memoryUsage().heapUsed;
  },
  
  checkPerformance(testName) {
    const duration = performance.now() - this.startTime;
    const memoryUsed = process.memoryUsage().heapUsed - this.memoryBaseline;
    
    if (duration > 5000) { // 5秒逾時
      console.warn(`Test ${testName} took ${duration}ms, may need optimization`);
    }
    
    if (memoryUsed > 50 * 1024 * 1024) { // 50MB記憶體
      console.warn(`Test ${testName} used ${memoryUsed / 1024 / 1024}MB memory`);
    }
  }
};
```

**效能優化建議**：
- **延遲載入**：Mock物件和測試資料採用需要時才載入的策略
- **物件池**：重用常見的Mock物件和測試資料，避免重複建立
- **快取策略**：對於不變的測試資料建立快取，避免重複生成
- **並行優化**：在確保測試隔離的前提下，利用Jest的並行執行能力

---

## 📊 實作完成交接標準

### 主線程實作責任檢查點：
- [ ] **ChromeExtensionMocksEnhancedV2類別實作完成**，支援Storage、Runtime、Tabs API的完整Mock
- [ ] **IntegrationTestHelper實作完成**，提供跨模組測試的統一介面
- [ ] **TestDataFactory實作完成**，提供標準化的測試資料生成
- [ ] **測試隔離機制實作完成**，確保測試間無狀態污染
- [ ] **所有新增程式碼通過ESLint檢查**，符合專案程式碼風格標準
- [ ] **測試覆蓋率達到95%+**，包含新增模組的單元測試
- [ ] **測試套件通過率從69.3%提升至85%+**，達成階段性目標
- [ ] **效能指標符合預期**，測試執行時間增長<20%，記憶體使用增長<20%

### 交接給cinnamon-refactor-owl的準備：
- [ ] **識別需要Five Lines規則重構的具體方法**，包含詳細的拆分建議
- [ ] **記錄單一責任原則違反的模組**，提供重構優先順序建議
- [ ] **建立程式碇品質基準**，包含可讀性、可維護性、可測試性標準
- [ ] **準備重構前後的效能對比基準**，確保重構不影響測試執行效率
- [ ] **完整記錄技術債務清單**，包含高中低優先級的改善方向
- [ ] **建立重構驗證檢查點**，確保重構過程中測試通過率保持100%

**準備完成後，主線程可以開始按照這個規劃進行實際程式碼實作。**

## 📊 預期成果與成功指標

### 量化指標：

**測試品質提升**:
- 測試套件通過率: 69.3% → 85%+
- 整合測試穩定性: 新建立的整合測試100%通過
- Chrome API Mock覆蓋率: 達到核心功能100%覆蓋

**開發效率改善**:
- 測試失敗問題排查時間縮短50%
- 新功能測試編寫效率提升30%
- CI/CD反饋週期縮短至合理範圍

**程式碼品質**:
- 新增模組100%符合Five Lines規則
- 測試覆蓋率達到95%+
- 技術債務清零，無已知架構問題

### 質化成果：

**開發體驗改善**:
- 開發者能輕鬆使用統一的測試輔助模組
- 測試失敗時獲得清晰的錯誤訊息和修復建議
- 整合測試編寫變得簡單且可重現

**系統穩定性提升**:
- Chrome Extension功能在測試環境中的行為更接近生產環境
- 跨模組互動問題能在開發階段被及早發現
- 系統整體的可靠性和可維護性顯著提升

## 🎯 下一階段準備

**為重構設計師準備的資訊**:
- 識別需要Five Lines規則重構的模組
- 記錄程式碼品質改善的具體方向
- 準備效能基準和品質標準

**為Phase 3.4準備的基礎**:
- 建立完整的測試基礎設施
- 確保7個核心Use Cases的測試穩定性
- 為最終v1.0發布準備奠定堅實基礎

---

**工作日誌建立時間**: 2025-08-27  
**預計完成時間**: 2-3天  
**TDD階段**: Phase 1 (功能設計) 完成，準備移交給測試工程師  
**專案版本**: v0.9.45 (Phase 3.3)