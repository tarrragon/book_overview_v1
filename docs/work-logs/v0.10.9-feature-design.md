# v0.10.9 錯誤處理與回應標準化 Domain 功能設計

**開發版本**: v0.10.9  
**開發日期**: 2025-09-03  
**主要任務**: 錯誤處理與回應標準化 Domain 功能設計  
**工作狀態**: 🔄 進行中 - TDD Phase 1 功能設計階段  
**開發者**: Claude Code

## 🎯 工作目標與背景

### TDD Phase 1: 功能設計階段

根據 CLAUDE.md「🤝 TDD 協作開發流程」要求，執行完整的功能需求分析、功能規劃、邊界條件分析、API介面設計、驗收標準制定。

### 本期工作重點

設計「錯誤處理與回應標準化 Domain」的完整功能規格，解決當前系統的核心問題：
- 3760個 lint 問題（主要是 console.log 警告）
- 測試失敗（StorageAPIValidator 構造函數問題）
- 文字不統一導致測試不穩定
- 錯誤處理不規範，缺乏統一回應格式

## 📅 2025-09-03 開發記錄

### 1. 功能需求分析階段 ✅

#### 核心問題分析
透過分析架構文件 `docs/architecture/error-handling-standardization-plan.md` 和工作日誌 `v0.10.8-startup-check-testing.md`，識別以下核心問題：

**文字管理問題**：
- 大小寫不統一的 console.log 輸出
- 內容略有差異的錯誤訊息
- 分散在各個檔案中的硬編碼文字

**錯誤處理問題**：
- 使用文字判斷而非結構化異常
- 缺乏統一的錯誤代碼體系
- 錯誤處理邏輯分散且不一致

**回應格式問題**：
- success/failure 沒有一致的檢核模型
- 測試依賴字串比對導致不穩定
- 缺乏結構化的驗證結果格式

#### 使用者場景分析
**開發者使用場景**：
1. **錯誤處理場景**: 開發者需要拋出具有明確錯誤代碼和類型的結構化異常
2. **結果檢驗場景**: 開發者需要檢查操作結果的成功/失敗狀態和相關資料
3. **訊息輸出場景**: 開發者需要輸出統一格式的日誌和使用者訊息
4. **測試編寫場景**: 開發者需要使用結構化驗證而非字串比對

**系統整合場景**：
1. **模組間通訊**: 不同模組間需要使用統一的回應格式進行資料交換
2. **錯誤傳遞**: 異常需要在模組間正確傳遞並保持資訊完整性
3. **日誌聚合**: 需要結構化的日誌格式支援監控和分析

### 2. 功能規格設計階段 ✅

#### Domain 核心架構設計

**Domain Root**: 錯誤處理與回應標準化
- **高內聚**: 異常管理、回應格式、文字字典、枚舉系統在同一 Domain 內
- **低耦合**: 透過明確的 API 介面與其他系統互動
- **易測試**: 所有組件都支援單元測試和整合測試
- **易維護**: 文字集中管理，錯誤代碼統一定義

#### 輸入定義

**異常建立輸入**：
- `errorCode`: string - 標準化錯誤代碼 (必填)
- `errorType`: ErrorTypes - 錯誤類型枚舉 (必填)
- `details`: object - 結構化錯誤詳情 (選填)
- `context`: object - 錯誤發生的上下文資訊 (選填)

**回應建立輸入**：
- `success`: boolean - 操作成功狀態 (必填)
- `data`: any - 成功時的回應資料 (選填)
- `error`: BaseException - 失敗時的異常資訊 (選填)
- `metadata`: object - 附加的中繼資料 (選填)

**日誌輸出輸入**：
- `level`: LogLevel - 日誌等級 (必填)
- `messageKey`: string - 訊息字典鍵值 (必填)
- `params`: object - 訊息參數 (選填)
- `context`: object - 日誌上下文 (選填)

#### 輸出規格定義

**統一回應格式**：
```javascript
{
  success: boolean,
  data: object | null,
  error: {
    code: string,
    type: string, 
    message: string,
    details: object,
    timestamp: string,
    stackTrace: string
  } | null,
  metadata: {
    timestamp: string,
    requestId: string,
    version: string
  }
}
```

**結構化異常格式**：
```javascript
{
  errorCode: string,
  errorType: string,
  message: string,
  details: object,
  stackTrace: string,
  timestamp: string,
  context: object
}
```

**日誌輸出格式**：
```javascript
{
  level: string,
  message: string,
  timestamp: string,
  context: object,
  metadata: object
}
```

#### 正常流程設計

**異常處理流程**：
1. 系統檢測到錯誤情況
2. 使用對應的 Exception 類別建立結構化異常
3. 異常包含錯誤代碼、類型、訊息（從字典獲取）、詳情
4. 拋出異常或轉換為 OperationResult 回傳
5. 上層接收結構化異常進行處理

**成功回應流程**：
1. 操作執行成功
2. 使用 OperationResult.success() 建立成功回應
3. 包含操作結果資料和中繼資料
4. 回傳標準化格式供上層使用

**文字訊息流程**：
1. 系統需要輸出訊息
2. 使用訊息鍵值查詢字典
3. 進行參數插值替換
4. 輸出格式化後的訊息

#### 異常處理策略

**驗證異常處理**：
- 欄位驗證失敗 → ValidationException
- 包含具體的欄位名稱、期望值、實際值
- 使用 VALIDATION_ERROR 類型

**網路異常處理**：
- 連線失敗 → NetworkException  
- 包含請求 URL、超時時間、HTTP 狀態碼
- 使用 NETWORK_ERROR 類型

**儲存異常處理**：
- 檔案操作失敗 → StorageException
- 包含檔案路徑、操作類型、權限資訊
- 使用 STORAGE_ERROR 類型

**業務邏輯異常處理**：
- 業務規則違反 → BusinessException
- 包含業務規則描述、違反詳情
- 使用 BUSINESS_ERROR 類型

### 3. 邊界條件分析階段 ✅

#### 極端輸入情況

**空值處理**：
- `errorCode` 為 null/undefined → 使用預設錯誤代碼 "UNKNOWN_ERROR"
- `details` 為 null → 設定為空物件 {}
- `message` 為空字串 → 從字典獲取預設訊息

**超大值處理**：
- `details` 物件過大 → 限制序列化大小，超過則截斷並添加警告
- 堆疊追蹤過長 → 限制行數，保留關鍵資訊
- 訊息參數過多 → 限制參數數量，超過則忽略

**無效值處理**：
- 不存在的 `errorType` → 使用 SYSTEM_ERROR 作為預設值
- 無效的日誌等級 → 使用 INFO 等級
- 不存在的訊息鍵值 → 回傳鍵值本身並記錄警告

#### 系統限制分析

**記憶體限制**：
- 異常物件大小限制：最大 1MB
- 日誌緩衝區大小：最大 10MB
- 字典快取大小：最大 5MB

**效能限制**：
- 異常建立時間：< 1ms
- 字典查詢時間：< 0.1ms  
- 日誌輸出時間：< 0.5ms

**併發限制**：
- 支援多執行緒同時存取字典
- 日誌輸出支援非同步處理
- 異常物件必須是不可變的

#### 錯誤情況處理

**字典載入失敗**：
- 字典檔案不存在 → 使用內建預設訊息
- 字典格式錯誤 → 記錄錯誤並使用備用字典
- 字典更新失敗 → 繼續使用快取版本

**循環依賴處理**：
- 異常處理系統本身出錯 → 使用簡化版本處理
- 日誌系統異常 → 降級到 console 輸出
- 字典系統異常 → 使用硬編碼備用訊息

**系統資源不足**：
- 記憶體不足 → 清理快取並使用精簡模式
- 磁碟空間不足 → 停止檔案日誌，僅保留記憶體日誌
- CPU 資源不足 → 簡化日誌格式，取消非必要處理

### 4. API/介面設計階段 ✅

#### 核心類別設計

**BaseException 基礎異常類別**：
```javascript
class BaseException extends Error {
  constructor(errorCode, errorType, details = {}, context = {})
  
  // Getters
  get errorCode(): string
  get errorType(): string  
  get details(): object
  get context(): object
  get timestamp(): string
  
  // Methods
  toJSON(): object
  toString(): string
  static fromJSON(json): BaseException
}
```

**OperationResult 操作結果類別**：
```javascript
class OperationResult {
  constructor(success, data, error, metadata)
  
  // Static factory methods
  static success(data, metadata): OperationResult
  static failure(error, metadata): OperationResult
  
  // Getters
  get isSuccess(): boolean
  get isFailure(): boolean
  get data(): any
  get error(): BaseException | null
  
  // Methods
  toJSON(): object
  throwIfFailure(): void
}
```

**MessageDictionary 訊息字典類別**：
```javascript
class MessageDictionary {
  constructor(dictionaries)
  
  // Methods
  getMessage(key, params): string
  hasMessage(key): boolean
  loadDictionary(name, dictionary): void
  clearCache(): void
  
  // Static methods
  static getInstance(): MessageDictionary
}
```

**Logger 日誌管理類別**：
```javascript
class Logger {
  constructor(config)
  
  // Logging methods
  debug(messageKey, params, context): void
  info(messageKey, params, context): void  
  warn(messageKey, params, context): void
  error(messageKey, params, context): void
  fatal(messageKey, params, context): void
  
  // Configuration methods
  setLevel(level): void
  addAppender(appender): void
  
  // Static methods
  static getLogger(name): Logger
}
```

#### 模組匯出設計

**src/core/exceptions/index.js**：
```javascript
export { BaseException } from './BaseException.js'
export { ValidationException } from './ValidationException.js'
export { NetworkException } from './NetworkException.js'
export { StorageException } from './StorageException.js'
export { BusinessException } from './BusinessException.js'

// Factory function
export { createException } from './ExceptionFactory.js'
```

**src/core/models/index.js**：
```javascript
export { ApiResponse } from './ApiResponse.js'
export { OperationResult } from './OperationResult.js'
export { ValidationResult } from './ValidationResult.js'
export { ErrorDetails } from './ErrorDetails.js'

// Builder patterns
export { ResponseBuilder } from './ResponseBuilder.js'
```

**src/core/enums/index.js**：
```javascript
export { OperationStatus } from './OperationStatus.js'
export { ValidationStatus } from './ValidationStatus.js'
export { ErrorTypes } from './ErrorTypes.js'
export { MessageTypes } from './MessageTypes.js'
export { LogLevel } from './LogLevel.js'
```

**src/core/localization/index.js**：
```javascript
export { MessageDictionary } from './MessageDictionary.js'
export { ErrorMessages } from './dictionaries/ErrorMessages.js'
export { UserMessages } from './dictionaries/UserMessages.js'
export { StatusMessages } from './dictionaries/StatusMessages.js'
```

#### 與其他系統的整合介面

**測試框架整合**：
```javascript
// 測試輔助函數
export function expectOperationSuccess(result) {
  expect(result.isSuccess).toBe(true)
  expect(result.data).toBeDefined()
  expect(result.error).toBeNull()
}

export function expectOperationFailure(result, errorType, errorCode) {
  expect(result.isFailure).toBe(true)
  expect(result.error.errorType).toBe(errorType)
  expect(result.error.errorCode).toBe(errorCode)
}
```

**Chrome Extension API 整合**：
```javascript
// Storage API 包裝
export class ChromeStorageAdapter {
  async set(data) {
    try {
      await chrome.storage.local.set(data)
      return OperationResult.success()
    } catch (error) {
      const exception = new StorageException('CHROME_STORAGE_SET_FAILED', { data })
      return OperationResult.failure(exception)
    }
  }
}
```

### 5. 驗收標準制定階段 ✅

#### 功能正確性驗證

**異常管理系統驗證**：
- [ ] 所有異常類別都繼承自 BaseException
- [ ] 異常包含完整的錯誤代碼、類型、詳情、時間戳
- [ ] 異常可以正確序列化和反序列化
- [ ] 異常工廠可以根據類型建立對應的異常實例

**回應格式驗證**：
- [ ] 所有 OperationResult 都有明確的成功/失敗狀態
- [ ] 成功回應包含預期的資料結構
- [ ] 失敗回應包含結構化的錯誤資訊
- [ ] 回應格式符合 JSON Schema 規範

**文字字典驗證**：
- [ ] 所有硬編碼字串都移動到字典中
- [ ] 字典支援參數插值功能
- [ ] 字典載入和快取機制正常運作
- [ ] 不存在的鍵值有適當的預設處理

**日誌系統驗證**：
- [ ] 所有 console.log 都替換為結構化日誌
- [ ] 日誌包含適當的等級、時間戳、上下文
- [ ] 日誌可以輸出到多種目標 (控制台、檔案)
- [ ] 日誌格式支援監控系統分析

#### 效能要求

**回應時間要求**：
- 異常建立時間：< 1ms
- 字典查詢時間：< 0.1ms
- 日誌輸出時間：< 0.5ms
- 回應格式轉換：< 0.2ms

**記憶體使用要求**：
- 字典快取大小：< 5MB
- 單一異常物件：< 1KB
- 日誌緩衝區：< 10MB

**併發效能要求**：
- 支援 100+ 併發異常建立
- 支援 1000+ 併發日誌輸出
- 字典讀取無鎖定衝突

#### 使用者體驗標準

**開發者體驗**：
- API 使用簡單直觀，符合 JavaScript 慣例
- 錯誤訊息清楚明確，包含修復建議
- 文件完整，包含使用範例和最佳實踐
- IDE 支援良好，有完整的型別定義

**測試體驗**：
- 測試不依賴字串比對，使用結構化驗證
- 測試失敗時有清楚的錯誤訊息
- 支援測試資料的輕鬆建立和比對
- 測試運行穩定，不受文字變更影響

**維護體驗**：
- 文字修改只需要更新字典檔案
- 新增異常類型有標準化的流程
- 系統監控可以快速定位問題
- 日誌分析支援問題診斷和效能優化

---

## 📋 交接給 sage-test-architect 的檢查點

### 設計完整性確認 ✅

- [x] **功能需求清楚且具體**: 已識別核心問題並定義具體解決方案
- [x] **API介面定義完整**: 包含完整的類別設計、方法簽名、參數定義
- [x] **邊界條件全面識別**: 涵蓋空值、超大值、無效值、系統限制、錯誤情況
- [x] **驗收標準明確可驗證**: 建立功能正確性、效能要求、使用者體驗的具體標準

### 設計文件交付物 ✅

- [x] **Domain 概覽與職責**: 錯誤處理與回應標準化，包含 4 個子系統
- [x] **核心類別設計**: BaseException, OperationResult, MessageDictionary, Logger
- [x] **模組關係圖**: 清楚的匯出結構和整合介面
- [x] **使用範例規劃**: 涵蓋異常處理、回應格式、日誌輸出的具體使用方式
- [x] **測試策略定義**: 結構化驗證替代字串比對，完整的測試輔助函數

### 技術規格完整性 ✅

- [x] **輸入輸出規格**: 完整定義所有 API 的參數和回傳值
- [x] **錯誤處理策略**: 4 種異常類型的處理方式和轉換規則
- [x] **效能要求**: 具體的時間和記憶體要求
- [x] **整合方案**: 與測試框架、Chrome Extension API 的整合介面

---

## 🎯 下一階段：sage-test-architect TDD Phase 2

### 移交資訊摘要

**Domain 名稱**: 錯誤處理與回應標準化 Domain  
**核心目標**: 解決 3760 個 lint 問題、測試失敗、文字不統一問題  
**技術架構**: 4 個子系統 (exceptions, models, enums, localization)  
**設計複雜度**: 高 - 涉及系統性重構和多模組整合  
**預期效益**: 測試通過率達 100%、lint 問題減少 90%、維護成本大幅降低

### 關鍵設計決策

1. **統一異常體系**: 使用 BaseException 為基礎的結構化異常系統
2. **標準回應格式**: OperationResult 模式統一所有操作結果
3. **集中文字管理**: MessageDictionary 系統管理所有使用者可見文字
4. **結構化日誌**: 替換所有 console.log 為分級結構化日誌

**設計文件已完成，準備進入 TDD Phase 2 測試設計階段。**

---

*建立日期: 2025-09-03*  
*Phase 1 完成時間: 2025-09-03*  
*預計 Phase 2 開始: 立即*