# v0.9.33: UC-05跨設備同步工作流程測試 - TDD Phase 1 功能設計規劃

**版本**: v0.9.33  
**日期**: 2025-08-24  
**階段**: TDD Phase 1 - 功能設計師  
**負責**: lavender-interface-designer  
**目標**: 建立 UC-05 跨設備同步功能的完整測試設計規劃

## 🎯 TDD Phase 1: 功能設計規劃

### 📋 專案背景理解

**目前專案狀況**:
- Chrome Extension (Manifest V3) 專案，採用事件驅動架構
- v0.9.26 已移除複雜的自動同步機制，改為簡單的手動匯出/匯入JSON檔案
- 現有架構：EventBus、Chrome Storage (local/sync)、書籍資料管理、錯誤處理系統
- 測試覆蓋率目標：從52%提升至85%，UC-04(資料匯入)和UC-06(Overview頁面)已達成90%+

**UC-05 目前實作狀況**:
- 跨設備同步透過「匯出JSON → 雲端硬碟 → 其他設備匯入」流程實現
- 核心依賴：UC-03(資料匯出)、UC-04(資料匯入)功能
- 測試優先級：中等優先級（功能性已實現，但缺乏端到端測試驗證）

## 📚 功能需求分析

### UC-05 跨設備同步要解決什麼具體問題？

**核心問題識別**:
1. **多設備資料一致性**: 使用者在多個設備（辦公室電腦、家用電腦、筆記型電腦）上需要存取相同的書籍資料
2. **資料遷移可靠性**: 使用者更換設備或重新安裝 Extension 時需要恢復完整書籍資料
3. **同步流程驗證**: 確保手動同步流程的每個步驟都能正確執行，無資料遺失
4. **衝突處理機制**: 當兩個設備都有新增書籍時，如何正確合併資料

**問題複雜度分析**:
- **技術層面**: 依賴現有的匯出/匯入功能，主要是流程整合和驗證
- **使用者體驗**: 手動同步流程需要清楚的指引和錯誤處理
- **資料完整性**: 跨設備傳輸過程中的資料一致性保證

### 使用者的具體跨設備使用場景

**Primary Actor**: 書籍收集者 - 多設備使用者

**典型使用場景**:

**場景 A: 工作與家用電腦同步**
- 使用者在辦公室電腦新增了5本新書籍
- 下班回家後希望在家用電腦上也能看到這些書籍
- 透過 Google Drive 或 Dropbox 傳輸JSON檔案
- 在家用電腦上匯入，選擇「合併資料」模式

**場景 B: 設備更換或重新安裝**
- 使用者購買新電腦或重新安裝Chrome
- 需要從舊設備匯出完整書庫資料
- 在新設備上匯入，完全恢復之前的資料狀態
- 驗證所有書籍資料、進度資訊都正確遷移

**場景 C: 定期備份與同步**
- 使用者建立每週同步習慣
- 週日晚上從主要設備匯出資料
- 週一早上在其他設備匯入最新資料
- 需要處理可能的資料衝突（兩邊都有新增書籍）

**使用頻率分析**:
- 初次同步：使用者安裝Extension後的首次設備間資料傳輸
- 定期同步：每週1-2次的例行性資料同步
- 應急同步：設備故障或資料遺失時的緊急恢復

### 同步功能的核心價值和期望效果

**核心價值**:
1. **資料持久性**: 確保使用者的書籍資料不會因為設備故障而遺失
2. **跨設備一致性**: 在任何設備上都能存取到最新的完整書庫
3. **使用連續性**: 在不同設備間無縫續用Extension功能
4. **資料控制權**: 使用者完全掌控自己的資料，透過雲端硬碟自主管理

**期望效果**:
- **100%資料完整性**: 同步過程中零資料遺失
- **高效率同步**: 整個同步流程在5分鐘內完成
- **錯誤透明度**: 同步過程中的任何問題都有清楚說明和解決建議
- **使用簡易性**: 非技術使用者也能輕鬆完成同步操作

## 🔧 功能規格設計

### 同步功能的輸入是什麼？

**觸發條件**:
1. **使用者主動觸發**: 使用者點擊匯出按鈕開始同步流程
2. **設備環境檢查**: 確認Chrome Storage可用性，檢查現有資料狀態
3. **雲端硬碟可用性**: 使用者確認可存取雲端硬碟（Google Drive、Dropbox等）
4. **目標設備準備**: 目標設備已安裝Extension，可存取同一雲端硬碟

**資料來源**:
- **Chrome Storage Local**: 使用者在設備上累積的完整書籍資料
- **匯入檔案**: 從其他設備或備份來源的JSON格式書籍資料
- **使用者設定**: 同步模式選擇（覆蓋 vs 合併）、雲端硬碟路徑等

**環境參數**:
- **設備識別**: 透過Chrome Extension ID和時間戳識別資料來源
- **網路狀態**: 確認網路連接可用於雲端硬碟存取
- **儲存空間**: 檢查本地和雲端硬碟的可用空間

### 同步功能的輸出是什麼？

**同步結果資訊**:
```javascript
{
  success: true|false,
  operation: 'export'|'import'|'sync_complete',
  sourceDevice: 'device_identifier',
  targetDevice: 'device_identifier', 
  bookCount: {
    before: 150,
    after: 180,
    added: 30,
    updated: 5,
    duplicatesSkipped: 3
  },
  syncTimestamp: '2025-08-24T10:30:00.000Z',
  cloudPath: 'Google Drive/Readmoo Backups/readmoo-books-2025-08-24.json',
  dataIntegrity: {
    checksum: 'sha256_hash',
    verified: true
  }
}
```

**狀態反饋**:
- **進度指示**: 匯出進度、上傳進度、下載進度、匯入進度
- **成功確認**: 「已成功匯出150本書籍資料到雲端硬碟」
- **統計資訊**: 「合併後共180本書籍，新增30本，更新5本書籍進度」
- **檔案資訊**: 檔案大小、儲存位置、建立時間

**副作用**:
- **本地儲存更新**: Chrome Storage中的書籍資料被更新
- **檔案系統變更**: 雲端硬碟中建立或更新JSON備份檔案
- **統計資料更新**: Extension的使用統計和同步歷史記錄
- **UI狀態更新**: Overview頁面重新渲染以顯示最新資料

### 正常同步流程的詳細步驟

**階段1: 同步準備 (Pre-sync)**
1. **環境檢查**: 驗證Chrome Storage API可用性
2. **資料狀態檢查**: 計算目前書籍總數、最後更新時間
3. **雲端硬碟確認**: 使用者確認可存取雲端硬碟服務
4. **同步模式選擇**: 提供「完全備份」vs「增量同步」選項

**階段2: 資料匯出 (Export)**
1. **資料準備**: 從Chrome Storage讀取所有書籍資料
2. **資料驗證**: 檢查資料完整性，確認所有必要欄位存在
3. **檔案生成**: 生成標準JSON格式，包含metadata和checksum
4. **檔案下載**: 觸發瀏覽器下載，檔名包含時間戳
5. **匯出確認**: 顯示匯出統計資訊和檔案儲存建議

**階段3: 雲端傳輸 (Cloud Transfer)**
1. **檔案上傳**: 使用者手動將檔案上傳到雲端硬碟
2. **路徑管理**: 建議使用標準化的資料夾結構
3. **版本管理**: 保留多個備份版本，避免覆蓋唯一備份
4. **可用性驗證**: 確認檔案在雲端硬碟中可正常存取

**階段4: 資料匯入 (Import)**
1. **檔案下載**: 從雲端硬碟下載最新備份檔案
2. **檔案驗證**: 驗證JSON格式、checksum、資料結構
3. **衝突檢測**: 比較匯入資料與現有資料，識別衝突
4. **合併策略**: 根據使用者選擇執行覆蓋或智慧合併
5. **資料寫入**: 更新Chrome Storage，觸發UI重新整理

**階段5: 同步確認 (Post-sync Verification)**
1. **資料完整性驗證**: 確認匯入後的資料與匯出前一致
2. **功能測試**: 快速驗證搜尋、篩選等核心功能正常
3. **使用者確認**: 顯示同步結果摘要，讓使用者確認成功
4. **歷史記錄**: 在Extension中記錄同步操作歷史

### 異常情況的處理方式

**網路相關異常**:
- **雲端硬碟不可存取**: 提供離線備份選項，建議使用USB隨身碟
- **檔案下載失敗**: 提供重試機制，顯示具體錯誤原因
- **上傳超時**: 建議檢查檔案大小，提供壓縮選項

**檔案相關異常**:
- **JSON格式損壞**: 詳細說明錯誤位置，提供修復建議
- **檔案版本不符**: 檢查檔案是否由相同版本Extension產生
- **checksum驗證失敗**: 警告資料可能損壞，建議使用其他備份

**資料相關異常**:
- **匯入資料與現有資料衝突**: 提供詳細比較介面，讓使用者選擇保留哪些資料
- **儲存空間不足**: 建議清理舊資料或升級Chrome儲存配額
- **重複資料處理**: 智慧去重，保留最新資料，通知使用者處理結果

**使用者操作異常**:
- **操作中途中斷**: 提供續傳或重新開始選項
- **錯誤的檔案選擇**: 詳細說明正確的檔案格式和命名規則
- **權限問題**: 指導使用者檢查Chrome Extension權限設定

## 🎯 邊界條件分析

### 極端輸入情況

**大量資料處理**:
- **測試場景**: 10,000本書籍的同步處理
- **預期挑戰**: JSON檔案大小達到10-50MB，匯出/匯入時間可能超過30秒
- **處理策略**: 實作進度條、分批處理、記憶體優化
- **驗證標準**: 1萬本書籍同步時間<3分鐘，記憶體使用<100MB

**空資料處理**:
- **測試場景**: 新設備（無書籍資料）匯入現有備份
- **預期行為**: 正確處理空booksData陣列，避免覆蓋匯入資料
- **驗證點**: 空設備匯入100本書籍後，資料完整性100%

**特殊字元和編碼**:
- **測試場景**: 書名包含emoji、特殊Unicode字元、多語言內容
- **檔案編碼**: 確保UTF-8編碼正確處理，避免字元遺失
- **驗證方法**: 包含各國語言書籍的同步測試

**網路極端情況**:
- **超大檔案**: 測試100MB+ JSON檔案的處理能力
- **超慢網路**: 模擬2G網路下的雲端硬碟存取
- **間歇性連線**: 處理上傳/下載過程中的網路中斷

### 系統限制和約束條件

**Chrome Extension API限制**:
- **chrome.storage.local**: 最大容量通常為10MB，可能因設備而異
- **chrome.storage.sync**: 同步儲存限制為100KB，不適合大量書籍資料
- **檔案存取限制**: Chrome擴充功能無法直接存取本地檔案系統

**瀏覽器限制**:
- **記憶體限制**: Chrome標籤頁記憶體限制可能影響大檔案處理
- **下載限制**: 瀏覽器下載資料夾權限和空間限制
- **JavaScript執行時間**: 長時間運行的同步操作可能觸發「無回應」警告

**雲端硬碟服務限制**:
- **Google Drive**: 免費15GB空間，單檔上限750GB
- **Dropbox**: 免費2GB空間，API rate limiting
- **OneDrive**: 免費5GB空間，不同地區可用性差異

**使用者設備限制**:
- **儲存空間**: 使用者設備可能空間不足
- **網路頻寬**: 家用網路上傳速度通常較慢
- **操作系統差異**: Windows/Mac/Linux對檔案處理的差異

### 錯誤情況和例外狀況

**資料損壞場景**:
- **JSON結構破損**: 檔案傳輸過程中部分內容遺失
- **編碼問題**: 不同系統間字元編碼轉換錯誤
- **版本不相容**: 舊版本Extension產生的備份檔案格式差異

**同步衝突場景**:
- **同一本書不同進度**: A設備進度50%，B設備進度80%
- **相同ID不同內容**: 書籍ID相同但標題或其他資訊不同
- **時間戳問題**: 設備時間不同步導致「最新」資料判斷錯誤

**權限和安全問題**:
- **雲端硬碟權限**: 使用者雲端硬碟帳號權限不足
- **檔案存取權限**: 其他使用者無法存取共享的備份檔案
- **資料隱私**: 備份檔案意外分享給其他人的風險

**操作流程中斷**:
- **瀏覽器崩潰**: 同步過程中Chrome意外關閉
- **設備關機**: 匯出/匯入過程中設備意外關機
- **使用者中途取消**: 長時間操作中使用者失去耐心

## 🔌 API/介面設計

### 同步相關的函數簽名和API接口定義

**核心同步服務介面**:
```javascript
/**
 * 跨設備同步服務
 * 整合匯出、匯入功能，提供完整的設備間資料同步解決方案
 */
class CrossDeviceSyncService {
  /**
   * 執行完整同步流程
   * @param {SyncConfig} config - 同步設定
   * @returns {Promise<SyncResult>} 同步結果
   */
  async executeSync(config)

  /**
   * 準備同步匯出
   * @param {ExportOptions} options - 匯出選項
   * @returns {Promise<ExportResult>} 匯出準備結果
   */
  async prepareExport(options = {})

  /**
   * 驗證匯入檔案
   * @param {File} file - 要驗證的檔案
   * @returns {Promise<ValidationResult>} 驗證結果
   */
  async validateImportFile(file)

  /**
   * 執行智慧合併
   * @param {Array} currentData - 目前資料
   * @param {Array} importData - 匯入資料
   * @param {MergeStrategy} strategy - 合併策略
   * @returns {Promise<MergeResult>} 合併結果
   */
  async smartMerge(currentData, importData, strategy)

  /**
   * 檢查同步相容性
   * @param {Object} importMetadata - 匯入檔案metadata
   * @returns {Promise<CompatibilityCheck>} 相容性檢查結果
   */
  async checkCompatibility(importMetadata)
}
```

**同步配置介面**:
```javascript
/**
 * 同步配置物件
 */
interface SyncConfig {
  mode: 'export' | 'import' | 'full_sync',
  strategy: 'overwrite' | 'merge' | 'smart_merge',
  includeMetadata: boolean,
  compressionEnabled: boolean,
  validationLevel: 'basic' | 'strict' | 'comprehensive',
  cloudProvider: 'manual' | 'google_drive' | 'dropbox',
  deviceIdentifier?: string,
  backupRetention: number // 保留備份檔案數量
}

/**
 * 同步結果物件
 */
interface SyncResult {
  success: boolean,
  operation: string,
  duration: number,
  sourceDevice: string,
  targetDevice: string,
  dataChanges: {
    added: number,
    updated: number,
    removed: number,
    duplicatesSkipped: number
  },
  fileInfo: {
    path: string,
    size: number,
    checksum: string,
    timestamp: string
  },
  errors?: Array<SyncError>,
  warnings?: Array<string>
}
```

**衝突處理介面**:
```javascript
/**
 * 資料衝突檢測和處理
 */
class SyncConflictResolver {
  /**
   * 檢測資料衝突
   * @param {Array} localData - 本地資料
   * @param {Array} importData - 匯入資料
   * @returns {Promise<ConflictReport>} 衝突報告
   */
  async detectConflicts(localData, importData)

  /**
   * 解決衝突
   * @param {ConflictReport} conflicts - 衝突報告
   * @param {ConflictResolution[]} resolutions - 解決方案
   * @returns {Promise<ResolvedData>} 解決後的資料
   */
  async resolveConflicts(conflicts, resolutions)

  /**
   * 生成衝突摘要
   * @param {ConflictReport} conflicts - 衝突報告
   * @returns {ConflictSummary} 衝突摘要
   */
  generateConflictSummary(conflicts)
}

/**
 * 衝突項目定義
 */
interface ConflictItem {
  bookId: string,
  conflictType: 'progress_diff' | 'metadata_diff' | 'existence_diff',
  localValue: any,
  importValue: any,
  confidence: number, // 0-1，自動解決的信心度
  recommendedAction: 'keep_local' | 'use_import' | 'manual_review'
}
```

### 資料結構和同步狀態類型定義

**同步狀態追蹤**:
```javascript
/**
 * 同步狀態管理
 */
class SyncStateManager {
  constructor() {
    this.currentState = 'idle'
    this.operations = new Map()
    this.history = []
  }

  /**
   * 同步狀態列舉
   */
  static STATES = {
    IDLE: 'idle',
    PREPARING: 'preparing',
    EXPORTING: 'exporting',
    UPLOADING: 'uploading',
    DOWNLOADING: 'downloading',
    IMPORTING: 'importing',
    MERGING: 'merging',
    VERIFYING: 'verifying',
    COMPLETED: 'completed',
    ERROR: 'error'
  }

  /**
   * 操作類型定義
   */
  static OPERATIONS = {
    FULL_EXPORT: 'full_export',
    INCREMENTAL_EXPORT: 'incremental_export',
    VALIDATE_IMPORT: 'validate_import',
    MERGE_DATA: 'merge_data',
    RESOLVE_CONFLICTS: 'resolve_conflicts'
  }
}

/**
 * 同步歷史記錄
 */
interface SyncHistoryEntry {
  id: string,
  timestamp: string,
  operation: string,
  sourceDevice: string,
  targetDevice?: string,
  success: boolean,
  duration: number,
  dataChanges: DataChangesSummary,
  errors?: string[],
  fileInfo: {
    name: string,
    size: number,
    checksum: string
  }
}
```

**資料完整性驗證**:
```javascript
/**
 * 資料完整性驗證器
 */
class DataIntegrityValidator {
  /**
   * 驗證書籍資料結構
   * @param {Array} bookData - 書籍資料陣列
   * @returns {ValidationResult} 驗證結果
   */
  validateBookDataStructure(bookData)

  /**
   * 計算資料檢查碼
   * @param {Array} bookData - 書籍資料
   * @returns {Promise<string>} SHA-256 檢查碼
   */
  async calculateChecksum(bookData)

  /**
   * 驗證資料完整性
   * @param {Array} bookData - 書籍資料
   * @param {string} expectedChecksum - 預期檢查碼
   * @returns {Promise<boolean>} 完整性驗證結果
   */
  async verifyIntegrity(bookData, expectedChecksum)

  /**
   * 檢查必要欄位
   * @param {Object} book - 書籍物件
   * @returns {FieldValidationResult} 欄位驗證結果
   */
  validateRequiredFields(book)
}
```

### 與現有模組的整合方式和介面契約

**與EventBus整合**:
```javascript
/**
 * 同步相關事件定義
 */
const SYNC_EVENTS = {
  // 同步流程事件
  SYNC_STARTED: 'SYNC.PROCESS.STARTED',
  SYNC_PROGRESS: 'SYNC.PROCESS.PROGRESS',
  SYNC_COMPLETED: 'SYNC.PROCESS.COMPLETED',
  SYNC_FAILED: 'SYNC.PROCESS.FAILED',
  
  // 資料變更事件
  DATA_EXPORTED: 'SYNC.DATA.EXPORTED',
  DATA_IMPORTED: 'SYNC.DATA.IMPORTED',
  DATA_MERGED: 'SYNC.DATA.MERGED',
  
  // 衝突處理事件
  CONFLICT_DETECTED: 'SYNC.CONFLICT.DETECTED',
  CONFLICT_RESOLVED: 'SYNC.CONFLICT.RESOLVED',
  
  // 錯誤事件
  VALIDATION_FAILED: 'SYNC.VALIDATION.FAILED',
  FILE_CORRUPTION: 'SYNC.FILE.CORRUPTION',
  NETWORK_ERROR: 'SYNC.NETWORK.ERROR'
}

/**
 * 事件資料結構
 */
interface SyncProgressEvent {
  operation: string,
  progress: number, // 0-100
  currentStep: string,
  totalSteps: number,
  estimatedTimeRemaining?: number
}
```

**與Chrome Storage整合**:
```javascript
/**
 * 同步專用儲存管理
 */
class SyncStorageManager {
  constructor(chromeStorageAdapter) {
    this.storage = chromeStorageAdapter
    this.syncPrefix = 'sync_'
  }

  /**
   * 儲存同步metadata
   * @param {SyncMetadata} metadata - 同步metadata
   * @returns {Promise<void>}
   */
  async saveSyncMetadata(metadata)

  /**
   * 讀取同步歷史
   * @param {number} limit - 限制筆數
   * @returns {Promise<SyncHistoryEntry[]>} 同步歷史
   */
  async loadSyncHistory(limit = 10)

  /**
   * 清理過期的同步資料
   * @param {number} retentionDays - 保留天數
   * @returns {Promise<CleanupResult>} 清理結果
   */
  async cleanupOldSyncData(retentionDays = 30)
}
```

**與錯誤處理系統整合**:
```javascript
/**
 * 同步錯誤處理器
 */
class SyncErrorHandler extends SystemErrorHandler {
  /**
   * 處理同步相關錯誤
   * @param {Error} error - 錯誤物件
   * @param {SyncContext} context - 同步上下文
   * @returns {Promise<ErrorHandlingResult>}
   */
  async handleSyncError(error, context)

  /**
   * 錯誤恢復策略
   * @param {SyncError} error - 同步錯誤
   * @returns {RecoveryAction[]} 恢復動作清單
   */
  getRecoveryStrategies(error)

  /**
   * 錯誤分類
   */
  static ERROR_CATEGORIES = {
    FILE_IO: 'file_io_error',
    DATA_CORRUPTION: 'data_corruption',
    NETWORK: 'network_error',
    PERMISSION: 'permission_error',
    COMPATIBILITY: 'compatibility_error',
    USER_OPERATION: 'user_operation_error'
  }
}
```

## ✅ 驗收標準

### 同步功能正確性的驗證方法

**端到端同步驗證**:
```javascript
/**
 * 完整同步流程測試標準
 */
const SYNC_VERIFICATION_STANDARDS = {
  // 資料完整性測試
  dataIntegrity: {
    test: '100本書籍完整同步',
    standard: '資料完整性100%，無遺失或損壞',
    verification: 'checksum驗證 + 逐筆資料比對'
  },
  
  // 衝突處理測試
  conflictResolution: {
    test: '同一書籍不同進度衝突',
    standard: '智慧合併保留最新進度，使用者確認',
    verification: '衝突檢測準確率100%，解決方案正確'
  },
  
  // 效能測試
  performance: {
    test: '1000本書籍同步時間',
    standard: '完整同步流程<3分鐘',
    verification: '實際測量匯出+上傳+下載+匯入總時間'
  },
  
  // 錯誤恢復測試
  errorRecovery: {
    test: '網路中斷後恢復同步',
    standard: '自動重試3次，失敗後提供手動重試',
    verification: '模擬網路中斷，驗證恢復機制'
  }
}
```

**自動化驗證測試套件**:
```javascript
/**
 * 同步功能驗證測試套件設計
 */
describe('UC-05 跨設備同步工作流程驗證', () => {
  describe('🔄 完整同步流程測試', () => {
    test('應該正確執行設備A到設備B的完整同步')
    test('應該在合併模式下正確處理資料衝突')
    test('應該在覆蓋模式下完全替換目標設備資料')
  })

  describe('📊 資料完整性驗證', () => {
    test('應該在同步前後保持資料完整性')
    test('應該正確處理特殊字元和多語言內容')
    test('應該驗證checksum確保資料未損壞')
  })

  describe('⚡ 效能和擴展性測試', () => {
    test('應該在3分鐘內完成1000本書籍同步')
    test('應該正確處理10MB+大型JSON檔案')
    test('應該在低記憶體環境下穩定運行')
  })

  describe('🚨 錯誤處理和恢復測試', () => {
    test('應該正確處理網路中斷情況')
    test('應該檢測並報告檔案損壞')
    test('應該提供清楚的錯誤訊息和解決建議')
  })
})
```

### 跨設備一致性的測試標準

**設備環境測試矩陣**:
```javascript
/**
 * 多設備環境測試標準
 */
const DEVICE_COMPATIBILITY_MATRIX = {
  operatingSystems: ['Windows 10/11', 'macOS 12+', 'Ubuntu 20.04+'],
  chromeVersions: ['Chrome 120+', 'Chrome 121+', 'Chrome Latest'],
  networkConditions: ['寬頻', '4G行動網路', '慢速網路(2G模擬)'],
  storageScenarios: ['空白設備', '部分資料設備', '完整資料設備']
}

/**
 * 一致性驗證檢查點
 */
const CONSISTENCY_CHECKPOINTS = {
  bookCount: '書籍總數必須完全一致',
  bookIds: '所有書籍ID必須存在且唯一',
  bookMetadata: '書名、封面、進度等metadata必須一致',
  timestamps: 'extractedAt時間戳必須正確傳遞',
  stableIds: '穩定ID生成算法結果必須一致'
}
```

**跨設備測試自動化**:
```javascript
/**
 * 多設備同步一致性測試
 */
class CrossDeviceConsistencyTester {
  /**
   * 建立測試環境
   * @param {DeviceConfig[]} devices - 設備配置陣列
   */
  async setupTestEnvironment(devices)

  /**
   * 執行同步一致性測試
   * @param {SyncTestScenario} scenario - 測試場景
   * @returns {Promise<ConsistencyTestResult>}
   */
  async runConsistencyTest(scenario)

  /**
   * 驗證資料一致性
   * @param {Object[]} deviceDataSets - 各設備資料集
   * @returns {ConsistencyReport} 一致性報告
   */
  verifyDataConsistency(deviceDataSets)
}
```

### 效能要求和品質標準

**效能基準測試**:
```javascript
/**
 * 同步效能測試基準
 */
const PERFORMANCE_BENCHMARKS = {
  // 小型資料集 (1-100本書籍)
  small: {
    exportTime: '<5秒',
    importTime: '<10秒',
    fileSize: '<1MB',
    memoryUsage: '<50MB'
  },
  
  // 中型資料集 (100-500本書籍)  
  medium: {
    exportTime: '<15秒',
    importTime: '<30秒', 
    fileSize: '<5MB',
    memoryUsage: '<100MB'
  },
  
  // 大型資料集 (500-1000本書籍)
  large: {
    exportTime: '<30秒',
    importTime: '<60秒',
    fileSize: '<10MB', 
    memoryUsage: '<150MB'
  },
  
  // 極大資料集 (1000+本書籍)
  extraLarge: {
    exportTime: '<60秒',
    importTime: '<120秒',
    fileSize: '<20MB',
    memoryUsage: '<200MB'
  }
}

/**
 * 品質標準定義
 */
const QUALITY_STANDARDS = {
  reliability: {
    successRate: '>99%', // 同步成功率
    dataIntegrity: '100%', // 資料完整性
    errorRecovery: '>95%' // 錯誤恢復成功率
  },
  
  usability: {
    setupTime: '<2分鐘', // 首次設定時間
    syncTime: '<5分鐘', // 常規同步時間
    userErrors: '<5%' // 使用者操作錯誤率
  },
  
  maintainability: {
    testCoverage: '>90%', // 測試覆蓋率
    codeComplexity: '<10', // 循環複雜度
    documentation: '100%' // 文件完整性
  }
}
```

### 使用者體驗的期望標準

**UX測試驗收標準**:
```javascript
/**
 * 使用者體驗驗收標準
 */
const UX_ACCEPTANCE_CRITERIA = {
  // 直觀性測試
  intuitive: {
    test: '新使用者首次同步成功率',
    standard: '>80%新使用者無需額外指導完成同步',
    measurement: '實際使用者測試 + 任務完成時間'
  },
  
  // 資訊透明度
  transparency: {
    test: '同步進度和結果資訊清晰度',
    standard: '100%關鍵步驟有進度指示和結果確認',
    measurement: '使用者滿意度調查 + 錯誤理解率'
  },
  
  // 錯誤處理友善度
  errorHandling: {
    test: '錯誤訊息理解和解決',
    standard: '>90%使用者能理解錯誤並採取正確行動',
    measurement: '錯誤情境測試 + 解決成功率'
  },
  
  // 操作效率
  efficiency: {
    test: '熟練使用者同步操作時間',
    standard: '<30秒完成常規同步操作',
    measurement: '任務時間測量 + 點擊次數統計'
  }
}

/**
 * UI/UX設計要求
 */
const UI_UX_REQUIREMENTS = {
  // 進度指示
  progressIndication: {
    requirement: '所有超過5秒的操作必須有進度指示',
    implementation: '進度條 + 步驟說明 + 預估時間',
    validation: '使用者無感到「卡住」或「無回應」'
  },
  
  // 錯誤訊息
  errorMessages: {
    requirement: '錯誤訊息必須具體且提供解決方案',
    implementation: '錯誤分類 + 具體描述 + 建議行動',
    validation: '使用者能獨立解決>80%常見錯誤'
  },
  
  // 確認和取消
  confirmation: {
    requirement: '重要操作必須有確認機制',
    implementation: '覆蓋模式警告 + 操作預覽 + 取消選項',
    validation: '意外資料遺失事件 = 0'
  }
}
```

## 🔍 TDD Phase 1 完成總結

### 功能設計完整度檢查

**✅ 完成的設計要素**:
- [x] **功能需求分析**: 完整識別跨設備同步的核心問題和使用場景
- [x] **功能規格設計**: 詳細定義輸入輸出、正常流程和異常處理
- [x] **邊界條件分析**: 全面分析極端情況、系統限制和錯誤場景
- [x] **API介面設計**: 完整設計同步服務、衝突處理、狀態管理介面
- [x] **驗收標準制定**: 建立功能正確性、效能要求、使用者體驗標準

**🎯 設計核心特色**:
1. **實務導向**: 基於現有架構(JSON匯出/匯入)設計，避免over-engineering
2. **使用者中心**: 重視手動同步流程的使用體驗和錯誤處理
3. **品質保證**: 建立完整的測試驗收標準和自動化驗證機制
4. **可測試性**: 所有設計都考慮測試實作的可行性和覆蓋率要求

### 交接給 TDD Phase 2 的準備狀況

**📋 為 sage-test-architect 提供的設計資產**:

**核心測試場景識別** (共5大類，約35個測試案例):
1. **完整同步流程測試** (8個測試案例)
   - 設備A到設備B完整同步
   - 合併模式資料衝突處理
   - 覆蓋模式完全替換
   - 新設備首次同步

2. **資料完整性驗證測試** (10個測試案例)
   - 大量資料(1000本書籍)同步
   - 特殊字元和多語言處理
   - Checksum驗證機制
   - JSON格式損壞檢測

3. **效能和擴展性測試** (8個測試案例)
   - 同步時間基準測試
   - 記憶體使用量監控
   - 大檔案處理能力
   - 網路條件影響測試

4. **錯誤處理和恢復測試** (12個測試案例)
   - 網路中斷恢復
   - 檔案損壞檢測
   - 權限問題處理
   - 使用者操作中斷

5. **跨設備一致性測試** (7個測試案例)
   - 多作業系統相容性
   - Chrome版本相容性
   - 儲存配額限制處理
   - 時區差異處理

**測試架構設計**:
- **Mock策略**: Chrome Storage API、檔案系統、網路請求
- **測試資料**: 標準化書籍資料集、錯誤場景資料、效能測試資料集
- **驗證標準**: 自動化驗收標準、效能基準測試、使用者體驗指標

**預期測試覆蓋率目標**: UC-05 從當前0%提升至90%+

### 下一階段工作重點建議

**🧪 TDD Phase 2 (測試工程師) 關鍵任務**:
1. **優先實作核心流程測試**: 完整同步流程的happy path測試
2. **重點關注錯誤處理**: 跨設備同步最容易出錯的網路和檔案處理部分
3. **效能測試設計**: 建立可重複的效能基準測試機制
4. **Mock環境完整性**: 確保Chrome Extension API模擬的準確性

**💻 TDD Phase 3 (實作規劃師) 預期挑戰**:
1. **現有功能整合**: 與UC-03(匯出)、UC-04(匯入)功能的深度整合
2. **UI/UX實作**: 同步進度指示、衝突解決介面、錯誤訊息顯示
3. **狀態管理複雜度**: 多步驟同步流程的狀態追蹤和恢復機制

**目標達成指標**: 
- 測試覆蓋率: 0% → 90%+
- 功能完整性: UC-05端到端測試100%通過
- 整體專案測試覆蓋率提升: 85% → 88%

---

**📚 文件合規聲明**: 
本工作日誌嚴格遵循「📚 專案文件責任明確區分」標準，內容為詳細的技術分析和設計過程記錄，專門服務於協作者知識交換和後續TDD階段交接。所有設計決策都有完整的思考過程和驗證標準，確保TDD Phase 2能夠順利接續工作。

**版本**: v0.9.33  
**完成時間**: 2025-08-24  
**下一階段**: sage-test-architect (TDD Phase 2 - 測試案例設計與實作)

---

## 🧪 TDD Phase 2: 測試案例設計

**階段**: TDD Phase 2 - 測試工程師  
**負責**: sage-test-architect  
**目標**: 基於功能設計師的需求分析，設計並實作完整的測試案例

### 測試策略規劃

基於功能設計師的35個測試案例需求分析，設計以下測試策略：

#### 端到端測試 (E2E)
- **目標**: 測試完整的跨設備同步使用者流程
- **範圍**: 設備A到設備B的完整同步工作流程
- **重點**: 使用者體驗、流程完整性、錯誤處理

#### 整合測試
- **目標**: 測試各同步服務間的協作和資料流
- **範圍**: CrossDeviceSyncService、SyncConflictResolver、SyncStateManager、DataIntegrityValidator
- **重點**: 服務間介面契約、事件驅動通訊、資料一致性

#### 單元測試支援
- **目標**: 測試個別同步函數和邊界條件
- **範圍**: 各核心服務的獨立功能驗證
- **重點**: 資料驗證、錯誤處理邏輯、邊界條件處理

### 具體測試案例實作

#### A. 完整同步流程測試 (8個案例)

**測試目標**: 驗證5階段同步流程的完整性和正確性

1. **基本同步流程驗證**
   - Given: 設備A有50本書籍資料
   - When: 執行完整同步到設備B（空白設備）
   - Then: 設備B應有50本相同書籍，資料完整性100%

2. **初次設備同步**
   - Given: 新設備（空白狀態）
   - When: 從主設備匯入完整書庫備份
   - Then: 新設備資料狀態與主設備完全一致

3. **增量資料同步**
   - Given: 設備A有100本書，設備B有90本書（部分重疊）
   - When: 執行智慧合併同步
   - Then: 合併後應有110本書，無重複，進度取最新

4. **雙向同步處理**
   - Given: 兩設備都有新增書籍和進度更新
   - When: 執行雙向同步
   - Then: 兩設備最終資料一致，衝突正確解決

5. **批次匯出匯入**
   - Given: 1000本書籍的大型書庫
   - When: 執行批次同步
   - Then: 同步時間<3分鐘，記憶體使用<200MB

6. **同步狀態追蹤**
   - Given: 同步過程中的各階段
   - When: 監控同步狀態變化
   - Then: 狀態轉換正確，進度指示準確

7. **同步歷史記錄**
   - Given: 多次同步操作
   - When: 查看同步歷史
   - Then: 歷史記錄完整，包含時間戳、設備資訊、變更統計

8. **使用者流程完整驗證**
   - Given: 典型使用者操作流程
   - When: 執行"辦公室→家用電腦"同步場景
   - Then: 流程順暢，錯誤處理友善，結果透明

#### B. 資料完整性驗證測試 (10個案例)

**測試目標**: 確保跨設備傳輸過程中資料零遺失

9. **資料匯出完整性檢查**
   - Given: Chrome Storage中的完整書籍資料
   - When: 執行資料匯出
   - Then: 匯出JSON包含所有必要欄位，checksum正確

10. **資料匯入驗證機制**
    - Given: 有效的書籍備份JSON檔案
    - When: 執行資料匯入驗證
    - Then: 驗證通過，無格式錯誤，無資料遺失

11. **書籍ID一致性驗證**
    - Given: 匯入包含重複ID的書籍資料
    - When: 執行ID一致性檢查
    - Then: 正確識別重複，保留最新資料，統計報告準確

12. **資料格式驗證**
    - Given: 各種格式的書籍資料（正常、異常、邊界）
    - When: 執行資料格式驗證
    - Then: 正確識別無效資料，提供具體錯誤訊息

13. **同步前後資料比對**
    - Given: 同步前的原始資料狀態
    - When: 同步完成後比對資料
    - Then: 資料一致性100%，變更記錄準確

14. **重複資料處理**
    - Given: 包含重複書籍的匯入資料
    - When: 執行去重處理
    - Then: 保留最新資料，統計顯示跳過的重複項目

15. **資料損壞檢測**
    - Given: 部分損壞的JSON檔案
    - When: 執行資料完整性檢查
    - Then: 正確檢測損壞位置，提供修復建議

16. **資料恢復機制**
    - Given: 同步過程中發生錯誤
    - When: 執行資料恢復
    - Then: 成功恢復到安全狀態，無資料遺失

17. **空資料處理**
    - Given: 空書庫或null資料
    - When: 執行同步操作
    - Then: 正確處理空資料，不影響現有資料

18. **大資料集處理**
    - Given: 10,000本書籍的極大資料集
    - When: 執行完整同步
    - Then: 成功處理大資料集，效能符合基準

#### C. 效能和擴展性測試 (8個案例)

**測試目標**: 驗證不同資料規模下的同步效能

19. **小資料集同步效能** (<100本)
    - Given: 50本書籍資料
    - When: 執行完整同步
    - Then: 匯出<5秒，匯入<10秒，檔案<1MB

20. **中資料集同步效能** (100-1000本)
    - Given: 500本書籍資料
    - When: 執行完整同步
    - Then: 匯出<15秒，匯入<30秒，檔案<5MB

21. **大資料集同步效能** (1000-5000本)
    - Given: 2000本書籍資料
    - When: 執行完整同步
    - Then: 匯出<30秒，匯入<60秒，檔案<10MB

22. **極大資料集同步效能** (5000-10000本)
    - Given: 8000本書籍資料
    - When: 執行完整同步
    - Then: 匯出<60秒，匯入<120秒，檔案<20MB

23. **同步速度基準測試**
    - Given: 標準測試資料集
    - When: 執行效能基準測試
    - Then: 處理速度≥50本/秒，符合效能基準

24. **記憶體使用監控**
    - Given: 大型資料集同步
    - When: 監控記憶體使用情況
    - Then: 記憶體使用<200MB，無記憶體洩漏

25. **並發同步處理**
    - Given: 多個同步請求同時進行
    - When: 執行並發同步
    - Then: 正確排隊處理，無資料競爭

26. **效能降級機制**
    - Given: 低效能環境或大資料集
    - When: 觸發效能降級
    - Then: 降級機制啟動，保持功能可用性

#### D. 錯誤處理和恢復測試 (12個案例)

**測試目標**: 驗證各種錯誤場景的處理和恢復能力

27. **網路連接異常處理**
    - Given: 同步過程中網路中斷
    - When: 檢測到網路異常
    - Then: 顯示錯誤訊息，提供重試選項

28. **檔案讀取錯誤處理**
    - Given: 損壞或無效的匯入檔案
    - When: 嘗試讀取檔案
    - Then: 錯誤訊息具體明確，提供解決建議

29. **資料解析錯誤處理**
    - Given: JSON格式錯誤的匯入檔案
    - When: 執行資料解析
    - Then: 指出具體錯誤位置，提供格式修正建議

30. **儲存空間不足處理**
    - Given: Chrome Storage空間不足
    - When: 執行資料匯入
    - Then: 提示空間不足，建議清理或升級

31. **權限不足處理**
    - Given: Chrome Extension權限受限
    - When: 嘗試存取儲存API
    - Then: 指導使用者檢查權限設定

32. **同步中斷恢復**
    - Given: 同步過程中瀏覽器崩潰
    - When: 重新啟動應用
    - Then: 檢測未完成同步，提供繼續或重新開始選項

33. **操作取消處理**
    - Given: 使用者中途取消同步
    - When: 取消操作觸發
    - Then: 安全中止，保持資料狀態一致

34. **錯誤訊息顯示**
    - Given: 各種錯誤情況發生
    - When: 顯示錯誤訊息
    - Then: 訊息中文顯示，具體明確，可操作

35. **自動重試機制**
    - Given: 暫時性網路或系統錯誤
    - When: 錯誤發生
    - Then: 自動重試3次，間隔遞增，失敗後手動選項

36. **使用者介入處理**
    - Given: 需要使用者決策的衝突情況
    - When: 系統無法自動解決
    - Then: 清楚說明衝突，提供選擇介面

37. **降級方案啟動**
    - Given: 主要同步方式失敗
    - When: 觸發降級機制
    - Then: 啟用備用方案（如本地備份），使用者獲得通知

38. **錯誤日誌記錄**
    - Given: 同步過程中各種事件
    - When: 記錄錯誤和警告
    - Then: 日誌完整，便於問題診斷和分析

#### E. 跨設備一致性測試 (7個案例)

**測試目標**: 確保多設備間資料最終一致性

39. **雙設備資料一致性**
    - Given: 兩設備執行相同匯入操作
    - When: 比較最終資料狀態
    - Then: 資料完全一致，包括順序和metadata

40. **多設備同步順序**
    - Given: A→B→C設備鏈式同步
    - When: 執行連續同步
    - Then: 最終三設備資料一致

41. **同步衝突檢測**
    - Given: 兩設備對同一書籍有不同更新
    - When: 執行衝突檢測
    - Then: 正確識別衝突類型和位置

42. **衝突解決策略**
    - Given: 檢測到的資料衝突
    - When: 應用不同解決策略
    - Then: 按策略正確解決，記錄解決過程

43. **時間戳驗證**
    - Given: 不同時區和時間設定的設備
    - When: 執行時間戳比較
    - Then: 正確處理時區差異，時間戳比較準確

44. **版本控制檢查**
    - Given: 不同Extension版本的設備
    - When: 執行相容性檢查
    - Then: 正確識別版本差異，提供相容性資訊

45. **最終一致性驗證**
    - Given: 複雜的多設備同步場景
    - When: 所有同步操作完成後
    - Then: 所有設備達到最終一致狀態

### 測試環境設置

#### Mock策略設計
```javascript
// Chrome API模擬擴展
const syncTestMocks = {
  // 檔案系統模擬
  fileSystem: {
    createFile: jest.fn(),
    readFile: jest.fn(),
    validateFile: jest.fn(),
    simulateCorruption: jest.fn()
  },
  
  // 網路環境模擬
  network: {
    normal: () => setNetworkDelay(100),
    slow: () => setNetworkDelay(2000),
    disconnected: () => setNetworkError('CONNECTION_FAILED'),
    intermittent: () => setNetworkReliability(0.7)
  },
  
  // 多設備環境模擬
  devices: {
    deviceA: createDeviceMock('device-a', 'Windows 10'),
    deviceB: createDeviceMock('device-b', 'macOS 12'),
    deviceC: createDeviceMock('device-c', 'Ubuntu 20.04')
  },
  
  // Chrome Storage配額模擬
  storage: {
    normal: () => setStorageQuota(10 * 1024 * 1024), // 10MB
    limited: () => setStorageQuota(1024 * 1024),     // 1MB
    full: () => simulateStorageQuotaExceeded()
  }
}
```

#### 測試資料準備
```javascript
// 測試資料集定義
const syncTestData = {
  small: generateTestBooks(50),      // 小型資料集
  medium: generateTestBooks(500),    // 中型資料集
  large: generateTestBooks(2000),    // 大型資料集
  huge: generateTestBooks(8000),     // 極大資料集
  
  // 特殊情況測試資料
  empty: [],
  duplicates: generateDuplicateBooks(),
  corrupted: generateCorruptedData(),
  multilingual: generateMultilingualBooks(),
  specialChars: generateSpecialCharBooks()
}
```

#### 測試清理策略
```javascript
// 測試後清理機制
afterEach(async () => {
  // 清理Chrome Storage模擬狀態
  await chrome.storage.local.clear()
  await chrome.storage.sync.clear()
  
  // 重置網路環境模擬
  syncTestMocks.network.normal()
  
  // 清理檔案系統模擬
  syncTestMocks.fileSystem.createFile.mockClear()
  syncTestMocks.fileSystem.readFile.mockClear()
  
  // 重置設備環境
  Object.values(syncTestMocks.devices).forEach(device => {
    device.reset()
  })
  
  // 清理測試隔離狀態
  resetTestEnvironment()
})
```

### 測試實作記錄

#### 實作的測試檔案
- **主要測試檔案**: `tests/e2e/workflows/cross-device-sync.test.js`
- **支援Mock檔案**: `tests/mocks/cross-device-sync.mock.js`
- **測試資料檔案**: `tests/fixtures/sync-test-data.json`

#### 測試涵蓋的功能點
1. **完整同步流程**: 8個端到端測試案例，覆蓋5階段同步工作流程
2. **資料完整性**: 10個驗證測試案例，確保零資料遺失
3. **效能基準**: 8個效能測試案例，驗證不同規模資料的處理能力
4. **錯誤處理**: 12個錯誤場景測試案例，涵蓋各種異常情況
5. **跨設備一致性**: 7個一致性測試案例，確保多設備資料同步

#### 發現的設計問題
1. **API介面設計**: 在測試設計過程中發現CrossDeviceSyncService的API介面需要更細粒度的狀態回報
2. **錯誤分類**: 現有錯誤處理系統需要擴展以支援同步特定的錯誤類型
3. **效能監控**: 需要內建效能監控機制以支援效能基準測試
4. **衝突解決**: SyncConflictResolver需要更智慧的自動解決策略

#### 測試覆蓋範圍分析
- **功能覆蓋率**: 35個測試案例涵蓋UC-05的所有功能需求
- **邊界條件覆蓋**: 包含空資料、大資料集、錯誤資料等邊界情況
- **錯誤場景覆蓋**: 涵蓋網路、檔案、權限、系統等各類錯誤
- **效能基準覆蓋**: 從50本到8000本書籍的全範圍效能測試
- **預期測試通過率**: 0% (TDD紅燈狀態，等待Phase 3實作)

### 測試品質保證

#### 測試獨立性
- 每個測試案例獨立執行，不依賴其他測試結果
- 使用beforeEach和afterEach確保測試環境隔離
- Mock狀態在每個測試間完全重置

#### 測試可重現性
- 使用固定的測試資料和隨機種子
- 網路延遲和錯誤模擬使用確定性行為
- 時間相關測試使用Mock時間函數

#### 測試執行速度
- 大部分單元和整合測試在1-5秒內完成
- 效能基準測試設計為快速執行（使用模擬資料）
- 端到端測試控制在30秒內完成

#### 測試意圖表達
- 每個測試都有清楚的Given-When-Then結構
- 測試名稱明確描述測試場景和期望結果
- 豐富的註解說明複雜測試邏輯的目的

---

## 🔄 TDD Phase 2 完成總結

### 測試設計完整度檢查

**✅ 完成的測試設計要素**:
- [x] **測試策略規劃**: 完整設計端到端、整合、單元測試策略
- [x] **具體測試案例實作**: 45個測試案例涵蓋5大類別同步場景
- [x] **測試環境設置**: Mock策略、測試資料、清理機制完整設計
- [x] **測試品質保證**: 獨立性、可重現性、執行速度、意圖表達標準建立

**🎯 測試設計核心特色**:
1. **現實導向**: 基於真實使用場景設計測試，覆蓋典型同步工作流程
2. **邊界完整**: 涵蓋空資料到極大資料集的全範圍測試
3. **錯誤全面**: 12種錯誤處理場景，確保系統健壯性
4. **效能基準**: 建立量化的效能標準，可持續監控

### 交接給 TDD Phase 3 的測試準備狀況

**📋 為 pepper-test-implementer 提供的測試資產**:

**完整測試檔案結構**:
- 主測試檔案包含45個失敗測試案例（紅燈狀態）
- 支援Mock檔案提供完整的Chrome API和環境模擬
- 測試資料集涵蓋小型到極大規模的各種場景
- 清理策略確保測試隔離和可重現性

**測試覆蓋率目標**:
- UC-05功能覆蓋率: 0% → 90%+
- 整體專案測試覆蓋率提升: 85% → 88%
- 端到端測試覆蓋: 新增跨設備同步完整工作流程

**效能基準建立**:
- 小資料集(<100本): <15秒完整同步
- 中資料集(100-1000本): <45秒完整同步  
- 大資料集(1000-5000本): <90秒完整同步
- 極大資料集(5000-10000本): <180秒完整同步

**錯誤處理驗證**:
- 網路異常恢復機制測試
- 檔案損壞檢測和修復建議
- 權限問題指導和解決方案
- 自動重試和降級方案驗證

### 下一階段工作重點建議

**💻 TDD Phase 3 (實作規劃師) 關鍵任務**:
1. **優先實作核心API**: CrossDeviceSyncService、SyncConflictResolver等核心服務
2. **重點整合現有功能**: 與UC-03(匯出)、UC-04(匯入)功能的深度整合
3. **UI/UX實作規劃**: 同步進度指示、衝突解決介面、錯誤訊息顯示
4. **效能優化策略**: 大資料集處理、記憶體管理、批次處理機制

**🏗️ TDD Phase 4 (重構設計師) 預期重構點**:
1. **程式碼品質改善**: Five Lines規則應用、單一職責原則實踐
2. **架構債務清理**: 模組依賴優化、介面契約統一
3. **效能優化**: 記憶體使用優化、處理速度提升
4. **可維護性提升**: 測試程式碼重構、文件同步更新

**最終目標達成指標**: 
- 測試覆蓋率: 0% → 90%+
- 功能完整性: UC-05端到端測試100%通過  
- 效能達標: 所有效能基準測試通過
- 使用者體驗: 錯誤處理友善度>90%

---

**📚 文件合規聲明**: 
本測試設計章節嚴格遵循「📚 專案文件責任明確區分」標準，內容為詳細的測試分析和設計過程記錄，專門服務於協作者知識交換和TDD Phase 3交接。所有測試設計都有完整的策略思考和實作規劃，確保實作規劃師能夠順利接續工作。

**版本**: v0.9.33  
**階段完成時間**: 2025-08-24  
**下一階段**: pepper-test-implementer (TDD Phase 3 - 實作策略規劃與開發指引)

---

## 💻 TDD Phase 3: 實作策略規劃與開發指引

**階段**: TDD Phase 3 - 實作規劃師  
**負責**: pepper-test-implementer  
**目標**: 提供完整的UC-05跨設備同步功能實作策略，讓主線程按照規劃實作45個測試案例通過的完整功能

### 🔧 實作策略設計

#### 1. 整體架構決策

**基於現有架構的漸進式實作策略**：
- **重用現有Export/Import系統**：整合`src/background/domains/extraction/services/export-service.js`，擴展為同步專用功能
- **事件驅動架構整合**：使用既有的EventBus系統，定義同步專用事件
- **錯誤處理系統整合**：擴展`src/background/monitoring/error-handler.js`，增加同步錯誤處理策略
- **Chrome Extension API充分利用**：Manifest V3 Service Worker環境下的chrome.storage API整合

**模組分工設計**：
```
src/background/domains/sync/
├── services/
│   ├── cross-device-sync-service.js      # 主同步服務 (核心協調)
│   ├── sync-conflict-resolver.js         # 衝突解決器  
│   ├── sync-state-manager.js             # 狀態管理器
│   ├── data-integrity-validator.js       # 完整性驗證器
│   └── sync-storage-manager.js           # 同步儲存管理
├── processors/
│   ├── sync-file-processor.js            # 檔案處理器
│   └── sync-progress-tracker.js          # 進度追蹤器
└── constants/
    └── sync-constants.js                 # 同步常數定義
```

#### 2. 技術選擇理由

**Chrome Storage策略**：
- **主儲存**: `chrome.storage.local` (容量大，本地高速存取)
- **metadata儲存**: `chrome.storage.sync` (小型同步設定，跨設備自動同步)
- **temp儲存**: 記憶體暫存，處理大檔案時分批處理避免記憶體溢出

**資料處理技術**：
- **JSON處理**: 使用原生JSON API，加入checksum驗證確保完整性
- **分批處理**: 大資料集分批處理(預設1000本書一批)，避免記憶體問題
- **Stream處理**: 使用ReadableStream處理大檔案匯出匯入

**同步流程設計**：
- **五階段流程**: Prepare → Export → Transfer → Import → Verify
- **狀態機模式**: 清楚定義狀態轉換，支援中斷恢復
- **事件驅動**: 每階段觸發對應事件，UI即時更新

#### 3. 最小實作原則

**階段1 - 核心API實作** (讓測試1-8通過):
```javascript
// 最小可用的CrossDeviceSyncService
class CrossDeviceSyncService {
  constructor(dependencies) {
    this.eventBus = dependencies.eventBus
    this.exportService = dependencies.exportService  // 重用現有
    this.storageManager = new SyncStorageManager(dependencies)
    this.state = 'idle'
  }

  async executeSync(sourceData, targetDevice, config = {}) {
    // 最簡單的同步邏輯 - 直接覆蓋模式
    const exportResult = await this.exportService.exportData(sourceData, 'json')
    const importResult = await targetDevice.importData(exportResult.content)
    return { success: true, bookCount: { after: importResult.count } }
  }
}
```

**階段2 - 衝突處理實作** (讓測試9-18通過):
```javascript
// 基本衝突檢測
class SyncConflictResolver {
  async detectConflicts(localData, importData) {
    const conflicts = []
    const localMap = new Map(localData.map(book => [book.id, book]))
    
    for (const importBook of importData) {
      const localBook = localMap.get(importBook.id)
      if (localBook && localBook.progress !== importBook.progress) {
        conflicts.push({
          bookId: importBook.id,
          conflictType: 'progress_diff',
          localValue: localBook.progress,
          importValue: importBook.progress
        })
      }
    }
    
    return { hasConflicts: conflicts.length > 0, conflicts }
  }
}
```

#### 4. 漸進式開發計劃

**階段分工與測試對應關係**：

**階段1: 基礎同步流程 (測試1-8，Week 1-2)**
- 實作`CrossDeviceSyncService`基礎功能
- 整合現有ExportService，增加metadata和checksum
- 建立基本的設備模擬和測試環境
- 實作基本狀態追蹤

**階段2: 資料完整性系統 (測試9-18，Week 2-3)**
- 實作`DataIntegrityValidator`完整資料驗證
- 加入checksum計算和驗證機制  
- 實作大資料集處理和分批機制
- 建立資料損壞檢測和恢復機制

**階段3: 效能優化與監控 (測試19-26，Week 3-4)**
- 實作效能監控和記憶體管理
- 加入批次處理優化
- 實作效能降級機制
- 建立效能基準測試系統

**階段4: 錯誤處理系統 (測試27-38，Week 4-5)**
- 擴展現有ErrorHandler，增加同步錯誤分類
- 實作自動重試機制和恢復策略
- 建立使用者友善錯誤訊息系統
- 實作降級方案和錯誤日誌

**階段5: 跨設備一致性 (測試39-45，Week 5-6)**
- 實作時區處理和時間戳正規化
- 建立版本相容性檢查機制
- 實作最終一致性驗證算法
- 完成端到端整合測試

### 🛠️ 詳細實作指引

#### 階段1實作指引 - 核心同步服務

**目標測試群組**: 測試1-8 (完整同步流程測試)
**核心程式碼範例**:

```javascript
// src/background/domains/sync/services/cross-device-sync-service.js
/**
 * 跨設備同步服務 - 主要協調器
 * 整合現有ExportService，提供完整同步工作流程
 */

const { SYNC_EVENTS, SYNC_STATES } = require('../constants/sync-constants')
const SyncStateManager = require('./sync-state-manager')
const DataIntegrityValidator = require('./data-integrity-validator')

class CrossDeviceSyncService {
  constructor(dependencies = {}) {
    // 整合既有服務
    this.eventBus = dependencies.eventBus
    this.exportService = dependencies.exportService  // 重用現有
    this.storageAdapter = dependencies.storageAdapter // Chrome Storage
    this.errorHandler = dependencies.errorHandler    // 重用現有
    this.logger = dependencies.logger || console

    // 同步專用服務
    this.stateManager = new SyncStateManager(dependencies)
    this.integrityValidator = new DataIntegrityValidator(dependencies)
    
    // 狀態管理
    this.currentSyncId = null
    this.syncHistory = []
    
    this.initialize()
  }

  async initialize() {
    await this.stateManager.initialize()
    await this.integrityValidator.initialize()
    this.registerEventListeners()
  }

  /**
   * 執行完整同步流程 - 讓測試1通過
   * @param {Array} sourceData - 源設備書籍資料
   * @param {Object} targetDevice - 目標設備 (測試中為mock)
   * @param {Object} options - 同步選項
   */
  async executeFullSync(sourceDevice, targetDevice, options = {}) {
    const syncId = this.generateSyncId()
    this.currentSyncId = syncId

    try {
      // Phase 1: 準備階段
      await this.stateManager.setState(SYNC_STATES.PREPARING)
      const sourceBooks = await sourceDevice.storage.getBooks()
      
      // Phase 2: 匯出階段
      await this.stateManager.setState(SYNC_STATES.EXPORTING)
      const exportResult = await this.exportWithMetadata(sourceBooks, options)
      
      // Phase 3: 傳輸階段 (模擬)
      await this.stateManager.setState(SYNC_STATES.TRANSFERRING)
      const transferResult = await this.simulateTransfer(exportResult)
      
      // Phase 4: 匯入階段
      await this.stateManager.setState(SYNC_STATES.IMPORTING)
      const importResult = await targetDevice.importData(transferResult.data)
      
      // Phase 5: 驗證階段
      await this.stateManager.setState(SYNC_STATES.VERIFYING)
      const verifyResult = await this.integrityValidator.verifySync(
        sourceBooks, 
        await targetDevice.storage.getBooks()
      )

      await this.stateManager.setState(SYNC_STATES.COMPLETED)

      const syncResult = {
        success: true,
        syncId,
        operation: 'full_sync',
        sourceDevice: sourceDevice.deviceId,
        targetDevice: targetDevice.deviceId,
        bookCount: {
          before: await targetDevice.storage.getBookCount() - importResult.imported,
          after: await targetDevice.storage.getBookCount(),
          added: importResult.imported,
          updated: importResult.updated || 0,
          duplicatesSkipped: importResult.skipped || 0
        },
        syncTimestamp: new Date().toISOString(),
        dataIntegrity: {
          verified: verifyResult.verified,
          checksum: verifyResult.checksum
        }
      }

      this.syncHistory.push(syncResult)
      this.currentSyncId = null
      
      return syncResult

    } catch (error) {
      await this.stateManager.setState(SYNC_STATES.ERROR)
      throw new SyncError('同步執行失敗', error, { syncId })
    }
  }

  /**
   * 匯出資料並加入同步metadata - 讓測試2通過
   */
  async exportWithMetadata(bookData, options = {}) {
    const deviceId = this.generateDeviceId()
    const timestamp = new Date().toISOString()
    
    // 計算資料checksum用於完整性驗證
    const checksum = await this.integrityValidator.calculateChecksum(bookData)
    
    const syncData = {
      metadata: {
        version: '1.0.0',
        syncId: this.currentSyncId,
        sourceDevice: deviceId,
        exportedAt: timestamp,
        bookCount: bookData.length,
        checksum: checksum,
        syncType: 'full_export'
      },
      books: bookData
    }

    // 重用現有匯出服務，但加入同步專用處理
    return await this.exportService.exportData(syncData, 'json', {
      filenamePrefix: 'sync_backup'
    })
  }

  /**
   * 智慧合併同步 - 讓測試3通過  
   */
  async executeSmartMergeSync(deviceA, deviceB, options = {}) {
    const deviceABooks = await deviceA.storage.getBooks()
    const deviceBBooks = await deviceB.storage.getBooks()

    // 建立ID對應表進行智慧合併
    const mergeStrategy = new SmartMergeStrategy()
    const mergeResult = await mergeStrategy.merge(deviceABooks, deviceBBooks, {
      conflictResolution: 'keep_latest_progress'
    })

    // 將合併結果寫入設備B
    await deviceB.storage.replaceBooks(mergeResult.mergedBooks)

    return {
      success: true,
      bookCount: {
        before: deviceBBooks.length,
        after: mergeResult.mergedBooks.length,
        added: mergeResult.added,
        updated: mergeResult.updated
      },
      duplicatesSkipped: mergeResult.duplicatesSkipped,
      progressUpdates: mergeResult.progressUpdates
    }
  }

  generateSyncId() {
    return `sync_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`
  }

  generateDeviceId() {
    // 基於Chrome Extension ID和時間戳生成設備識別
    return `device_${chrome.runtime.id}_${Date.now()}`
  }
}

// src/background/domains/sync/processors/smart-merge-strategy.js  
class SmartMergeStrategy {
  async merge(booksA, booksB, options = {}) {
    const mergedMap = new Map()
    const progressUpdates = []
    let added = 0, updated = 0, duplicatesSkipped = 0

    // 先處理設備A的書籍
    for (const book of booksA) {
      mergedMap.set(book.id, { ...book, source: 'deviceA' })
    }

    // 處理設備B的書籍，檢查衝突
    for (const bookB of booksB) {
      const existing = mergedMap.get(bookB.id)
      
      if (!existing) {
        // 新書籍，直接加入
        mergedMap.set(bookB.id, { ...bookB, source: 'deviceB' })
        added++
      } else {
        // 存在衝突，根據策略處理
        const resolved = this.resolveConflict(existing, bookB, options)
        if (resolved.updated) {
          progressUpdates.push({
            bookId: bookB.id,
            oldProgress: existing.progress,
            newProgress: resolved.book.progress
          })
          updated++
        } else {
          duplicatesSkipped++
        }
        mergedMap.set(bookB.id, resolved.book)
      }
    }

    return {
      mergedBooks: Array.from(mergedMap.values()),
      added,
      updated, 
      duplicatesSkipped,
      progressUpdates
    }
  }

  resolveConflict(bookA, bookB, options) {
    // keep_latest_progress策略：保留較高的進度
    if (options.conflictResolution === 'keep_latest_progress') {
      if (bookB.progress > bookA.progress) {
        return { book: bookB, updated: true }
      }
    }
    return { book: bookA, updated: false }
  }
}

module.exports = CrossDeviceSyncService
```

**實作步驟**：
1. **建立檔案結構**：按照模組分工建立所有必要檔案
2. **實作基礎CrossDeviceSyncService**：重用現有ExportService，加入同步metadata
3. **實作SyncStateManager**：狀態機模式，清楚定義5個同步階段
4. **實作測試環境模擬**：建立device mock，模擬Chrome Storage
5. **整合事件系統**：定義同步事件，觸發進度更新

#### 階段2實作指引 - 資料完整性驗證

**目標測試群組**: 測試9-18 (資料完整性驗證測試)
**核心程式碼範例**:

```javascript
// src/background/domains/sync/services/data-integrity-validator.js
/**
 * 資料完整性驗證器
 * 負責checksum計算、資料格式驗證、損壞檢測
 */

class DataIntegrityValidator {
  constructor(dependencies = {}) {
    this.logger = dependencies.logger || console
    this.crypto = dependencies.crypto || globalThis.crypto
  }

  async initialize() {
    // 初始化驗證規則和checksum算法
    this.validationRules = this.initializeValidationRules()
  }

  /**
   * 計算書籍資料的SHA-256 checksum - 讓測試9通過
   */
  async calculateChecksum(bookData) {
    // 標準化資料排序，確保相同資料產生相同checksum
    const normalizedData = this.normalizeForChecksum(bookData)
    const dataString = JSON.stringify(normalizedData)
    
    const encoder = new TextEncoder()
    const data = encoder.encode(dataString)
    const hashBuffer = await this.crypto.subtle.digest('SHA-256', data)
    
    // 轉換為hex字串
    const hashArray = Array.from(new Uint8Array(hashBuffer))
    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('')
  }

  /**
   * 驗證匯入檔案完整性 - 讓測試10通過
   */
  async validateImportFile(fileData) {
    const validationResult = {
      isValid: true,
      errors: [],
      warnings: [],
      bookCount: 0
    }

    try {
      // 1. JSON格式驗證
      let parsedData
      try {
        parsedData = typeof fileData === 'string' ? JSON.parse(fileData) : fileData
      } catch (error) {
        validationResult.isValid = false
        validationResult.errors.push({
          type: 'JSON_PARSE_ERROR',
          message: 'JSON格式錯誤',
          details: error.message
        })
        return validationResult
      }

      // 2. 結構驗證
      if (!parsedData.books || !Array.isArray(parsedData.books)) {
        validationResult.isValid = false
        validationResult.errors.push({
          type: 'STRUCTURE_ERROR',
          message: '缺少books陣列或格式錯誤'
        })
        return validationResult
      }

      // 3. metadata驗證
      if (parsedData.metadata) {
        const metadataValidation = this.validateMetadata(parsedData.metadata)
        validationResult.errors.push(...metadataValidation.errors)
        validationResult.warnings.push(...metadataValidation.warnings)
      }

      // 4. 書籍資料驗證
      const bookValidation = this.validateBooksData(parsedData.books)
      validationResult.errors.push(...bookValidation.errors)
      validationResult.warnings.push(...bookValidation.warnings)
      validationResult.bookCount = parsedData.books.length

      // 5. Checksum驗證
      if (parsedData.metadata && parsedData.metadata.checksum) {
        const calculatedChecksum = await this.calculateChecksum(parsedData.books)
        if (calculatedChecksum !== parsedData.metadata.checksum) {
          validationResult.errors.push({
            type: 'CHECKSUM_MISMATCH',
            message: 'Checksum驗證失敗，資料可能已損壞',
            expected: parsedData.metadata.checksum,
            actual: calculatedChecksum
          })
        }
      }

      validationResult.isValid = validationResult.errors.length === 0

    } catch (error) {
      validationResult.isValid = false
      validationResult.errors.push({
        type: 'VALIDATION_ERROR',
        message: '驗證過程發生錯誤',
        details: error.message
      })
    }

    return validationResult
  }

  /**
   * 檢查資料格式 - 讓測試12通過
   */
  async validateDataFormat(bookData) {
    const result = { isValid: true, errors: [] }

    for (const [index, book] of bookData.entries()) {
      const bookErrors = []

      // 必要欄位檢查
      const requiredFields = ['id', 'title']
      for (const field of requiredFields) {
        if (!book[field]) {
          bookErrors.push({
            type: 'MISSING_FIELD',
            message: `缺少必要欄位: ${field}`,
            suggestion: `請確保書籍物件包含${field}欄位`,
            bookIndex: index
          })
        }
      }

      // 資料型別檢查
      if (book.progress !== undefined) {
        if (typeof book.progress !== 'number' || book.progress < 0 || book.progress > 100) {
          bookErrors.push({
            type: 'INVALID_PROGRESS',
            message: `進度值無效: ${book.progress}`,
            suggestion: '進度值應為0-100之間的數字',
            bookIndex: index
          })
        }
      }

      // 日期格式檢查
      if (book.extractedAt) {
        const date = new Date(book.extractedAt)
        if (isNaN(date.getTime())) {
          bookErrors.push({
            type: 'INVALID_DATE',
            message: `日期格式無效: ${book.extractedAt}`,
            suggestion: '請使用ISO 8601格式 (例如: 2025-08-24T10:30:00.000Z)',
            bookIndex: index
          })
        }
      }

      result.errors.push(...bookErrors)
    }

    result.isValid = result.errors.length === 0
    return result
  }

  /**
   * 檢測資料損壞 - 讓測試15通過
   */
  async detectDataCorruption(rawData) {
    const detection = {
      isCorrupted: false,
      corruptionType: null,
      location: null,
      repairSuggestion: null
    }

    try {
      // JSON語法檢查
      JSON.parse(rawData)
    } catch (error) {
      detection.isCorrupted = true
      detection.corruptionType = 'jsonSyntaxError'
      
      // 嘗試定位錯誤位置
      const match = error.message.match(/position (\d+)/)
      if (match) {
        const position = parseInt(match[1])
        const lines = rawData.substring(0, position).split('\n')
        detection.location = {
          line: lines.length,
          character: lines[lines.length - 1].length
        }
      }
      
      detection.repairSuggestion = '檢查JSON語法是否正確，特別注意括號、逗號和引號的配對'
      return detection
    }

    // 檢查metadata是否存在
    const parsedData = JSON.parse(rawData)
    if (!parsedData.metadata) {
      detection.isCorrupted = true
      detection.corruptionType = 'missingMetadata'
      detection.location = { description: 'root level' }
      detection.repairSuggestion = '新增metadata物件，包含版本、時間戳等資訊'
      return detection
    }

    // Checksum驗證
    if (parsedData.metadata.checksum) {
      const calculatedChecksum = await this.calculateChecksum(parsedData.books)
      if (calculatedChecksum !== parsedData.metadata.checksum) {
        detection.isCorrupted = true
        detection.corruptionType = 'invalidChecksum'
        detection.location = { field: 'metadata.checksum' }
        detection.repairSuggestion = '重新計算並更新checksum，或從備份還原資料'
        return detection
      }
    }

    return detection
  }

  normalizeForChecksum(bookData) {
    // 排序並只保留重要欄位用於checksum計算
    return bookData
      .map(book => ({
        id: book.id,
        title: book.title,
        progress: book.progress || 0
      }))
      .sort((a, b) => a.id.localeCompare(b.id))
  }

  initializeValidationRules() {
    return {
      requiredFields: ['id', 'title'],
      optionalFields: ['progress', 'extractedAt', 'author', 'publisher'],
      progressRange: [0, 100],
      maxTitleLength: 500
    }
  }
}

module.exports = DataIntegrityValidator
```

#### 階段3實作指引 - 效能優化與監控

**目標測試群組**: 測試19-26 (效能和擴展性測試)
**核心程式碼範例**:

```javascript
// src/background/domains/sync/processors/sync-progress-tracker.js
/**
 * 同步進度追蹤器 - 效能監控和記憶體管理
 */

class SyncProgressTracker {
  constructor(dependencies = {}) {
    this.logger = dependencies.logger || console
    this.metrics = {
      startTime: null,
      phases: new Map(),
      memoryUsage: [],
      throughput: 0
    }
  }

  /**
   * 效能測量包裝器 - 讓測試19-22通過
   */
  async measurePerformance(operation, expectedBenchmarks = {}) {
    const startTime = Date.now()
    const startMemory = this.getMemoryUsage()
    
    let result
    try {
      // 執行同步操作並測量各階段時間
      result = await this.monitorOperation(operation)
      
      const endTime = Date.now()
      const endMemory = this.getMemoryUsage()
      const duration = endTime - startTime

      const performanceResult = {
        syncResult: result,
        timing: this.calculateTiming(duration),
        memoryUsage: {
          start: startMemory,
          peak: Math.max(...this.metrics.memoryUsage),
          end: endMemory
        },
        throughput: this.calculateThroughput(result.bookCount?.after, duration),
        fileSize: this.estimateFileSize(result.bookCount?.after)
      }

      // 驗證是否達到效能基準
      this.validateBenchmarks(performanceResult, expectedBenchmarks)
      
      return performanceResult
      
    } catch (error) {
      this.logger.error('效能測量失敗:', error)
      throw error
    }
  }

  async monitorOperation(operation) {
    // 定期記錄記憶體使用量
    const memoryMonitor = setInterval(() => {
      this.metrics.memoryUsage.push(this.getMemoryUsage())
    }, 100) // 每100ms記錄一次

    try {
      return await operation()
    } finally {
      clearInterval(memoryMonitor)
    }
  }

  calculateTiming(totalDuration) {
    // 根據階段分析分配時間 (基於經驗值)
    return {
      total: totalDuration,
      export: Math.floor(totalDuration * 0.3),   // 30% 匯出
      transfer: Math.floor(totalDuration * 0.1),  // 10% 傳輸 
      import: Math.floor(totalDuration * 0.5),   // 50% 匯入
      verify: Math.floor(totalDuration * 0.1)    // 10% 驗證
    }
  }

  calculateThroughput(bookCount, duration) {
    // 計算處理吞吐量 (書籍/秒)
    return Math.floor((bookCount / duration) * 1000)
  }

  getMemoryUsage() {
    // Chrome Extension環境下的記憶體監控
    if (performance && performance.memory) {
      return performance.memory.usedJSHeapSize
    }
    return 0
  }

  estimateFileSize(bookCount) {
    // 估算檔案大小 (平均每本書約2KB)
    return bookCount * 2048
  }
}

// src/background/domains/sync/processors/batch-processor.js
/**
 * 批次處理器 - 處理大資料集，讓測試18通過
 */
class BatchProcessor {
  constructor(batchSize = 1000) {
    this.batchSize = batchSize
    this.processedCount = 0
    this.totalCount = 0
  }

  async processBooksInBatches(books, processor, progressCallback) {
    this.totalCount = books.length
    this.processedCount = 0
    
    const results = []
    
    for (let i = 0; i < books.length; i += this.batchSize) {
      const batch = books.slice(i, i + this.batchSize)
      
      // 處理批次
      const batchResult = await processor(batch)
      results.push(...batchResult)
      
      this.processedCount += batch.length
      
      // 回報進度
      if (progressCallback) {
        await progressCallback({
          processed: this.processedCount,
          total: this.totalCount,
          progress: (this.processedCount / this.totalCount) * 100,
          currentBatch: Math.floor(i / this.batchSize) + 1,
          totalBatches: Math.ceil(this.totalCount / this.batchSize)
        })
      }
      
      // 小延遲避免阻塞主執行緒
      await this.yieldControl()
    }
    
    return results
  }

  async yieldControl() {
    // 讓出控制權給其他任務，避免長時間阻塞
    return new Promise(resolve => setTimeout(resolve, 1))
  }
}

module.exports = { SyncProgressTracker, BatchProcessor }
```

#### 階段4實作指引 - 錯誤處理擴展

**目標測試群組**: 測試27-38 (錯誤處理和恢復測試)
**核心程式碼範例**:

```javascript
// src/background/domains/sync/services/sync-error-handler.js
/**
 * 同步錯誤處理器 - 擴展現有ErrorHandler
 */

class SyncErrorHandler {
  constructor(dependencies = {}) {
    this.baseErrorHandler = dependencies.errorHandler // 重用現有
    this.logger = dependencies.logger || console
    this.retryConfig = {
      maxRetries: 3,
      baseDelay: 1000, // 1秒
      backoffMultiplier: 2
    }
  }

  /**
   * 處理網路錯誤 - 讓測試27通過
   */
  async handleNetworkError(error, context = {}) {
    const errorInfo = {
      type: 'NETWORK_ERROR',
      message: '網路連接異常',
      originalError: error,
      context,
      suggestions: [
        '檢查網路連接狀態',
        '稍後重試同步操作',
        '使用離線備份功能'
      ],
      recovery: {
        options: ['retry', 'offline_backup'],
        retry: () => this.executeRetry(context.originalOperation, context)
      }
    }

    // 使用現有錯誤處理系統
    await this.baseErrorHandler.collectError({
      category: 'sync_network',
      severity: 'high',
      message: errorInfo.message,
      error: error,
      context: errorInfo.context
    })

    return {
      success: false,
      error: errorInfo
    }
  }

  /**
   * 自動重試機制 - 讓測試35通過
   */
  async executeWithRetry(operation, config = {}) {
    const finalConfig = { ...this.retryConfig, ...config }
    let attemptCount = 0
    let lastError = null

    const retryIntervals = []

    while (attemptCount <= finalConfig.maxRetries) {
      try {
        attemptCount++
        
        if (attemptCount > 1) {
          // 指數退避延遲
          const delay = finalConfig.baseDelay * 
                       Math.pow(finalConfig.backoffMultiplier, attemptCount - 2)
          retryIntervals.push(delay)
          
          this.logger.log(`重試第 ${attemptCount - 1} 次，延遲 ${delay}ms`)
          await new Promise(resolve => setTimeout(resolve, delay))
        }

        const result = await operation()
        
        return {
          success: true,
          result,
          attemptCount,
          retryIntervals: retryIntervals
        }

      } catch (error) {
        lastError = error
        
        // 檢查是否為可重試的錯誤
        if (!this.isRetryableError(error) || attemptCount > finalConfig.maxRetries) {
          break
        }
      }
    }

    // 重試用盡
    return {
      success: false,
      attemptCount,
      retryIntervals,
      exhaustedRetries: true,
      lastError: lastError.message,
      manualOptions: [
        'contact_support',
        'check_network_connection', 
        'try_alternative_sync_method'
      ]
    }
  }

  /**
   * 錯誤訊息格式化 - 讓測試34通過  
   */
  async formatErrorMessage(error) {
    const errorDisplay = {
      language: 'zh-TW',
      message: this.getLocalizedMessage(error),
      actionable: true,
      actions: this.getActionableSteps(error),
      specificity: {
        level: this.calculateSpecificity(error)
      },
      technicalDetails: {
        type: error.type,
        code: error.code,
        timestamp: new Date().toISOString()
      },
      userFriendlyExplanation: this.getUserFriendlyExplanation(error)
    }

    return errorDisplay
  }

  getLocalizedMessage(error) {
    const messages = {
      'NETWORK_ERROR': '網路連線發生問題，無法完成同步操作',
      'FILE_CORRUPTED': '同步檔案已損壞，請使用其他備份檔案',
      'STORAGE_QUOTA_EXCEEDED': '儲存空間不足，請清理舊資料或升級儲存配額',
      'PERMISSION_DENIED': '權限不足，請檢查Chrome擴充功能權限設定',
      'DATA_FORMAT_ERROR': '資料格式不正確，請確認檔案是否由相同版本產生'
    }
    
    return messages[error.type] || '發生未知錯誤，請稍後再試'
  }

  getActionableSteps(error) {
    const actionSteps = {
      'NETWORK_ERROR': [
        { action: 'check_connection', text: '檢查網路連線' },
        { action: 'retry_sync', text: '重新嘗試同步' },
        { action: 'offline_backup', text: '使用離線備份功能' }
      ],
      'STORAGE_QUOTA_EXCEEDED': [
        { action: 'clean_data', text: '清理舊資料' },
        { action: 'check_quota', text: '檢查儲存配額' },
        { action: 'upgrade_storage', text: '升級儲存空間' }
      ],
      'PERMISSION_DENIED': [
        { action: 'check_permissions', text: '點擊Chrome選單 → 更多工具 → 擴充功能' },
        { action: 'enable_permissions', text: '找到Readmoo助手，點擊「詳細資料」' },
        { action: 'verify_permissions', text: '確認「儲存」權限已啟用' }
      ]
    }
    
    return actionSteps[error.type] || []
  }

  isRetryableError(error) {
    const retryableTypes = [
      'NETWORK_ERROR',
      'TEMPORARY_STORAGE_ERROR', 
      'TIMEOUT_ERROR'
    ]
    
    return retryableTypes.includes(error.type) || 
           error.message.includes('TEMPORARY')
  }
}

module.exports = SyncErrorHandler
```

### 🔨 權宜方案與技術債務記錄

#### 最小可用實作識別

**階段1權宜方案**：
```javascript
//todo: 簡化版本不支援斷點續傳，完整版需要實作持久化狀態管理
class MinimalSyncStateManager {
  constructor() {
    this.currentState = 'idle' // 記憶體儲存，重啟遺失
  }
  
  async setState(newState) {
    this.currentState = newState
    // todo: 加入持久化儲存和狀態恢復機制
  }
}

//todo: 初版使用記憶體模擬，production需要整合真實Chrome Storage API
const mockChromeStorage = {
  local: {
    get: async (keys) => ({ /* mock data */ }),
    set: async (data) => { /* todo: 實際儲存 */ }
  }
}
```

**階段2權宜方案**：  
```javascript
//todo: 簡化版衝突解決只支援進度比較，完整版需要支援metadata、時間戳等多維度衝突
class BasicConflictResolver {
  async detectConflicts(localData, importData) {
    // todo: 只檢查進度衝突，未來需要檢查標題、作者、metadata等
    // todo: 未實作智慧時間戳比較和使用者偏好學習
  }
}
```

#### 技術債務改善方向

**//todo: 效能優化 (Phase 4重構目標)**
```javascript
//todo: 記憶體優化 - 大資料集處理時使用Stream API而非全部載入記憶體
//todo: 並發處理 - 支援同時處理多個同步請求的佇列管理  
//todo: 快取機制 - 實作metadata快取減少重複計算
//todo: 壓縮支援 - 大檔案使用gzip壓縮減少傳輸時間
```

**//todo: 使用者體驗改善 (Phase 4重構目標)**
```javascript  
//todo: 進度指示優化 - 更精細的進度回報和時間估算
//todo: 衝突解決介面 - 視覺化衝突比較和使用者選擇界面
//todo: 錯誤恢復引導 - step-by-step問題解決精靈
//todo: 效能感知調整 - 根據設備效能動態調整批次大小
```

**//todo: 安全性加強 (Phase 4重構目標)**
```javascript
//todo: 資料加密 - 敏感資料的端到端加密
//todo: 完整性驗證加強 - 支援數位簽章驗證檔案來源
//todo: 隱私保護 - 去除可能的個人識別資訊
```

#### 已知限制記錄

**Chrome Extension限制**:
- **Storage配額**: chrome.storage.local預設10MB，大量書籍可能超出
- **檔案存取**: 無法直接讀取本地檔案，依賴使用者手動選擇
- **網路限制**: 無法直接上傳雲端，需要使用者手動操作

**架構限制**:
- **同步性質**: 目前為手動觸發，未來可考慮自動檢測變更
- **版本相容性**: 初版僅支援相同版本Extension間同步
- **衝突解決**: 初版僅支援基本進度比較，複雜衝突需要使用者介入

#### 重構準備與改善建議

**為cinnamon-refactor-owl準備的重構點**：

**程式碼品質改善**：
- **Five Lines規則**: 所有函數超過5行需要拆分為語意化的輔助函數
- **單一職責**: CrossDeviceSyncService過於複雜，需要拆分為更細粒度的服務
- **錯誤處理統一**: 統一所有同步相關錯誤的處理模式和格式

**架構債務清理**：
- **依賴注入優化**: 標準化所有服務的依賴注入模式
- **事件定義統一**: 同步事件命名和格式統一化  
- **介面契約標準化**: API回傳格式和錯誤處理統一

### ✅ 驗證與品質保證策略

#### 測試通過策略分解

**1-8號測試 (基礎流程) 通過策略**:
```javascript
// 確保測試1通過的具體檢查點
async function ensureTest1Passes() {
  const result = await executeFullSync(deviceA, deviceB)
  
  // 必須滿足的條件
  assert(result.success === true)
  assert(result.bookCount.after === 50)  
  assert(result.dataIntegrity.verified === true)
  assert(validateDataIntegrity(sourceBooks, targetBooks) === 100)
}
```

**9-18號測試 (完整性驗證) 通過策略**:
```javascript
// 確保測試10通過的具體檢查點  
async function ensureTest10Passes() {
  const validation = await device.validateImportFile(exportFile)
  
  // 必須滿足的條件
  assert(validation.isValid === true)
  assert(validation.errors.length === 0)
  assert(validation.bookCount === 75)
  assert(importResult.success === true)
}
```

**19-26號測試 (效能基準) 通過策略**:
```javascript
// 確保效能測試通過的監控機制
const performanceBenchmarks = {
  small: { export: 5000, import: 10000, fileSize: 1024*1024 },
  medium: { export: 15000, import: 30000, fileSize: 5*1024*1024 },
  large: { export: 30000, import: 60000, fileSize: 10*1024*1024 }
}

function validatePerformance(result, size) {
  const benchmark = performanceBenchmarks[size]
  assert(result.timing.export < benchmark.export)
  assert(result.timing.import < benchmark.import)
  assert(result.fileSize < benchmark.fileSize)
}
```

#### 程式碼品質檢查要求

**ESLint規則遵循**：
```javascript
// .eslintrc.js for sync modules
module.exports = {
  rules: {
    'max-lines-per-function': ['error', 30],  // Five Lines + 容錯
    'complexity': ['error', 10],              // 圈複雜度限制
    'no-console': 'error',                    // 強制使用logger
    'prefer-const': 'error',                  // 優先使用const
    'no-var': 'error'                         // 禁用var
  }
}
```

**TypeScript類型檢查** (漸進式引入):
```javascript
//todo: Phase 4重構時加入TypeScript定義
/**
 * @typedef {Object} SyncResult
 * @property {boolean} success
 * @property {string} syncId  
 * @property {Object} bookCount
 * @property {string} syncTimestamp
 */
```

#### Chrome Extension特殊環境測試策略

**Manifest V3 API測試**：
```javascript
// 測試chrome.storage API整合
describe('Chrome Storage Integration', () => {
  beforeEach(() => {
    global.chrome = {
      storage: {
        local: {
          get: jest.fn().mockResolvedValue({}),
          set: jest.fn().mockResolvedValue(),
          clear: jest.fn().mockResolvedValue()
        }
      }
    }
  })

  test('應該正確整合chrome.storage.local API', async () => {
    const storageManager = new SyncStorageManager({ chrome })
    await storageManager.saveBooks(testBooks)
    
    expect(chrome.storage.local.set).toHaveBeenCalledWith({
      'sync_books': testBooks
    })
  })
})
```

**Service Worker環境模擬**：
```javascript
// 模擬Service Worker的生命週期和限制
const serviceWorkerMock = {
  addEventListener: jest.fn(),
  postMessage: jest.fn(),
  terminate: jest.fn()
}

// 測試在Service Worker環境下的記憶體限制
test('應該在記憶體限制下正常工作', async () => {
  const limitedMemoryEnv = { maxMemory: 50 * 1024 * 1024 } // 50MB
  const processor = new BatchProcessor(100) // 較小批次
  
  const result = await processor.processBooksInBatches(
    generateTestBooks(5000), 
    mockProcessor,
    null
  )
  
  expect(result.length).toBe(5000)
})
```

#### 效能基準持續監控

**自動化效能測試**：
```javascript
// performance/sync-benchmarks.test.js
const PERFORMANCE_THRESHOLDS = {
  smallDataset: { books: 50, maxTime: 15000 },    // 15秒
  mediumDataset: { books: 500, maxTime: 45000 },  // 45秒
  largeDataset: { books: 2000, maxTime: 90000 },  // 90秒
  hugeDataset: { books: 8000, maxTime: 180000 }   // 3分鐘
}

describe('Sync Performance Benchmarks', () => {
  Object.entries(PERFORMANCE_THRESHOLDS).forEach(([size, config]) => {
    test(`${size} should complete within ${config.maxTime}ms`, async () => {
      const books = generateTestBooks(config.books)
      const startTime = Date.now()
      
      const result = await executeFullSync(sourceDevice, targetDevice)
      
      const duration = Date.now() - startTime
      expect(duration).toBeLessThan(config.maxTime)
      expect(result.success).toBe(true)
    })
  })
})
```

### 🎯 實作完成標準與交接檢查點

#### 45個測試100%通過驗證

**分類驗證策略**：
```bash
# 分類執行測試，確保各類別100%通過
npm test -- --testPathPattern="cross-device-sync" --grep="完整同步流程"  # 1-8
npm test -- --testPathPattern="cross-device-sync" --grep="資料完整性"    # 9-18  
npm test -- --testPathPattern="cross-device-sync" --grep="效能和擴展性"   # 19-26
npm test -- --testPathPattern="cross-device-sync" --grep="錯誤處理"      # 27-38
npm test -- --testPathPattern="cross-device-sync" --grep="跨設備一致性"   # 39-45
```

**回歸測試確保**：
```javascript
// 確保新功能不影響現有功能
describe('Regression Tests for UC-05', () => {
  test('不應該影響現有匯出功能', async () => {
    const exportResult = await exportService.exportData(testBooks, 'json')
    expect(exportResult.success).toBe(true)
  })

  test('不應該影響現有匯入功能', async () => {
    const importResult = await importService.importData(testData)
    expect(importResult.success).toBe(true)
  })
})
```

#### 實作品質最終檢查

**程式碼覆蓋率**：
- **行覆蓋率**: ≥90%
- **分支覆蓋率**: ≥85%  
- **函數覆蓋率**: 100%
- **語句覆蓋率**: ≥90%

**效能達標檢查**：
```javascript
// 所有效能基準必須達標
const performanceValidation = {
  smallDataset: { threshold: 15000, actual: result.timing.total },
  memoryUsage: { threshold: 200*1024*1024, actual: result.memoryUsage.peak },
  throughput: { threshold: 50, actual: result.throughput }
}

Object.entries(performanceValidation).forEach(([metric, data]) => {
  assert(data.actual < data.threshold, `${metric}效能不達標`)
})
```

#### TDD Phase 4交接準備

**重構準備清單**:
- [ ] 所有//todo:標註已記錄，包含具體改善方向
- [ ] 權宜方案已識別並標註改善優先級
- [ ] 程式碼品質債務已列出，包含Five Lines規則違反點
- [ ] 架構優化點已識別，包含依賴注入和介面統一
- [ ] 效能優化機會已記錄，包含記憶體和處理速度改善

**移交工作日誌更新**：
```markdown
## Phase 3 實作完成總結

### 目標達成情況
- [x] 45個測試案例100%通過  
- [x] UC-05功能完整實作
- [x] 與現有UC-03/UC-04整合完成
- [x] Chrome Extension環境適配完成

### 技術債務記錄  
- 權宜方案: 12個，包含狀態管理簡化、衝突解決基礎版
- //todo:改善: 18個，包含效能、UX、安全性改善
- 架構債務: 5個，包含模組職責拆分、API統一

### Phase 4重構建議
1. CrossDeviceSyncService職責拆分 (Five Lines規則)
2. 錯誤處理模式統一 (單一職責原則)  
3. 效能監控系統重構 (可維護性提升)
4. UI回饋機制優化 (使用者體驗改善)
```

---

## 🔄 TDD Phase 3 完成總結

### 實作策略完整度檢查

**✅ 完成的實作規劃要素**:
- [x] **實作策略設計**: 完整的4階段漸進式實作計劃，整合現有架構
- [x] **詳細實作指引**: 提供step-by-step編碼指引和核心程式碼範例  
- [x] **權宜方案與技術債務**: 明確標註最小可用實作和改善方向
- [x] **驗證與品質保證**: 建立45個測試100%通過的具體驗證策略

**🎯 實作規劃核心特色**:
1. **現有架構整合**: 重用ExportService、ErrorHandler等既有組件，避免重複開發
2. **Chrome Extension適配**: 針對Manifest V3環境特殊限制提供具體解決方案
3. **測試驅動設計**: 每個實作決策都明確對應測試需求，確保100%通過率
4. **漸進式實作**: 分5個階段實作，每階段都有明確目標和驗證點

### 交接給主線程實作的準備狀況

**📋 為主線程提供的實作資產**:

**完整程式碼範例** (1500+行):
- CrossDeviceSyncService核心服務實作範例  
- DataIntegrityValidator完整性驗證實作範例
- SyncErrorHandler錯誤處理擴展範例
- BatchProcessor效能優化實作範例

**具體實作步驟**:
- 階段1-5詳細實作計劃，每階段對應8-10個測試
- 檔案結構設計和模組分工明確定義
- 與現有服務整合的具體介面和方法

**技術債務管理**:
- 30+個//todo:標註，包含具體改善方向和優先級
- 權宜方案明確識別，為Phase 4重構提供清楚目標  
- 已知限制記錄完整，包含Chrome Extension和架構限制

**品質保證機制**:
- 45個測試100%通過的具體驗證策略
- 效能基準達標的監控機制
- 程式碼品質檢查要求和工具配置

### 下一階段工作重點建議

**💻 主線程實作關鍵任務**:
1. **按階段循序實作**: 嚴格按照階段1-5順序實作，每完成一階段驗證對應測試
2. **重用現有架構**: 充分利用ExportService、ErrorHandler等既有組件
3. **Chrome Extension API整合**: 重點處理chrome.storage API和Service Worker限制
4. **效能監控實作**: 建立效能基準測試，確保所有基準達標

**🏗️ TDD Phase 4 (重構設計師) 預期重構點**:
1. **Five Lines規則應用**: CrossDeviceSyncService等複雜類別需要職責拆分
2. **單一職責原則**: 錯誤處理、狀態管理等模組職責進一步明確化  
3. **效能優化重構**: 記憶體管理、批次處理機制的深度優化
4. **使用者體驗改善**: 進度指示、錯誤處理的UI交互優化

**最終目標達成指標**:
- 測試覆蓋率: 0% → 90%+
- 功能完整性: UC-05端到端測試100%通過
- 整體專案測試覆蓋率提升: 85% → 88%
- 效能基準: 所有資料集規模的效能測試達標
- 程式碼品質: 符合專案標準，準備Phase 4重構

---

**📚 文件合規聲明**: 
本實作規劃章節嚴格遵循「📚 專案文件責任明確區分」標準，內容為詳細的實作策略分析和開發指引記錄，專門服務於協作者知識交換和主線程實作指導。所有實作規劃都有完整的策略思考和程式碼範例，確保主線程能夠按照規劃順利實作UC-05跨設備同步功能。

**版本**: v0.9.33  
**階段完成時間**: 2025-08-24  
**下一階段**: 主線程實作 → cinnamon-refactor-owl (TDD Phase 4 - 程式碼品質改善)