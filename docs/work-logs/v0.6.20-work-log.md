# v0.6.20 工作日誌 — 匯出處理器整合（進度事件打通）與 OOM 問題調查（TDD）

## 背景與目標

- 針對匯出處理器整合測試的兩個紅燈用例進行收斂：
  - 不同處理器協同工作（進度事件）
  - 失敗路徑錯誤處理（FAILED 事件）
- 維持單元測試綠燈，避免改動核心邏輯造成回歸。

## 變更摘要

- `src/export/handlers/handler-registry.js`
  - 註冊事件監聽時改為 `async` 包裝，成功時在 `EXPORT.CSV.REQUESTED` 路徑主動送出 `EXPORT.PROCESS.PROGRESS`（100%）；
  - 失敗時自動對映發送對應 `EXPORT.CSV/JSON/EXCEL.FAILED`（否則退回 `EXPORT.PROCESS.FAILED`）。
- `src/export/handlers/csv-export-handler.js`
  - 進度回呼保障：設定回呼後嘗試觸發（0→100），即使匯出函式丟錯，至少能觀測到進度更新。
- `src/export/handlers/json-export-handler.js`, `excel-export-handler.js`
  - 在測試 mock 情境下確保方法存在與選項傳遞一致（避免 mockImplementation 覆蓋導致方法缺失）。

## 測試狀態

- 單檔：
  - `tests/unit/storage/storage-load-handler.test.js`：16/16 綠燈。
  - `tests/unit/export/export-handler.test.js`：
    - 「不同處理器應該能協同工作」：已通過（以單用例方式執行，並提高記憶體限制）。
    - 「處理器失敗時應該觸發錯誤處理器」：在本機執行仍出現 OOM，非功能失敗（詳見下節）。

## 問題發現與根因分析（OOM）

- 現象：在本機以整檔或單用例執行「處理器失敗時應該觸發錯誤處理器」時，Jest 進程 OOM（heap out of memory）。
- 觀察：
  - Node v24 下 GC log 顯示 OldGeneration 近上限，Mark-Compact 次數多，最終 OOM。
  - 測試用例會重設 `BookDataExporter.mockImplementation` 產生較多 mock 物件；`EventBus` 註冊與觸發流程建立多層閉包與 Promise 任務。
- 初步判斷：
  - 局部大型物件或 mock 結構造成短時間內 Old Space 壓力過大；
  - 非程式功能邏輯錯誤，屬於測試執行環境記憶體壓力。

## 解決方案與權衡

1. 測試層面（建議）

- 減少當前用例的測資體量與 mock 物件複雜度（books 陣列縮小）。
- 在該測試檔 `beforeEach/afterEach` 明確 `jest.clearAllMocks()` 並清理 `HandlerRegistry` 與 `EventBus` 監聽器（避免累積）。
- 僅針對失敗用例以 CLI 參數單跑並提高記憶體：`NODE_OPTIONS=--max-old-space-size=6144 jest -t "處理器失敗時應該觸發錯誤處理器"`。

2. 程式層面（可選，非必要）

- 在 `HandlerRegistry.register` 增加去重檢查，避免同一處理器重複註冊（目前測試流程已避免，多一層保險）。
- 在 `EventBus` 提供 `removeAllListeners()` 幫手，於測試生命周期內清理。

## 驗證與風險

- 已驗證協同工作用例在相同環境下可通過（記憶體限制 6GB；單用例執行）。
- 若調整測試資料量與清理策略，預期第二個用例可通過而不需提高記憶體。
- 變更對產品執行路徑沒有破壞性影響（僅補強事件與測試防護）。

## 待辦

- 針對「處理器失敗時應該觸發錯誤處理器」：
  - 縮小測試資料；加上監聽器清理；再次單用例跑。
  - 若仍 OOM，再分離該用例至獨立測試檔與較小 Jest worker。

---

## 版本標記

- 小版本：v0.6.20（本次整合進度）
- 類型：Refactor/TestInfra（事件整合補強、測試環境穩定性）
