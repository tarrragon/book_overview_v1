# ğŸ­ äº‹ä»¶é©…å‹•ç³»çµ±æ¶æ§‹è¨­è¨ˆ

## ğŸ“– æ¦‚è¿°

æœ¬æ–‡ä»¶è©³ç´°æè¿°äº†Readmooæ›¸åº«æ•¸æ“šæå–å™¨Chrome Extensionçš„äº‹ä»¶é©…å‹•æ¶æ§‹è¨­è¨ˆã€‚è©²æ¶æ§‹æ—¨åœ¨å¯¦ç¾é«˜å…§èšä½è€¦åˆçš„æ¨¡çµ„åŒ–ç³»çµ±ï¼Œç¢ºä¿å„çµ„ä»¶ä¹‹é–“é€éæ˜ç¢ºå®šç¾©çš„äº‹ä»¶é€²è¡Œé€šè¨Šã€‚

## ğŸ¯ è¨­è¨ˆç›®æ¨™

### ä¸»è¦ç›®æ¨™

- **é¬†è€¦åˆ**ï¼šå„æ¨¡çµ„ä¹‹é–“é€éäº‹ä»¶é€šè¨Šï¼Œæ¸›å°‘ç›´æ¥ä¾è³´
- **é«˜å…§èš**ï¼šæ¯å€‹æ¨¡çµ„å°ˆæ³¨æ–¼è‡ªå·±çš„è·è²¬
- **å¯æ“´å±•æ€§**ï¼šæ–°åŠŸèƒ½å¯ä»¥é€éæ–°å¢äº‹ä»¶è™•ç†å™¨è¼•é¬†æ•´åˆ
- **å¯æ¸¬è©¦æ€§**ï¼šäº‹ä»¶é©…å‹•çš„è¨­è¨ˆä¾¿æ–¼å–®å…ƒæ¸¬è©¦å’Œæ•´åˆæ¸¬è©¦
- **å¯ç¶­è­·æ€§**ï¼šæ¸…æ™°çš„äº‹ä»¶æµç¨‹ä¾¿æ–¼ç†è§£å’Œç¶­è­·

### æ¬¡è¦ç›®æ¨™

- **éŒ¯èª¤éš”é›¢**ï¼šä¸€å€‹æ¨¡çµ„çš„éŒ¯èª¤ä¸æœƒå½±éŸ¿å…¶ä»–æ¨¡çµ„
- **æ•ˆèƒ½å„ªåŒ–**ï¼šéåŒæ­¥äº‹ä»¶è™•ç†é¿å…é˜»å¡
- **èª¿è©¦å‹å¥½**ï¼šäº‹ä»¶æµç¨‹å¯è¿½è¹¤å’Œè¨˜éŒ„

## ğŸ— æ¶æ§‹æ¦‚è¦½

### æ ¸å¿ƒçµ„ä»¶

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    äº‹ä»¶é©…å‹•æ¶æ§‹æ ¸å¿ƒ                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Event Bus (äº‹ä»¶ç¸½ç·š)                                       â”‚
â”‚  â”œâ”€â”€ Event Registry (äº‹ä»¶è¨»å†Šè¡¨)                           â”‚
â”‚  â”œâ”€â”€ Event Dispatcher (äº‹ä»¶åˆ†ç™¼å™¨)                         â”‚
â”‚  â””â”€â”€ Event Logger (äº‹ä»¶è¨˜éŒ„å™¨)                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Event Publishers (äº‹ä»¶ç™¼å¸ƒè€…)                             â”‚
â”‚  â”œâ”€â”€ User Actions (ä½¿ç”¨è€…æ“ä½œ)                             â”‚
â”‚  â”œâ”€â”€ Chrome APIs (Chrome API å›èª¿)                         â”‚
â”‚  â”œâ”€â”€ DOM Changes (DOM è®ŠåŒ–)                                â”‚
â”‚  â””â”€â”€ Timer Events (å®šæ™‚å™¨äº‹ä»¶)                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Event Handlers (äº‹ä»¶è™•ç†å™¨)                               â”‚
â”‚  â”œâ”€â”€ Data Extraction Handlers (è³‡æ–™æå–è™•ç†å™¨)             â”‚
â”‚  â”œâ”€â”€ Storage Handlers (å„²å­˜è™•ç†å™¨)                         â”‚
â”‚  â”œâ”€â”€ UI Update Handlers (UIæ›´æ–°è™•ç†å™¨)                     â”‚
â”‚  â””â”€â”€ Error Handlers (éŒ¯èª¤è™•ç†å™¨)                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Event Listeners (äº‹ä»¶ç›£è½å™¨)                              â”‚
â”‚  â”œâ”€â”€ Background Listeners (èƒŒæ™¯ç›£è½å™¨)                     â”‚
â”‚  â”œâ”€â”€ Content Script Listeners (å…§å®¹è…³æœ¬ç›£è½å™¨)             â”‚
â”‚  â”œâ”€â”€ Popup Listeners (å½ˆå‡ºè¦–çª—ç›£è½å™¨)                       â”‚
â”‚  â””â”€â”€ Overview Listeners (ç€è¦½é é¢ç›£è½å™¨)                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“‹ äº‹ä»¶åˆ†é¡ç³»çµ±

### äº‹ä»¶å‘½åè¦ç¯„

æ¡ç”¨ `æ¨¡çµ„.å‹•ä½œ.ç‹€æ…‹` çš„ä¸‰å±¤å‘½åçµæ§‹ï¼š

```javascript
// æ ¼å¼ï¼š[MODULE].[ACTION].[STATE]
// ç¯„ä¾‹ï¼š
'data.extract.started'      // è³‡æ–™æå–é–‹å§‹
'data.extract.progress'     // è³‡æ–™æå–é€²åº¦
'data.extract.completed'    // è³‡æ–™æå–å®Œæˆ
'data.extract.failed'       // è³‡æ–™æå–å¤±æ•—

'storage.save.requested'    // å„²å­˜è«‹æ±‚
'storage.save.completed'    // å„²å­˜å®Œæˆ
'storage.save.failed'       // å„²å­˜å¤±æ•—

'ui.popup.opened'          // å½ˆå‡ºè¦–çª—é–‹å•Ÿ
'ui.popup.closed'          // å½ˆå‡ºè¦–çª—é—œé–‰
'ui.overview.rendered'     // ç€è¦½é é¢æ¸²æŸ“å®Œæˆ
```

### äº‹ä»¶å„ªå…ˆç´š

```javascript
const EVENT_PRIORITY = {
  CRITICAL: 0,    // é—œéµäº‹ä»¶ï¼ˆéŒ¯èª¤ã€å®‰å…¨ç›¸é—œï¼‰
  HIGH: 1,        // é«˜å„ªå…ˆç´šï¼ˆä½¿ç”¨è€…æ“ä½œå›æ‡‰ï¼‰
  NORMAL: 2,      // ä¸€èˆ¬å„ªå…ˆç´šï¼ˆè³‡æ–™è™•ç†ï¼‰
  LOW: 3          // ä½å„ªå…ˆç´šï¼ˆçµ±è¨ˆã€æ—¥èªŒï¼‰
};
```

## ğŸ”„ äº‹ä»¶ç”Ÿå‘½é€±æœŸ

### äº‹ä»¶æµç¨‹åœ–

```mermaid
graph TD
    A[äº‹ä»¶è§¸ç™¼] --> B[äº‹ä»¶é©—è­‰]
    B --> C{é©—è­‰é€šé?}
    C -->|æ˜¯| D[äº‹ä»¶åˆ†ç™¼]
    C -->|å¦| E[è¨˜éŒ„éŒ¯èª¤]
    D --> F[å°‹æ‰¾è™•ç†å™¨]
    F --> G{æ‰¾åˆ°è™•ç†å™¨?}
    G -->|æ˜¯| H[åŸ·è¡Œè™•ç†å™¨]
    G -->|å¦| I[è¨˜éŒ„è­¦å‘Š]
    H --> J{åŸ·è¡ŒæˆåŠŸ?}
    J -->|æ˜¯| K[è§¸ç™¼æˆåŠŸäº‹ä»¶]
    J -->|å¦| L[è§¸ç™¼éŒ¯èª¤äº‹ä»¶]
    K --> M[æ¸…ç†è³‡æº]
    L --> N[éŒ¯èª¤è™•ç†]
    N --> M
    I --> M
    E --> M
    M --> O[äº‹ä»¶å®Œæˆ]
```

### è©³ç´°ç”Ÿå‘½é€±æœŸéšæ®µ

1. **äº‹ä»¶å‰µå»º** (Event Creation)
   - å®šç¾©äº‹ä»¶é¡å‹å’Œè³‡æ–™
   - è¨­å®šå„ªå…ˆç´šå’Œæ™‚é–“æˆ³
   - åˆ†é…å”¯ä¸€äº‹ä»¶ID

2. **äº‹ä»¶é©—è­‰** (Event Validation)
   - æª¢æŸ¥äº‹ä»¶æ ¼å¼
   - é©—è­‰å¿…è¦æ¬„ä½
   - æª¢æŸ¥æ¬Šé™å’Œå®‰å…¨æ€§

3. **äº‹ä»¶åˆ†ç™¼** (Event Dispatching)
   - æŸ¥æ‰¾è¨»å†Šçš„è™•ç†å™¨
   - æŒ‰å„ªå…ˆç´šæ’åº
   - å»ºç«‹åŸ·è¡Œä½‡åˆ—

4. **è™•ç†å™¨åŸ·è¡Œ** (Handler Execution)
   - ä¾åºåŸ·è¡Œè™•ç†å™¨
   - ç›£æ§åŸ·è¡Œæ™‚é–“
   - è™•ç†ä¾‹å¤–å’ŒéŒ¯èª¤

5. **çµæœè™•ç†** (Result Processing)
   - æ”¶é›†è™•ç†çµæœ
   - è§¸ç™¼å¾ŒçºŒäº‹ä»¶
   - æ›´æ–°ç³»çµ±ç‹€æ…‹

6. **è³‡æºæ¸…ç†** (Resource Cleanup)
   - é‡‹æ”¾è¨˜æ†¶é«”
   - æ¸…ç†æš«å­˜æª”æ¡ˆ
   - é‡ç½®è™•ç†å™¨ç‹€æ…‹

## ğŸ“Š äº‹ä»¶è³‡æ–™çµæ§‹

### æ¨™æº–äº‹ä»¶æ ¼å¼

```javascript
/**
 * æ¨™æº–äº‹ä»¶ç‰©ä»¶çµæ§‹
 */
class Event {
  constructor(type, data = {}, options = {}) {
    this.id = generateEventId();
    this.type = type;
    this.data = data;
    this.timestamp = new Date().toISOString();
    this.priority = options.priority || EVENT_PRIORITY.NORMAL;
    this.source = options.source || 'unknown';
    this.correlationId = options.correlationId || null;
    this.metadata = {
      version: '1.0',
      schema: 'standard-event',
      ...options.metadata
    };
  }

  /**
   * åºåˆ—åŒ–äº‹ä»¶ç‚ºJSON
   */
  toJSON() {
    return {
      id: this.id,
      type: this.type,
      data: this.data,
      timestamp: this.timestamp,
      priority: this.priority,
      source: this.source,
      correlationId: this.correlationId,
      metadata: this.metadata
    };
  }

  /**
   * æª¢æŸ¥äº‹ä»¶æ˜¯å¦å¯ä»¥å–æ¶ˆ
   */
  isCancellable() {
    return this.type.endsWith('.requested') || 
           this.type.endsWith('.started');
  }
}
```

### ç‰¹å®šäº‹ä»¶é¡å‹

```javascript
// è³‡æ–™æå–äº‹ä»¶
const DataExtractionEvent = {
  STARTED: 'data.extract.started',
  PROGRESS: 'data.extract.progress',
  COMPLETED: 'data.extract.completed',
  FAILED: 'data.extract.failed',
  
  // äº‹ä»¶è³‡æ–™çµæ§‹
  createStartedEvent: (url, options) => new Event(
    DataExtractionEvent.STARTED,
    { url, options },
    { priority: EVENT_PRIORITY.HIGH }
  ),
  
  createProgressEvent: (progress, total) => new Event(
    DataExtractionEvent.PROGRESS,
    { progress, total, percentage: (progress / total) * 100 },
    { priority: EVENT_PRIORITY.NORMAL }
  )
};

// å„²å­˜äº‹ä»¶
const StorageEvent = {
  SAVE_REQUESTED: 'storage.save.requested',
  SAVE_COMPLETED: 'storage.save.completed',
  SAVE_FAILED: 'storage.save.failed',
  LOAD_REQUESTED: 'storage.load.requested',
  LOAD_COMPLETED: 'storage.load.completed',
  LOAD_FAILED: 'storage.load.failed'
};

// UIäº‹ä»¶
const UIEvent = {
  POPUP_OPENED: 'ui.popup.opened',
  POPUP_CLOSED: 'ui.popup.closed',
  OVERVIEW_RENDERED: 'ui.overview.rendered',
  SEARCH_PERFORMED: 'ui.search.performed',
  EXPORT_REQUESTED: 'ui.export.requested'
};
```

## ğŸ”§ äº‹ä»¶è™•ç†å™¨è¨­è¨ˆ

### è™•ç†å™¨ä»‹é¢è¦ç¯„

```javascript
/**
 * äº‹ä»¶è™•ç†å™¨åŸºåº•é¡åˆ¥
 */
class EventHandler {
  constructor(name, priority = EVENT_PRIORITY.NORMAL) {
    this.name = name;
    this.priority = priority;
    this.isEnabled = true;
    this.executionCount = 0;
    this.lastExecutionTime = null;
    this.averageExecutionTime = 0;
  }

  /**
   * è™•ç†äº‹ä»¶çš„ä¸»è¦æ–¹æ³•
   * @param {Event} event - è¦è™•ç†çš„äº‹ä»¶
   * @returns {Promise<any>} è™•ç†çµæœ
   */
  async handle(event) {
    if (!this.isEnabled) {
      return null;
    }

    const startTime = Date.now();
    this.executionCount++;

    try {
      // é è™•ç†
      await this.beforeHandle(event);
      
      // ä¸»è¦è™•ç†é‚è¼¯
      const result = await this.process(event);
      
      // å¾Œè™•ç†
      await this.afterHandle(event, result);
      
      return result;
    } catch (error) {
      await this.onError(event, error);
      throw error;
    } finally {
      // æ›´æ–°çµ±è¨ˆè³‡è¨Š
      const executionTime = Date.now() - startTime;
      this.updateStats(executionTime);
    }
  }

  /**
   * å¯¦éš›çš„è™•ç†é‚è¼¯ - å­é¡åˆ¥å¿…é ˆå¯¦ç¾
   */
  async process(event) {
    throw new Error('Process method must be implemented by subclass');
  }

  /**
   * è™•ç†å‰çš„æº–å‚™å·¥ä½œ
   */
  async beforeHandle(event) {
    // é è¨­å¯¦ç¾ï¼šè¨˜éŒ„æ—¥èªŒ
    console.log(`[${this.name}] Processing event: ${event.type}`);
  }

  /**
   * è™•ç†å¾Œçš„æ¸…ç†å·¥ä½œ
   */
  async afterHandle(event, result) {
    // é è¨­å¯¦ç¾ï¼šè¨˜éŒ„çµæœ
    console.log(`[${this.name}] Completed event: ${event.type}`);
  }

  /**
   * éŒ¯èª¤è™•ç†
   */
  async onError(event, error) {
    console.error(`[${this.name}] Error processing event: ${event.type}`, error);
  }

  /**
   * æ›´æ–°åŸ·è¡Œçµ±è¨ˆ
   */
  updateStats(executionTime) {
    this.lastExecutionTime = executionTime;
    this.averageExecutionTime = 
      (this.averageExecutionTime * (this.executionCount - 1) + executionTime) / 
      this.executionCount;
  }

  /**
   * æª¢æŸ¥æ˜¯å¦å¯ä»¥è™•ç†æŒ‡å®šäº‹ä»¶
   */
  canHandle(eventType) {
    return this.getSupportedEvents().includes(eventType);
  }

  /**
   * å–å¾—æ”¯æ´çš„äº‹ä»¶é¡å‹ - å­é¡åˆ¥å¿…é ˆå¯¦ç¾
   */
  getSupportedEvents() {
    throw new Error('getSupportedEvents method must be implemented by subclass');
  }

  /**
   * å•Ÿç”¨/åœç”¨è™•ç†å™¨
   */
  setEnabled(enabled) {
    this.isEnabled = enabled;
  }

  /**
   * å–å¾—è™•ç†å™¨çµ±è¨ˆè³‡è¨Š
   */
  getStats() {
    return {
      name: this.name,
      executionCount: this.executionCount,
      lastExecutionTime: this.lastExecutionTime,
      averageExecutionTime: this.averageExecutionTime,
      isEnabled: this.isEnabled
    };
  }
}
```

### å…·é«”è™•ç†å™¨å¯¦ç¾ç¯„ä¾‹

```javascript
/**
 * è³‡æ–™æå–è™•ç†å™¨
 */
class DataExtractionHandler extends EventHandler {
  constructor() {
    super('DataExtractionHandler', EVENT_PRIORITY.HIGH);
    this.extractor = null;
  }

  getSupportedEvents() {
    return [
      DataExtractionEvent.STARTED,
      'tab.updated.readmoo'
    ];
  }

  async process(event) {
    switch (event.type) {
      case DataExtractionEvent.STARTED:
        return await this.handleExtractionStart(event);
      case 'tab.updated.readmoo':
        return await this.handleTabUpdate(event);
      default:
        throw new Error(`Unsupported event type: ${event.type}`);
    }
  }

  async handleExtractionStart(event) {
    const { url, options } = event.data;
    
    // å»ºç«‹é€²åº¦è¿½è¹¤
    const progressTracker = new ProgressTracker();
    
    // åˆå§‹åŒ–æå–å™¨
    this.extractor = new BookDataExtractor(options);
    
    // åŸ·è¡Œæå–
    const books = await this.extractor.extract(url, (progress) => {
      // ç™¼å¸ƒé€²åº¦äº‹ä»¶
      eventBus.publish(
        DataExtractionEvent.createProgressEvent(progress.current, progress.total)
      );
    });

    // ç™¼å¸ƒå®Œæˆäº‹ä»¶
    eventBus.publish(new Event(
      DataExtractionEvent.COMPLETED,
      { books, extractedAt: new Date().toISOString() },
      { correlationId: event.id }
    ));

    return books;
  }

  async handleTabUpdate(event) {
    const { tabId, changeInfo, tab } = event.data;
    
    if (changeInfo.status === 'complete' && 
        tab.url.includes('readmoo.com/library')) {
      // è‡ªå‹•è§¸ç™¼è³‡æ–™æå–
      eventBus.publish(DataExtractionEvent.createStartedEvent(tab.url));
    }
  }
}

/**
 * å„²å­˜è™•ç†å™¨
 */
class StorageHandler extends EventHandler {
  constructor() {
    super('StorageHandler', EVENT_PRIORITY.NORMAL);
    this.storageAdapter = new ChromeStorageAdapter();
  }

  getSupportedEvents() {
    return [
      StorageEvent.SAVE_REQUESTED,
      StorageEvent.LOAD_REQUESTED,
      DataExtractionEvent.COMPLETED
    ];
  }

  async process(event) {
    switch (event.type) {
      case StorageEvent.SAVE_REQUESTED:
        return await this.handleSaveRequest(event);
      case StorageEvent.LOAD_REQUESTED:
        return await this.handleLoadRequest(event);
      case DataExtractionEvent.COMPLETED:
        return await this.handleAutoSave(event);
      default:
        throw new Error(`Unsupported event type: ${event.type}`);
    }
  }

  async handleSaveRequest(event) {
    const { key, data, options } = event.data;
    
    try {
      await this.storageAdapter.save(key, data, options);
      
      eventBus.publish(new Event(
        StorageEvent.SAVE_COMPLETED,
        { key, timestamp: new Date().toISOString() },
        { correlationId: event.id }
      ));
      
      return { success: true };
    } catch (error) {
      eventBus.publish(new Event(
        StorageEvent.SAVE_FAILED,
        { key, error: error.message },
        { correlationId: event.id }
      ));
      
      throw error;
    }
  }

  async handleAutoSave(event) {
    const { books } = event.data;
    
    // è‡ªå‹•å„²å­˜æå–çš„æ›¸ç±è³‡æ–™
    return await this.handleSaveRequest(new Event(
      StorageEvent.SAVE_REQUESTED,
      { 
        key: 'extracted_books', 
        data: books,
        options: { autoSave: true }
      }
    ));
  }
}
```

## ğŸŒ è·¨æ¨¡çµ„é€šè¨Š

### Chrome Extension æ¨¡çµ„é–“é€šè¨Š

```javascript
/**
 * Chrome Extension äº‹ä»¶æ©‹æ¥å™¨
 * è™•ç†ä¸åŒè…³æœ¬ç’°å¢ƒä¹‹é–“çš„äº‹ä»¶é€šè¨Š
 */
class ChromeEventBridge {
  constructor() {
    this.messageHandlers = new Map();
    this.setupMessageListeners();
  }

  /**
   * è¨­å®šChrome Runtimeæ¶ˆæ¯ç›£è½å™¨
   */
  setupMessageListeners() {
    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      if (message.type === 'CROSS_CONTEXT_EVENT') {
        this.handleCrossContextEvent(message, sender, sendResponse);
        return true; // ä¿æŒæ¶ˆæ¯é€šé“é–‹å•Ÿ
      }
    });
  }

  /**
   * è™•ç†è·¨ä¸Šä¸‹æ–‡äº‹ä»¶
   */
  async handleCrossContextEvent(message, sender, sendResponse) {
    const { event, targetContext } = message.data;
    
    try {
      // åœ¨ç›®æ¨™ä¸Šä¸‹æ–‡ä¸­è§¸ç™¼äº‹ä»¶
      const result = await this.dispatchToContext(event, targetContext);
      sendResponse({ success: true, result });
    } catch (error) {
      sendResponse({ success: false, error: error.message });
    }
  }

  /**
   * å°‡äº‹ä»¶åˆ†ç™¼åˆ°æŒ‡å®šä¸Šä¸‹æ–‡
   */
  async dispatchToContext(event, targetContext) {
    switch (targetContext) {
      case 'background':
        return await this.dispatchToBackground(event);
      case 'content':
        return await this.dispatchToContent(event);
      case 'popup':
        return await this.dispatchToPopup(event);
      default:
        throw new Error(`Unknown target context: ${targetContext}`);
    }
  }

  /**
   * ç™¼é€äº‹ä»¶åˆ°èƒŒæ™¯è…³æœ¬
   */
  async dispatchToBackground(event) {
    return new Promise((resolve, reject) => {
      chrome.runtime.sendMessage({
        type: 'BACKGROUND_EVENT',
        event
      }, (response) => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else {
          resolve(response);
        }
      });
    });
  }

  /**
   * ç™¼é€äº‹ä»¶åˆ°å…§å®¹è…³æœ¬
   */
  async dispatchToContent(event) {
    const tabs = await this.getReadmooTabs();
    const results = [];
    
    for (const tab of tabs) {
      try {
        const result = await this.sendToTab(tab.id, {
          type: 'CONTENT_EVENT',
          event
        });
        results.push(result);
      } catch (error) {
        console.warn(`Failed to send event to tab ${tab.id}:`, error);
      }
    }
    
    return results;
  }

  /**
   * å–å¾—Readmooç›¸é—œçš„åˆ†é 
   */
  async getReadmooTabs() {
    return new Promise((resolve) => {
      chrome.tabs.query({
        url: ['*://readmoo.com/*', '*://*.readmoo.com/*']
      }, resolve);
    });
  }

  /**
   * ç™¼é€æ¶ˆæ¯åˆ°æŒ‡å®šåˆ†é 
   */
  async sendToTab(tabId, message) {
    return new Promise((resolve, reject) => {
      chrome.tabs.sendMessage(tabId, message, (response) => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
        } else {
          resolve(response);
        }
      });
    });
  }
}
```

## ğŸ“ˆ æ•ˆèƒ½ç›£æ§èˆ‡å„ªåŒ–

### äº‹ä»¶æ•ˆèƒ½ç›£æ§

```javascript
/**
 * äº‹ä»¶æ•ˆèƒ½ç›£æ§å™¨
 */
class EventPerformanceMonitor {
  constructor() {
    this.metrics = new Map();
    this.thresholds = {
      warning: 1000,  // 1ç§’
      critical: 5000  // 5ç§’
    };
  }

  /**
   * é–‹å§‹ç›£æ§äº‹ä»¶
   */
  startMonitoring(event) {
    const eventId = event.id;
    this.metrics.set(eventId, {
      event,
      startTime: performance.now(),
      handlers: []
    });
  }

  /**
   * è¨˜éŒ„è™•ç†å™¨åŸ·è¡Œæ™‚é–“
   */
  recordHandlerExecution(eventId, handlerName, executionTime) {
    const metric = this.metrics.get(eventId);
    if (metric) {
      metric.handlers.push({
        name: handlerName,
        executionTime
      });
    }
  }

  /**
   * å®Œæˆäº‹ä»¶ç›£æ§
   */
  completeMonitoring(eventId) {
    const metric = this.metrics.get(eventId);
    if (!metric) return;

    const totalTime = performance.now() - metric.startTime;
    metric.totalTime = totalTime;
    metric.completedAt = new Date().toISOString();

    // æª¢æŸ¥æ˜¯å¦è¶…éé–¾å€¼
    if (totalTime > this.thresholds.critical) {
      this.reportCriticalPerformance(metric);
    } else if (totalTime > this.thresholds.warning) {
      this.reportWarningPerformance(metric);
    }

    // æ¸…ç†èˆŠçš„ç›£æ§è³‡æ–™
    this.metrics.delete(eventId);
  }

  /**
   * å ±å‘Šé—œéµæ•ˆèƒ½å•é¡Œ
   */
  reportCriticalPerformance(metric) {
    console.error('Critical performance issue detected:', {
      eventType: metric.event.type,
      totalTime: metric.totalTime,
      handlers: metric.handlers
    });
    
    // ç™¼é€æ•ˆèƒ½è­¦å‘Šäº‹ä»¶
    eventBus.publish(new Event(
      'system.performance.critical',
      { metric },
      { priority: EVENT_PRIORITY.CRITICAL }
    ));
  }

  /**
   * å ±å‘Šæ•ˆèƒ½è­¦å‘Š
   */
  reportWarningPerformance(metric) {
    console.warn('Performance warning:', {
      eventType: metric.event.type,
      totalTime: metric.totalTime
    });
  }

  /**
   * å–å¾—æ•ˆèƒ½çµ±è¨ˆ
   */
  getPerformanceStats() {
    const activeEvents = Array.from(this.metrics.values());
    return {
      activeEventsCount: activeEvents.length,
      longestRunningEvent: activeEvents.reduce((longest, current) => {
        const currentRunTime = performance.now() - current.startTime;
        return currentRunTime > longest.runTime ? 
          { event: current.event, runTime: currentRunTime } : 
          longest;
      }, { runTime: 0 })
    };
  }
}
```

## ğŸ›¡ éŒ¯èª¤è™•ç†èˆ‡å¾©åŸ

### éŒ¯èª¤è™•ç†ç­–ç•¥

```javascript
/**
 * äº‹ä»¶éŒ¯èª¤è™•ç†å™¨
 */
class EventErrorHandler extends EventHandler {
  constructor() {
    super('EventErrorHandler', EVENT_PRIORITY.CRITICAL);
    this.errorCounts = new Map();
    this.circuitBreaker = new Map();
  }

  getSupportedEvents() {
    return [
      'system.error.occurred',
      'handler.execution.failed',
      'event.processing.timeout'
    ];
  }

  async process(event) {
    switch (event.type) {
      case 'system.error.occurred':
        return await this.handleSystemError(event);
      case 'handler.execution.failed':
        return await this.handleHandlerFailure(event);
      case 'event.processing.timeout':
        return await this.handleProcessingTimeout(event);
    }
  }

  /**
   * è™•ç†ç³»çµ±éŒ¯èª¤
   */
  async handleSystemError(event) {
    const { error, context, severity } = event.data;
    
    // è¨˜éŒ„éŒ¯èª¤
    this.logError(error, context, severity);
    
    // æ ¹æ“šåš´é‡ç¨‹åº¦æ±ºå®šè™•ç†ç­–ç•¥
    switch (severity) {
      case 'critical':
        await this.handleCriticalError(error, context);
        break;
      case 'warning':
        await this.handleWarningError(error, context);
        break;
      default:
        await this.handleGeneralError(error, context);
    }
  }

  /**
   * è™•ç†é—œéµéŒ¯èª¤
   */
  async handleCriticalError(error, context) {
    // å•Ÿå‹•æ–·è·¯å™¨
    this.activateCircuitBreaker(context.component);
    
    // å˜—è©¦ç³»çµ±å¾©åŸ
    await this.attemptSystemRecovery(context);
    
    // é€šçŸ¥ä½¿ç”¨è€…
    await this.notifyUser({
      type: 'critical_error',
      message: 'ç³»çµ±é‡åˆ°åš´é‡éŒ¯èª¤ï¼Œæ­£åœ¨å˜—è©¦è‡ªå‹•å¾©åŸ',
      canRetry: true
    });
  }

  /**
   * å•Ÿå‹•æ–·è·¯å™¨
   */
  activateCircuitBreaker(component) {
    const now = Date.now();
    const breakerInfo = this.circuitBreaker.get(component) || {
      isOpen: false,
      failureCount: 0,
      lastFailureTime: 0
    };

    breakerInfo.failureCount++;
    breakerInfo.lastFailureTime = now;

    // å¦‚æœå¤±æ•—æ¬¡æ•¸éå¤šï¼Œé–‹å•Ÿæ–·è·¯å™¨
    if (breakerInfo.failureCount >= 3) {
      breakerInfo.isOpen = true;
      breakerInfo.openedAt = now;
      
      // è¨­å®šè‡ªå‹•å¾©åŸæ™‚é–“ï¼ˆ5åˆ†é˜å¾Œï¼‰
      setTimeout(() => {
        this.resetCircuitBreaker(component);
      }, 5 * 60 * 1000);
    }

    this.circuitBreaker.set(component, breakerInfo);
  }

  /**
   * é‡è¨­æ–·è·¯å™¨
   */
  resetCircuitBreaker(component) {
    const breakerInfo = this.circuitBreaker.get(component);
    if (breakerInfo) {
      breakerInfo.isOpen = false;
      breakerInfo.failureCount = 0;
      this.circuitBreaker.set(component, breakerInfo);
      
      console.log(`Circuit breaker reset for component: ${component}`);
    }
  }

  /**
   * æª¢æŸ¥æ–·è·¯å™¨ç‹€æ…‹
   */
  isCircuitBreakerOpen(component) {
    const breakerInfo = this.circuitBreaker.get(component);
    return breakerInfo && breakerInfo.isOpen;
  }

  /**
   * å˜—è©¦ç³»çµ±å¾©åŸ
   */
  async attemptSystemRecovery(context) {
    try {
      // æ¸…ç†å¯èƒ½æå£çš„ç‹€æ…‹
      await this.cleanupCorruptedState(context);
      
      // é‡æ–°åˆå§‹åŒ–ç›¸é—œçµ„ä»¶
      await this.reinitializeComponents(context);
      
      // é©—è­‰ç³»çµ±ç‹€æ…‹
      const isHealthy = await this.validateSystemHealth();
      
      if (isHealthy) {
        console.log('System recovery successful');
        return true;
      } else {
        console.error('System recovery failed');
        return false;
      }
    } catch (recoveryError) {
      console.error('Error during system recovery:', recoveryError);
      return false;
    }
  }
}
```

## ğŸ“Š ç›£æ§èˆ‡é™¤éŒ¯

### äº‹ä»¶è¿½è¹¤èˆ‡æ—¥èªŒ

```javascript
/**
 * äº‹ä»¶è¿½è¹¤å™¨
 */
class EventTracker {
  constructor() {
    this.eventHistory = [];
    this.maxHistorySize = 1000;
    this.filters = new Set();
  }

  /**
   * è¿½è¹¤äº‹ä»¶
   */
  trackEvent(event, phase, metadata = {}) {
    const trackingEntry = {
      eventId: event.id,
      eventType: event.type,
      phase,
      timestamp: new Date().toISOString(),
      metadata
    };

    this.eventHistory.push(trackingEntry);

    // ç¶­è­·æ­·å²è¨˜éŒ„å¤§å°
    if (this.eventHistory.length > this.maxHistorySize) {
      this.eventHistory.shift();
    }

    // å³æ™‚æ—¥èªŒ
    if (this.shouldLog(event.type)) {
      console.log(`[EventTracker] ${event.type} - ${phase}`, metadata);
    }
  }

  /**
   * æª¢æŸ¥æ˜¯å¦æ‡‰è©²è¨˜éŒ„æ­¤äº‹ä»¶
   */
  shouldLog(eventType) {
    if (this.filters.size === 0) return true;
    return Array.from(this.filters).some(filter => 
      eventType.includes(filter)
    );
  }

  /**
   * è¨­å®šäº‹ä»¶éæ¿¾å™¨
   */
  setFilters(filters) {
    this.filters = new Set(filters);
  }

  /**
   * å–å¾—äº‹ä»¶æ­·å²
   */
  getEventHistory(eventType = null, limit = 100) {
    let history = this.eventHistory;
    
    if (eventType) {
      history = history.filter(entry => 
        entry.eventType.includes(eventType)
      );
    }
    
    return history.slice(-limit);
  }

  /**
   * åˆ†æäº‹ä»¶çµ±è¨ˆ
   */
  analyzeEventStats() {
    const stats = {
      totalEvents: this.eventHistory.length,
      eventTypes: {},
      phases: {},
      timeRange: {
        start: this.eventHistory[0]?.timestamp,
        end: this.eventHistory[this.eventHistory.length - 1]?.timestamp
      }
    };

    this.eventHistory.forEach(entry => {
      // çµ±è¨ˆäº‹ä»¶é¡å‹
      stats.eventTypes[entry.eventType] = 
        (stats.eventTypes[entry.eventType] || 0) + 1;
      
      // çµ±è¨ˆéšæ®µ
      stats.phases[entry.phase] = 
        (stats.phases[entry.phase] || 0) + 1;
    });

    return stats;
  }

  /**
   * åŒ¯å‡ºè¿½è¹¤è³‡æ–™
   */
  exportTrackingData(format = 'json') {
    const data = {
      metadata: {
        exportedAt: new Date().toISOString(),
        totalEvents: this.eventHistory.length,
        format
      },
      events: this.eventHistory
    };

    switch (format) {
      case 'json':
        return JSON.stringify(data, null, 2);
      case 'csv':
        return this.convertToCsv(this.eventHistory);
      default:
        throw new Error(`Unsupported format: ${format}`);
    }
  }

  /**
   * è½‰æ›ç‚ºCSVæ ¼å¼
   */
  convertToCsv(events) {
    if (events.length === 0) return '';

    const headers = Object.keys(events[0]);
    const csvContent = [
      headers.join(','),
      ...events.map(event => 
        headers.map(header => 
          JSON.stringify(event[header] || '')
        ).join(',')
      )
    ].join('\n');

    return csvContent;
  }
}
```

## ğŸš€ æœ€ä½³å¯¦è¸èˆ‡æŒ‡å°åŸå‰‡

### äº‹ä»¶è¨­è¨ˆæœ€ä½³å¯¦è¸

1. **äº‹ä»¶å‘½å**
   - ä½¿ç”¨æ¸…æ™°ã€æè¿°æ€§çš„åç¨±
   - éµå¾ªä¸€è‡´çš„å‘½åè¦ç¯„
   - é¿å…ä½¿ç”¨ç¸®å¯«æˆ–æ¨¡ç³Šçš„è¡“èª

2. **äº‹ä»¶ç²’åº¦**
   - ä¿æŒäº‹ä»¶çš„åŸå­æ€§
   - é¿å…å°‡å¤šå€‹æ“ä½œåŒ…è£åœ¨å–®ä¸€äº‹ä»¶ä¸­
   - æä¾›é©ç•¶çš„æŠ½è±¡å±¤ç´š

3. **è³‡æ–™çµæ§‹**
   - ä¿æŒäº‹ä»¶è³‡æ–™çš„ç°¡æ½”æ€§
   - é¿å…åœ¨äº‹ä»¶ä¸­å‚³éå¤§é‡è³‡æ–™
   - ä½¿ç”¨å¼•ç”¨è€Œéå…§åµŒå¤§å‹ç‰©ä»¶

4. **éŒ¯èª¤è™•ç†**
   - ç‚ºæ¯å€‹äº‹ä»¶å®šç¾©å¯èƒ½çš„éŒ¯èª¤ç‹€æ…‹
   - æä¾›æ˜ç¢ºçš„éŒ¯èª¤è³‡è¨Š
   - å¯¦ç¾é©ç•¶çš„é‡è©¦æ©Ÿåˆ¶

5. **æ•ˆèƒ½è€ƒé‡**
   - é¿å…åœ¨äº‹ä»¶è™•ç†å™¨ä¸­åŸ·è¡Œé•·æ™‚é–“æ“ä½œ
   - ä½¿ç”¨éåŒæ­¥è™•ç†é¿å…é˜»å¡
   - å¯¦ç¾é©ç•¶çš„ç¯€æµå’Œé˜²æŠ–æ©Ÿåˆ¶

### é–‹ç™¼æŒ‡å°åŸå‰‡

1. **æ¸¬è©¦é©…å‹•é–‹ç™¼**
   - å…ˆå¯«æ¸¬è©¦ï¼Œå†å¯¦ç¾åŠŸèƒ½
   - ç¢ºä¿æ¯å€‹äº‹ä»¶è™•ç†å™¨éƒ½æœ‰å°æ‡‰æ¸¬è©¦
   - æ¸¬è©¦å„ç¨®é‚Šç•Œæƒ…æ³å’ŒéŒ¯èª¤å ´æ™¯

2. **æ–‡ä»¶åŒ–**
   - è©³ç´°è¨˜éŒ„äº‹ä»¶é¡å‹å’Œè³‡æ–™çµæ§‹
   - æä¾›ä½¿ç”¨ç¯„ä¾‹å’Œæœ€ä½³å¯¦è¸
   - ç¶­è­·æ¶æ§‹æ±ºç­–çš„è¨˜éŒ„

3. **ç‰ˆæœ¬æ§åˆ¶**
   - ç‚ºäº‹ä»¶çµæ§‹è®Šæ›´æä¾›ç‰ˆæœ¬æ§åˆ¶
   - å¯¦ç¾å‘å¾Œç›¸å®¹çš„å‡ç´šç­–ç•¥
   - æ˜ç¢ºå»¢æ£„æ”¿ç­–å’Œé·ç§»è·¯å¾‘

4. **ç›£æ§èˆ‡ç¶­è­·**
   - å¯¦æ–½å…¨é¢çš„ç›£æ§å’Œæ—¥èªŒè¨˜éŒ„
   - å®šæœŸæª¢æŸ¥å’Œå„ªåŒ–æ•ˆèƒ½
   - ä¸»å‹•è­˜åˆ¥å’Œè§£æ±ºæ½›åœ¨å•é¡Œ

## ğŸ“‹ å¯¦æ–½æª¢æŸ¥æ¸…å–®

### åŸºç¤è¨­æ–½æª¢æŸ¥æ¸…å–®

- [ ] äº‹ä»¶ç¸½ç·šæ ¸å¿ƒå¯¦ç¾
- [ ] äº‹ä»¶è¨»å†Šå’Œåˆ†ç™¼æ©Ÿåˆ¶
- [ ] åŸºæœ¬äº‹ä»¶è™•ç†å™¨ä»‹é¢
- [ ] Chrome Extensionæ¶ˆæ¯æ©‹æ¥
- [ ] åŸºç¤æ—¥èªŒå’Œç›£æ§

### åŠŸèƒ½å¯¦ç¾æª¢æŸ¥æ¸…å–®

- [ ] è³‡æ–™æå–äº‹ä»¶è™•ç†å™¨
- [ ] å„²å­˜ç®¡ç†äº‹ä»¶è™•ç†å™¨
- [ ] UIæ›´æ–°äº‹ä»¶è™•ç†å™¨
- [ ] éŒ¯èª¤è™•ç†å’Œå¾©åŸæ©Ÿåˆ¶
- [ ] æ•ˆèƒ½ç›£æ§å’Œå„ªåŒ–

### æ¸¬è©¦æª¢æŸ¥æ¸…å–®

- [ ] å–®å…ƒæ¸¬è©¦è¦†è“‹æ‰€æœ‰äº‹ä»¶è™•ç†å™¨
- [ ] æ•´åˆæ¸¬è©¦é©—è­‰äº‹ä»¶æµç¨‹
- [ ] æ•ˆèƒ½æ¸¬è©¦ç¢ºä¿éŸ¿æ‡‰æ™‚é–“
- [ ] éŒ¯èª¤å ´æ™¯æ¸¬è©¦
- [ ] è·¨æ¨¡çµ„é€šè¨Šæ¸¬è©¦

### æ–‡ä»¶æª¢æŸ¥æ¸…å–®

- [ ] APIæ–‡ä»¶å®Œæ•´
- [ ] ä½¿ç”¨æŒ‡å—æ¸…æ™°
- [ ] æ¶æ§‹æ±ºç­–è¨˜éŒ„
- [ ] æ•…éšœæ’é™¤æŒ‡å—
- [ ] æœ€ä½³å¯¦è¸æŒ‡å°

---

**æœ¬æ–‡ä»¶å°‡éš¨è‘—ç³»çµ±ç™¼å±•æŒçºŒæ›´æ–°ï¼Œç¢ºä¿æ¶æ§‹æ–‡ä»¶èˆ‡å¯¦éš›å¯¦ç¾ä¿æŒåŒæ­¥ã€‚**

## ğŸ§© æ¶æ§‹æ±ºç­–ï¼šåˆå§‹åŒ–ç«¶æ…‹èˆ‡ä»‹é¢å°è£

### å•é¡Œæè¿°ï¼ˆProblem Statementï¼‰

- **ç—‡ç‹€**ï¼šåœ¨å†·å•Ÿå‹•æˆ– Service Worker é‡å•Ÿæ™‚ï¼Œ`CONTENT.EVENT.FORWARD` èˆ‡ `EXTRACTION.COMPLETED` ç­‰äº‹ä»¶å¯èƒ½æ—©æ–¼èƒŒæ™¯ç«¯ç›£è½å™¨å®Œæˆè¨»å†Šå³æŠµé”ï¼Œå°è‡´äº‹ä»¶é›–æˆåŠŸ `emit()`ï¼Œä½†ç•¶ä¸‹æ²’æœ‰ä»»ä½•ç›£è½å™¨è¢«åŸ·è¡Œï¼Œä¸¦ä¼´éš¨é™¤éŒ¯æ—¥èªŒå‡ºç¾ä¸ç©©å®šå€¼ï¼ˆä¾‹å¦‚ `undefined`ï¼‰ã€‚
- **æ ¹å› **ï¼š
  - äº‹ä»¶ç³»çµ±ã€Œå»ºç«‹ï¼ˆEventBus/Bridgeï¼‰ã€èˆ‡ã€Œç›£è½å™¨è¨»å†Šã€ä¹‹é–“ç¼ºå°‘å–®ä¸€å°±ç·’å±éšœï¼ˆReady Barrierï¼‰ï¼Œè¨Šæ¯å…¥å£æœªç­‰å€™å®Œæ•´åˆå§‹åŒ–å®Œæˆä¾¿é–‹å§‹åˆ†ç™¼äº‹ä»¶ã€‚
  - å¤–éƒ¨ç›´æ¥è®€å– `eventBus.listeners` å…§éƒ¨çµæ§‹æª¢æŸ¥ç›£è½å™¨ï¼Œç ´å£æŠ½è±¡é‚Šç•Œï¼Œå°è‡´æª¢æŸ¥å€¼ä¸ç©©å®šã€‚

### è¨­è¨ˆåŸå‰‡ï¼ˆDesign Principlesï¼‰

- **å–®ä¸€è²¬ä»»èˆ‡æ¸…æ™°é‚Šç•Œ**ï¼šè¨Šæ¯å…¥å£åªè² è²¬ã€Œè·¯ç”± + ç­‰å¾…å°±ç·’ã€ï¼Œäº‹ä»¶ç³»çµ±å°å¤–åƒ…ä»¥å…¬é–‹æ–¹æ³•æä¾›ç‹€æ…‹æª¢æŸ¥ï¼›å…§éƒ¨è³‡æ–™çµæ§‹ä¸å¯è¢«å¤–éƒ¨ç›´æ¥ä¾è³´ã€‚
- **å¯è§€æ¸¬ä¸”å¯æ¸¬è©¦**ï¼šæä¾›ç©©å®šçš„æª¢æŸ¥ä»‹é¢ï¼ˆå¦‚ `hasListener(eventType)`ã€`getListenerCount(eventType)`ï¼‰ï¼Œé¿å…æ¸¬è©¦/æ—¥èªŒä¾è³´å…§éƒ¨å¯¦ä½œç´°ç¯€ã€‚
- **é˜²ç¦¦å¼è¨­è¨ˆ**ï¼šåœ¨ä¸å¯é¿å…çš„å†·å•Ÿå‹•æƒ…å¢ƒä¸‹ï¼Œä»»ä½•æ—©åˆ°äº‹ä»¶è¦å˜›è¢«å®‰å…¨ç·©è¡ï¼Œè¦å˜›åœ¨å…¥å£è™•è¢« gating ç›´åˆ°ç³»çµ± readyã€‚

### è§£æ±ºæ–¹æ¡ˆï¼ˆSolution Overviewï¼‰

- **å°±ç·’å±éšœï¼ˆReady Barrierï¼‰**ï¼š
  - å»ºç«‹å–®ä¸€ã€Œå®Œæ•´åˆå§‹åŒ–æ‰¿è«¾ã€æ¶µè“‹ã€Œäº‹ä»¶ç¸½ç·š/æ©‹æ¥å™¨å»ºç«‹ + ç›£è½å™¨è¨»å†Šã€ï¼Œä¾‹å¦‚ `globalThis.__bgInitPromise = initializeBackgroundServiceWorker()`ã€‚
  - è¨Šæ¯å…¥å£ï¼ˆ`chrome.runtime.onMessage`ï¼‰ä¸€å¾‹å…ˆ `await __bgInitPromise` å†é€²è¡Œè·¯ç”±èˆ‡ `emit()`ã€‚

- **è¨Šæ¯å…¥å£ Gating**ï¼š
  - è‹¥äº‹ä»¶ç³»çµ±å°šæœªå°±ç·’ï¼Œå…¥å£å…ˆç­‰å¾…å°±ç·’æ‰¿è«¾ï¼›å¿…è¦æ™‚å¯åŠ å…¥ timeout èˆ‡å‘Šè­¦ã€‚
  - åœ¨ ready å‰å°‡äº‹ä»¶æ”¾å…¥ pre-init queueï¼Œå¾…å°±ç·’æˆ–è¨»å†Šåˆ°å°æ‡‰ç›£è½å™¨å¾Œé‡æ”¾ï¼ˆæœ¬å°ˆæ¡ˆå·²æ¡ç”¨ï¼‰ã€‚

- **ä»‹é¢å°è£èˆ‡ä¸€è‡´æ€§**ï¼š
  - å°è£ç›£è½æª¢æŸ¥ç‚ºå…¬é–‹ä»‹é¢ï¼š`eventBus.hasListener(eventType)`ã€`eventBus.getListenerCount(eventType)`ã€‚
  - ç¦æ­¢ç›´æ¥è®€å– `eventBus.listeners`ã€‚
  - ä¿æŒè·¨æ¨¡çµ„ API ä¸€è‡´ï¼Œä»¥åˆ©æ•´åˆæ¸¬è©¦èˆ‡è¨ºæ–·ã€‚

### è™•ç†æµç¨‹ï¼ˆProcess Flowï¼‰

1. èƒŒæ™¯åˆå§‹åŒ–å•Ÿå‹• `initializeBackgroundServiceWorker()`ï¼Œå»ºç«‹äº‹ä»¶ç³»çµ±ä¸¦å®Œæˆç›£è½å™¨è¨»å†Šã€‚
2. åˆå§‹åŒ–éç¨‹å®Œæˆå¾Œå‘¼å« `resolve` æ¨™è¨˜ `__bgInitPromise` å®Œæˆï¼ˆç³»çµ± readyï¼‰ã€‚
3. è¨Šæ¯å…¥å£æ¥æ”¶åˆ°ä»»ä½•è·¨ä¸Šä¸‹æ–‡è¨Šæ¯æ™‚ï¼Œå…ˆ `await __bgInitPromise`ï¼Œå†å‘¼å«å°æ‡‰çš„ `handle*` è·¯ç”±èˆ‡ `eventBus.emit()`ã€‚
4. ç›£è½æª¢æŸ¥èˆ‡è¨ºæ–·ä¸€å¾‹ä½¿ç”¨å…¬é–‹ä»‹é¢ï¼Œé¿å…å…§éƒ¨è³‡æ–™çµæ§‹å¤–æ´©ã€‚

### ä½¿ç”¨æƒ…å¢ƒï¼ˆUsage Contextï¼‰

- å†·å•Ÿå‹•æˆ– Service Worker è¢«å–šé†’å¾Œç«‹å³æœ‰ Content Script å‚³å…¥ `CONTENT.EVENT.FORWARD`ã€‚
- åœ˜éšŠéœ€è¦åœ¨æ—¥èªŒæˆ–æ¸¬è©¦ä¸­ç¢ºèªæŸäº‹ä»¶ç›®å‰æ˜¯å¦æœ‰ç›£è½å™¨ã€æœ‰å¤šå°‘ç›£è½å™¨ã€‚

### è¨­è¨ˆå–æ¨ï¼ˆTrade-offsï¼‰

- ç­‰å¾…å°±ç·’å¯èƒ½å¼•å…¥æ¥µçŸ­å»¶é²ï¼Œä½†æ›å–äº‹ä»¶è™•ç†ä¸€è‡´æ€§èˆ‡å¯é åº¦ã€‚
- è‹¥æ¡ç”¨ pre-init queueï¼Œéœ€é¡å¤–è¨˜æ†¶é«”èˆ‡åºåˆ—åŒ–ä¿è­‰ï¼›æœ¬éšæ®µå…ˆæ¡ã€Œç­‰å¾…å°±ç·’ã€ä»¥é™ä½è¤‡é›œåº¦ã€‚

### æ¨™æº–åŒ–ä»‹é¢ï¼ˆStandardized Interfacesï¼‰

```js
// ç©©å®šæª¢æŸ¥æ–¹å¼
eventBus.hasListener('EXTRACTION.COMPLETED') // boolean
eventBus.getListenerCount('EXTRACTION.COMPLETED') // number

// äº‹ä»¶ç³»çµ±å°±ç·’èˆ‡é‡æ”¾
eventBus.markReady() // æ¨™è¨˜ç³»çµ±å°±ç·’ï¼Œè§¸ç™¼ pre-init ä½‡åˆ—é‡æ”¾

// çµ±ä¸€ emit ä»‹é¢èˆ‡å›å‚³
// å‚³å…¥ dataï¼Œè™•ç†å™¨æ”¶åˆ°æ¨™æº–äº‹ä»¶ç‰©ä»¶ { type, data, timestamp }
// å›å‚³è™•ç†çµæœé™£åˆ—ï¼ˆæ¯å€‹ç›£è½å™¨çš„è™•ç†çµæœï¼‰
const results = await eventBus.emit('EXTRACTION.COMPLETED', { booksData })
Array.isArray(results) === true
```

### é©—æ”¶æº–å‰‡ï¼ˆAcceptance Criteriaï¼‰

- å†·å•Ÿå‹•æƒ…å¢ƒä¸‹ï¼Œ`EXTRACTION.COMPLETED` ä¸å†å‡ºç¾ã€Œäº‹ä»¶æˆåŠŸ emit ä½†ç„¡ç›£è½å™¨åŸ·è¡Œã€çš„æƒ…æ³ã€‚
- å°±ç·’å‰åˆ°é”çš„äº‹ä»¶æœƒè¢«æš«å­˜æ–¼ pre-init queueï¼Œä¸¦åœ¨ `markReady()` æˆ–å°æ‡‰äº‹ä»¶ç›£è½å™¨è¨»å†Šå¾Œé‡æ”¾ã€‚
- æ‰€æœ‰ç›£è½æª¢æŸ¥æ—¥èªŒ/æ¸¬è©¦å‡æ”¹ç”¨å…¬é–‹ APIï¼Œä¸ä¾è³´ `listeners` å…§éƒ¨çµæ§‹ã€‚
- æ•´åˆæ¸¬è©¦åœ¨å¤šæ¬¡å•Ÿåœ/é‡è¼‰ä¸‹äº‹ä»¶è™•ç†çµæœä¸€è‡´ã€‚

### Pre-init ä½‡åˆ—èˆ‡å°±ç·’å±éšœè¨­è¨ˆï¼ˆæ–°å¢ï¼‰

#### è² è²¬åŠŸèƒ½ï¼š
- æš«å­˜ç³»çµ±å°±ç·’å‰æŠµé”çš„äº‹ä»¶ï¼Œé¿å…è³‡æ–™éºå¤±
- åœ¨ç³»çµ±å°±ç·’å¾Œå®‰å…¨é‡æ”¾äº‹ä»¶ï¼Œç¢ºä¿è™•ç†é †åºèˆ‡ä¸€è‡´æ€§
- é™ä½ Service Worker å†·å•Ÿå‹•æ™‚åºä¸ç¢ºå®šæ€§å°åŠŸèƒ½çš„å½±éŸ¿

#### è¨­è¨ˆè€ƒé‡ï¼š
- Chrome MV3 Service Worker å¯èƒ½åœ¨ä»»ä½•æ™‚é–“è¢«å–šé†’/çµ‚æ­¢
- Content Script å¯èƒ½åœ¨èƒŒæ™¯ç›£è½å™¨è¨»å†Šå®Œæˆå‰å³é–‹å§‹ç™¼é€äº‹ä»¶
- éœ€é¿å…ç›´æ¥ä¾è³´å…§éƒ¨è³‡æ–™çµæ§‹ï¼ˆå¦‚ listeners Mapï¼‰

#### è™•ç†æµç¨‹ï¼š
1. emit(eventType, data) åœ¨å°šç„¡ç›£è½å™¨ä¸”æœªå°±ç·’æ™‚ï¼Œå°‡äº‹ä»¶æ¨å…¥ pre-init queue ä¸¦è¿”å›ç©ºé™£åˆ—
2. on(eventType, handler) è¨»å†Šå¾Œï¼Œéé˜»å¡é‡æ”¾ä½‡åˆ—ä¸­åŒå‹åˆ¥äº‹ä»¶
3. initializeBackgroundServiceWorker() å®Œæˆå¾Œå‘¼å« eventBus.markReady()ï¼Œé‡æ”¾æ‰€æœ‰ä½‡åˆ—äº‹ä»¶
4. å¾ŒçºŒ emit ç›´æ¥ä»¥å·²è¨»å†Šç›£è½å™¨åŒæ­¥/éåŒæ­¥è™•ç†ï¼Œå›å‚³çµæœé™£åˆ—

#### ä½¿ç”¨æƒ…å¢ƒï¼š
- å†·å•Ÿå‹•ç«‹å³é€²è¡Œçš„ `CONTENT.EVENT.FORWARD` èˆ‡ `EXTRACTION.*` äº‹ä»¶
- èƒŒæ™¯ç›£è½å™¨è¨»å†Šè½å¾Œæ–¼è¨Šæ¯å…¥å£äº‹ä»¶åˆ°é”çš„æƒ…å¢ƒ

#### ç‹€æ…‹è½‰æ›ï¼š
- [PreInit] â†’ [Ready] ç”± `eventBus.markReady()` è§¸ç™¼
- åœ¨ [PreInit] ç‹€æ…‹ï¼Œäº‹ä»¶é€²å…¥ `preInitQueue`
- é€²å…¥ [Ready] å¾Œï¼Œä½‡åˆ—äº‹ä»¶ä¾æ™‚é–“é †åºé‡æ”¾

#### æ¸¬è©¦èˆ‡é©—è­‰ï¼š
- æ–°å¢æ•´åˆæ¸¬è©¦ï¼šç›£è½å™¨è¨»å†Šå‰ emitï¼Œ`markReady()` å¾Œ handler å¿…é ˆæ”¶åˆ°äº‹ä»¶ï¼ˆå·²é€šéï¼‰
- é©—è­‰ emit å›å‚³å‹åˆ¥çµ±ä¸€ç‚ºé™£åˆ—ï¼Œä¾¿æ–¼çµ±è¨ˆè™•ç†å™¨åŸ·è¡Œæ¬¡æ•¸

### Overview è³‡æ–™åŒæ­¥è¨­è¨ˆï¼ˆé€é chrome.storage.onChangedï¼‰

#### è² è²¬åŠŸèƒ½ï¼š
- è®“ Overview é é¢åœ¨æå–å®Œæˆå¾Œè‡ªå‹•æ›´æ–°æ›¸åº«è³‡æ–™
- è§£è€¦ Content Script/Background å’Œ Overview çš„è·¨ä¸Šä¸‹æ–‡é€šè¨Š

#### è¨­è¨ˆè€ƒé‡ï¼š
- ä¾æ“šæœ¬å°ˆæ¡ˆè·¨ä¸Šä¸‹æ–‡é€šè¨Šè¦ç¯„ï¼ŒOverview â†” Background å„ªå…ˆé€é `chrome.storage` é€²è¡Œè³‡æ–™åŒæ­¥
- Background åœ¨æ¥æ”¶åˆ° `EXTRACTION.COMPLETED` å¾Œå°‡è³‡æ–™å¯«å…¥ `chrome.storage.local.readmoo_books`
- Overview ç›£è½ `chrome.storage.onChanged`ï¼Œä¸€æ—¦ `readmoo_books` è®Šæ›´ç«‹å³æ›´æ–° UI

#### è™•ç†æµç¨‹ï¼š
1. Content Script è§¸ç™¼æå– â†’ äº‹ä»¶è½‰ç™¼åˆ° Background
2. Background ç›£è½ `EXTRACTION.COMPLETED` â†’ å¯«å…¥ `chrome.storage.local.readmoo_books`
3. Overview ç›£è½ `chrome.storage.onChanged` â†’ è®€å–è®Šæ›´ä¸¦æ›´æ–°ç•«é¢

### é—œéµç›£è½å™¨å®ˆè­·ï¼ˆListener Guardï¼‰

ç‚ºé¿å…å†·å•Ÿå‹•æˆ–ä¾‹å¤–æƒ…æ³ä¸‹é—œéµç›£è½å™¨æœªè¨»å†Šå°è‡´äº‹ä»¶æµå¤±ï¼ŒèƒŒæ™¯å±¤åŠ å…¥å®ˆè­·æ©Ÿåˆ¶ï¼š

- æä¾› `registerCoreListenersIfNeeded()`ï¼šå¯é‡å…¥ï¼Œç¢ºä¿ `EXTRACTION.COMPLETED` ç­‰é—œéµç›£è½å™¨å­˜åœ¨
- åœ¨èƒŒæ™¯åˆå§‹åŒ–æµç¨‹åŠ `CONTENT.EVENT.FORWARD` çš„ `EXTRACTION.COMPLETED` è·¯å¾‘ä¸Šå‡æœƒå‘¼å«æ­¤å‡½å¼
- è‹¥ç›£è½å™¨ç¼ºå¤±å‰‡å³æ™‚è£œè¨»å†Šï¼Œä¿éšœè³‡æ–™å¯«å…¥ `chrome.storage.local`

é©—æ”¶æº–å‰‡ï¼š
- åœ¨ Content Script å…ˆç™¼ `EXTRACTION.COMPLETED` å†å®ŒæˆèƒŒæ™¯ç›£è½å™¨è¨»å†Šæ™‚ï¼Œè³‡æ–™ä»æœƒè¢«å¯«å…¥ storageï¼ˆé  pre-init queue + å®ˆè­·ï¼‰
- åœ¨ä»»æ„æ™‚åºä¸‹ï¼Œ`eventBus.hasListener('EXTRACTION.COMPLETED')` æ–¼ emit å‰å¾Œå‡ç‚º true æˆ–åœ¨ emit å‰è¢«è£œè¶³

#### ä»‹é¢ç¯„ä¾‹ï¼š
```js
// Overview åˆå§‹åŒ–æ™‚è¨»å†Š storage è®Šæ›´ç›£è½
chrome.storage.onChanged.addListener((changes, area) => {
  if (area === 'local' && changes.readmoo_books?.newValue?.books) {
    const { books } = changes.readmoo_books.newValue
    this._updateBooksData(books || [])
    this.updateDisplay()
  }
})
```

#### é©—æ”¶æº–å‰‡ï¼š
- Background å¯«å…¥ `readmoo_books` å¾Œï¼ŒOverview æ‡‰ç„¡éœ€æ‰‹å‹•é‡è¼‰å³å¯é¡¯ç¤ºæœ€æ–°æ›¸åº«æ•¸é‡
- å³ä½¿ `EXTRACTION.STARTED/PROGRESS` ç„¡ç›£è½å™¨ï¼Œæ•´é«”ä½¿ç”¨è€…é«”é©—ä»æ­£ç¢ºï¼ˆå®Œæˆæ™‚è‡ªå‹•æ›´æ–°ï¼‰

## ğŸ” EventBus è¨ºæ–· API (`getStats()`)

### åŠŸèƒ½æ¦‚è¿°

EventBus æä¾› `getStats()` æ–¹æ³•ï¼Œè¿”å›å®Œæ•´çš„äº‹ä»¶ç³»çµ±çµ±è¨ˆè³‡è¨Šï¼Œç”¨æ–¼ç³»çµ±ç›£æ§ã€æ•ˆèƒ½åˆ†æå’Œé™¤éŒ¯è¨ºæ–·ã€‚æ­¤æ–¹æ³•æ˜¯äº‹ä»¶ç³»çµ±å¥åº·ç‹€æ…‹çš„æ ¸å¿ƒæŒ‡æ¨™ä¾†æºã€‚

### æ–¹æ³•ç°½å

```javascript
/**
 * å–å¾—äº‹ä»¶ç³»çµ±çµ±è¨ˆè³‡è¨Š
 * @returns {Object} å®Œæ•´çš„çµ±è¨ˆè³‡è¨Šç‰©ä»¶
 */
getStats(): EventBusStats
```

### è¿”å›è³‡æ–™çµæ§‹

```typescript
interface EventBusStats {
  // === ç›£è½å™¨ç›¸é—œçµ±è¨ˆ ===
  totalEventTypes: number;        // è¨»å†Šçš„äº‹ä»¶é¡å‹ç¸½æ•¸
  totalListeners: number;         // ç›£è½å™¨ç¸½æ•¸é‡
  eventTypes: string[];          // æ‰€æœ‰å·²è¨»å†Šäº‹ä»¶é¡å‹é™£åˆ—
  listenerCounts: {              // æ¯ç¨®äº‹ä»¶é¡å‹çš„ç›£è½å™¨æ•¸é‡
    [eventType: string]: number;
  };
  
  // === äº‹ä»¶è§¸ç™¼ç›¸é—œçµ±è¨ˆ ===
  totalEvents: number;           // ç¸½äº‹ä»¶è§¸ç™¼æ¬¡æ•¸ï¼ˆèˆ‡ totalEmissions ç›¸åŒï¼‰
  totalEmissions: number;        // ç¸½äº‹ä»¶è§¸ç™¼æ¬¡æ•¸ï¼ˆå‘å¾Œç›¸å®¹ï¼‰
  totalExecutionTime: number;    // ç´¯è¨ˆåŸ·è¡Œæ™‚é–“ï¼ˆæ¯«ç§’ï¼‰
  lastActivity: string | null;   // æœ€å¾Œæ´»å‹•æ™‚é–“æˆ³ï¼ˆISOæ ¼å¼ï¼‰
}
```

### ä½¿ç”¨ç¯„ä¾‹

#### åŸºæœ¬çµ±è¨ˆæŸ¥è©¢
```javascript
const eventBus = new EventBus();
eventBus.on('DATA.EXTRACTION.STARTED', handler1);
eventBus.on('DATA.EXTRACTION.STARTED', handler2);
eventBus.on('UI.UPDATE.PROGRESS', handler3);

const stats = eventBus.getStats();
console.log(stats);
/* è¼¸å‡ºï¼š
{
  totalEventTypes: 2,
  totalListeners: 3,
  eventTypes: ['DATA.EXTRACTION.STARTED', 'UI.UPDATE.PROGRESS'],
  listenerCounts: {
    'DATA.EXTRACTION.STARTED': 2,
    'UI.UPDATE.PROGRESS': 1
  },
  totalEvents: 0,
  totalEmissions: 0,
  totalExecutionTime: 0,
  lastActivity: null
}
*/
```

#### è§¸ç™¼äº‹ä»¶å¾Œçš„çµ±è¨ˆ
```javascript
await eventBus.emit('DATA.EXTRACTION.STARTED', { bookId: 123 });
await eventBus.emit('UI.UPDATE.PROGRESS', { progress: 50 });

const stats = eventBus.getStats();
console.log(stats);
/* è¼¸å‡ºï¼š
{
  totalEventTypes: 2,
  totalListeners: 3,
  eventTypes: ['DATA.EXTRACTION.STARTED', 'UI.UPDATE.PROGRESS'],
  listenerCounts: {
    'DATA.EXTRACTION.STARTED': 2,
    'UI.UPDATE.PROGRESS': 1
  },
  totalEvents: 2,
  totalEmissions: 2,
  totalExecutionTime: 15.2,
  lastActivity: '2025-08-12T10:30:45.123Z'
}
*/
```

### å¯¦éš›æ‡‰ç”¨å ´æ™¯

#### 1. Background Service Worker å¥åº·æª¢æŸ¥
```javascript
// src/background/background.js
function getSystemStatus() {
  const stats = eventBus.getStats();
  return {
    eventSystem: {
      active: stats.totalListeners > 0,
      eventsProcessed: stats.totalEvents,
      lastActivity: stats.lastActivity,
      listenerHealth: stats.listenerCounts
    }
  };
}
```

#### 2. é–‹ç™¼é™¤éŒ¯èˆ‡æ•ˆèƒ½ç›£æ§
```javascript
// æª¢æŸ¥é—œéµç›£è½å™¨æ˜¯å¦å­˜åœ¨
function validateCriticalListeners() {
  const stats = eventBus.getStats();
  const critical = ['EXTRACTION.COMPLETED', 'STORAGE.SAVE.COMPLETED'];
  
  const missing = critical.filter(event => 
    !stats.eventTypes.includes(event) || 
    stats.listenerCounts[event] === 0
  );
  
  if (missing.length > 0) {
    console.warn('Missing critical listeners:', missing);
  }
  
  return missing.length === 0;
}
```

#### 3. æ•´åˆæ¸¬è©¦é©—è­‰
```javascript
// tests/integration/background-event-system.test.js
test('äº‹ä»¶ç³»çµ±çµ±è¨ˆè¿½è¹¤', async () => {
  const initialStats = eventBus.getStats();
  expect(initialStats.totalEvents).toBe(0);
  
  await eventBus.emit('TEST.EVENT', { data: 'test' });
  
  const finalStats = eventBus.getStats();
  expect(finalStats.totalEvents).toBe(1);
  expect(finalStats.lastActivity).toBeTruthy();
});
```

### çµ±è¨ˆè³‡æ–™è§£è®€æŒ‡å—

#### ç›£è½å™¨å¥åº·åº¦æŒ‡æ¨™
- `totalEventTypes`: åæ˜ ç³»çµ±æ¨¡çµ„åŒ–ç¨‹åº¦ï¼Œéå¤šå¯èƒ½è¡¨ç¤ºäº‹ä»¶åˆ‡åˆ†éç´°
- `totalListeners`: åæ˜ ç³»çµ±è¤‡é›œåº¦ï¼Œç•°å¸¸å¢é•·å¯èƒ½è¡¨ç¤ºè¨˜æ†¶é«”æ´©æ¼
- `listenerCounts`: ç”¨æ–¼é©—è­‰é—œéµäº‹ä»¶æ˜¯å¦æœ‰è¶³å¤ è™•ç†å™¨

#### æ•ˆèƒ½æŒ‡æ¨™åˆ†æ
- `totalEvents`: ç³»çµ±æ´»èºåº¦æŒ‡æ¨™ï¼Œå¯ç”¨æ–¼è² è¼‰åˆ†æ
- `totalExecutionTime`: æ•´é«”è™•ç†æ•ˆèƒ½ï¼Œç•°å¸¸å¢é•·éœ€æª¢æŸ¥è™•ç†å™¨æ•ˆç‡
- `lastActivity`: ç³»çµ±ç”Ÿå‘½é€±æœŸè¿½è¹¤ï¼Œç”¨æ–¼åˆ¤æ–·æ˜¯å¦æ­£å¸¸é‹ä½œ

### æ³¨æ„äº‹é …èˆ‡æœ€ä½³å¯¦è¸

1. **çµ±è¨ˆè³‡æ–™å³æ™‚æ€§**: æ‰€æœ‰çµ±è¨ˆè³‡æ–™éƒ½æ˜¯å³æ™‚è¨ˆç®—ï¼Œåæ˜ ç•¶å‰äº‹ä»¶ç³»çµ±ç‹€æ…‹
2. **è¨˜æ†¶é«”è€ƒé‡**: çµ±è¨ˆè³‡æ–™å ç”¨è¨˜æ†¶é«”æ¥µå°‘ï¼Œä½†åœ¨å¤§é‡äº‹ä»¶è§¸ç™¼æ™‚ `totalExecutionTime` æœƒæŒçºŒç´¯ç©
3. **é™¤éŒ¯æ‡‰ç”¨**: å»ºè­°åœ¨é–‹ç™¼å’Œæ¸¬è©¦éšæ®µé »ç¹ä½¿ç”¨ï¼Œç”Ÿç”¢ç’°å¢ƒå¯ç”¨æ–¼å¥åº·æª¢æŸ¥
4. **API ç©©å®šæ€§**: è¿”å›ç‰©ä»¶çµæ§‹ä¿æŒå‘å¾Œç›¸å®¹ï¼Œæ–°å¢æ¬„ä½ä¸æœƒç ´å£æ—¢æœ‰ä»£ç¢¼

### ç›¸é—œ API

- `hasListener(eventType)`: æª¢æŸ¥ç‰¹å®šäº‹ä»¶æ˜¯å¦æœ‰ç›£è½å™¨
- `getListenerCount(eventType)`: å–å¾—ç‰¹å®šäº‹ä»¶çš„ç›£è½å™¨æ•¸é‡
- `getEventStats(eventType)`: å–å¾—ç‰¹å®šäº‹ä»¶çš„è©³ç´°çµ±è¨ˆï¼ˆè§¸ç™¼æ¬¡æ•¸ã€åŸ·è¡Œæ™‚é–“ç­‰ï¼‰

### ç‰ˆæœ¬æ­·å²

- **v0.8.8**: æ–°å¢ `totalEvents` å’Œ `lastActivity` æ¬„ä½ï¼Œæå‡èˆ‡ Background æ•´åˆçš„ç›¸å®¹æ€§
- **v0.8.5**: å»ºç«‹åŸºç¤ `getStats()` å¯¦ç¾ï¼ŒåŒ…å«ç›£è½å™¨çµ±è¨ˆ
- **åˆå§‹ç‰ˆæœ¬**: äº‹ä»¶ç³»çµ±æ ¸å¿ƒåŠŸèƒ½å»ºç«‹
