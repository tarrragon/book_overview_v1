# 🤝 TDD 協作開發流程：設計師導向的團隊協作

**TDD 不只是開發方法，更是一個完整的團隊協作流程**，包含：

- 🎨 **功能設計師**: 負責功能規劃和需求分析
- 🧪 **測試工程師**: 負責測試設計和測試案例撰寫
- 💻 **實作工程師**: 負責功能實作和測試通過
- 🏗️ **重構設計師**: 負責程式碼品質改善和架構優化

## 🎯 TDD 協作核心原則

1. **工作日誌驅動**: 每個階段都有對應的工作日誌，記錄思考過程和交接資訊
2. **角色明確分工**: 每個角色有明確的職責和交付物
3. **文件化交接**: 透過工作日誌進行角色間的知識傳遞
4. **測試先行**: 絕對不在沒有測試的情況下寫程式碼
5. **品質不妥協**: 每個階段都有品質門檻，不達標不進入下一階段

## 🔄 TDD 完整協作流程

TDD 協作流程分為四個明確的階段，每個階段都有專門的角色負責：

### 🎨 Phase 1: 功能設計師 - 需求分析與功能規劃

**負責角色**: 功能設計師  
**目標**: 建立清楚的功能需求和設計規範，為後續測試和實作奠定基礎

**必須建立新工作日誌**: `docs/work-logs/vX.X.X-feature-design.md`

**工作日誌必須包含內容**:

```markdown
## 功能設計規劃

### 功能需求分析：

- 這個功能要解決什麼問題？
- 使用者的具體使用場景是什麼？
- 功能的核心價值和期望效果是什麼？

### 功能規格設計：

- 功能的輸入是什麼？（參數、資料、使用者互動）
- 功能的輸出是什麼？（回傳值、副作用、使用者回饋）
- 正常流程的步驟是什麼？
- 異常情況的處理方式是什麼？

### 邊界條件分析：

- 極端輸入情況（空值、超大值、無效值）
- 系統限制和約束條件
- 錯誤情況和例外狀況

### API/介面設計：

- 函數簽名或 API 接口定義
- 資料結構和類型定義
- 與其他模組的互動方式

### 驗收標準：

- 功能正確性的驗證方法
- 效能要求和品質標準
- 使用者體驗的期望標準
```

**交接給測試工程師**:

- [ ] 功能需求清楚且具體
- [ ] API 介面定義完整
- [ ] 邊界條件和異常情況已識別
- [ ] 驗收標準明確可驗證

### 🔍 Phase 1 專家審查：Linux設計品質檢查

**觸發時機**: 功能設計師完成設計規劃後，測試工程師開始前
**負責專家**: linux (Linus Torvalds 程式碼品質專家)

**Linux專家審查重點**:

- **實際問題驗證**: "Is this a real problem or imaginary?" - 拒絕過度設計
- **簡化機會識別**: "Is there a simpler way?" - 尋找最簡解決方案
- **複雜度評估**: 設計是否超過必要複雜度，能否消除特殊情況
- **Good Taste評分**: 設計是否展現技術直覺和經驗積累

**Linux審查輸出標準**:

```markdown
## Linux專家設計審查 (Phase 1)

**Taste Score**: Good taste / Acceptable / Garbage

**核心判斷**: Worth doing [reason] / Not worth doing [reason]

**關鍵洞察**:

- 資料結構: [最關鍵的資料關係]
- 複雜度: [可以消除的複雜度]
- 風險點: [最大的破壞性風險]

**改善建議**:

- [具體的設計簡化建議]
- [特殊情況消除方法]
- [資料結構優化方向]
```

**審查通過標準**:

- [ ] 設計解決實際存在的問題
- [ ] 複雜度合理且必要
- [ ] 沒有可消除的特殊情況
- [ ] 符合"Good Taste"原則

### 🧠 Phase 1 知識捕獲：Memory Network Builder

**觸發條件**: Linux專家審查評定為"Good Taste"或發現重要設計洞察時
**負責Agent**: memory-network-builder

**自動觸發場景**:

- Linux專家評定為"Good Taste"的設計模式
- 發現可消除特殊情況的資料結構設計
- 重要的架構決策和設計原則
- 複雜度簡化的具體方法

**Memory捕獲範例**:

```markdown
Memory類型: decision
標題範例: "使用事件驅動架構消除模組間直接依賴"
觸發原因: Linux專家識別出消除特殊情況的優秀設計
連結: 基於 [[SOLID原則]] → 導致 [[模組解耦策略]]
```

**知識捕獲標準**:

- [ ] 捕獲具體的設計決策和原理
- [ ] 建立與相關概念的連結
- [ ] 記錄決策的前因後果
- [ ] 使用結論導向的標題格式

### 🧪 Phase 2: 測試工程師 - 測試案例設計與實作

**負責角色**: 測試工程師  
**目標**: 根據功能設計，設計並實作完整的測試案例

**在原工作日誌中新增測試設計章節**:

```markdown
## 測試案例設計

### 測試策略規劃：

基於功能設計師的需求分析，設計以下測試策略：

- 單元測試：測試核心邏輯和邊界條件
- 整合測試：測試與其他模組的互動
- 端對端測試：測試完整的使用者流程

### 具體測試案例：

#### 正常流程測試：

- [測試案例1]: Given [前置條件], When [執行動作], Then [預期結果]
- [測試案例2]: Given [前置條件], When [執行動作], Then [預期結果]

#### 邊界條件測試：

- [邊界測試1]: Given [邊界情況], When [執行動作], Then [預期結果]
- [邊界測試2]: Given [極端輸入], When [執行動作], Then [預期結果]

#### 異常情況測試：

- [異常測試1]: Given [錯誤條件], When [執行動作], Then [預期錯誤處理]
- [異常測試2]: Given [無效輸入], When [執行動作], Then [預期錯誤回應]

### 測試環境設置：

- Mock 物件設計：[列出需要的 Mock]
- 測試資料準備：[列出測試所需資料]
- 測試清理策略：[說明測試後的清理方法]

### 測試實作記錄：

- 實作的測試檔案：[列出建立的測試檔案]
- 測試覆蓋的功能點：[記錄測試涵蓋範圍]
- 發現的設計問題：[記錄在設計測試過程中發現的問題]
```

**實際執行工作**:

1. **撰寫失敗的測試**: 根據設計實作具體的測試程式碼
2. **驗證測試失敗**: 確保測試在沒有實作時會失敗
3. **測試品質檢查**: 確保測試程式碼品質和覆蓋率

**交接給實作工程師**:

- [ ] 所有測試案例已實作為程式碼
- [ ] 測試在沒有功能實作時會失敗（紅燈狀態）
- [ ] 測試覆蓋率達到設計要求
- [ ] 測試程式碼品質良好且可維護

### 🔍 Phase 2 專家審查：雙專家測試品質檢查

**觸發時機**: 測試工程師完成測試案例實作後，實作規劃師開始前
**負責專家**: linux + john-carmack (雙專家聯合審查)

**Linux專家測試審查重點**:

- **測試複雜度評估**: 測試是否過度複雜，能否簡化
- **邊界條件充分性**: 是否測試了所有實際可能的邊界情況
- **真實問題覆蓋**: 測試是否針對實際存在的問題，避免理論測試

**John Carmack效能測試審查重點**:

- **熱路徑測試覆蓋**: 效能關鍵路徑是否有充分測試
- **確定性行為驗證**: 測試是否驗證可預測的行為模式
- **最壞情況測試**: 是否包含最壞情況和極端負載的測試場景
- **狀態管理測試**: 副作用最小化和純函數測試覆蓋

**雙專家審查輸出標準**:

```markdown
## 雙專家測試審查 (Phase 2)

### Linux測試品質審查

**Taste Score**: Good taste / Acceptable / Garbage
**致命問題**: [如有，直接指出最差的部分]
**改善方向**:

- [消除這個特殊情況]
- [這些10行可以變成3行]

### John Carmack效能測試審查

**熱路徑覆蓋**: Comprehensive / Adequate / Insufficient
**確定性驗證**: Strong / Moderate / Weak
**關鍵發現**:

- [效能關鍵路徑識別]
- [狀態管理模式評估]
- [最壞情況處理]

### 聯合建議

- [測試架構改善建議]
- [效能測試加強方向]
- [測試複雜度簡化方法]
```

**雙專家審查通過標準**:

- [ ] Linux: 測試複雜度合理，覆蓋實際問題
- [ ] John Carmack: 效能關鍵路徑測試充分
- [ ] 確定性行為驗證完整
- [ ] 最壞情況測試涵蓋適當

### 🧠 Phase 2 知識捕獲：Memory Network Builder

**觸發條件**: 雙專家審查發現有效測試策略或測試設計洞察時
**負責Agent**: memory-network-builder

**自動觸發場景**:

- 發現特別有效的邊界條件測試策略
- John Carmack識別的效能測試關鍵點
- Linux認可的測試複雜度控制方法
- 確定性行為驗證的創新方法

**Memory捕獲範例**:

```markdown
Memory類型: learning  
標題範例: "邊界條件測試比正常流程測試更容易暴露設計缺陷"
觸發原因: Linux專家發現測試策略的重要洞察
連結: 基於 [[邊界條件分析]] → 導致 [[測試驅動設計改善]]
```

**雙專家協作捕獲**:

```markdown
Memory類型: concept
標題範例: "熱路徑測試需要最壞情況和平均情況雙重覆蓋"  
觸發原因: John Carmack + Linux 專家聯合發現
連結: 基於 [[確定性系統設計]] → 導致 [[效能測試策略]]
```

**知識捕獲標準**:

- [ ] 記錄有效的測試方法和策略
- [ ] 捕獲專家認可的測試模式
- [ ] 建立測試策略間的知識連結
- [ ] 記錄測試複雜度控制的原則

### 💻 Phase 3: 實作規劃師 - 實作策略規劃與開發指引

**負責角色**: 實作規劃師  
**目標**: 規劃實作策略，提供主線程完整的開發指引和程式碼範例

**在原工作日誌中新增實作規劃章節**: 包含實作策略設計、詳細實作指引、權宜方案與技術債務、驗證與品質保證

- **實作步驟**: [Step-by-step 具體編碼指引]
- **預期問題與解決方案**: [可能遇到的技術挑戰和建議解法]

#### 第二階段實作指引：

- **目標測試群組**: [下一組要通過的測試]
- **程式碼範例**: [繼續實作的關鍵程式碼]
- **整合策略**: [與前一階段程式碼的整合方法]

### 權宜方案與技術債務：

- **最小可用實作**: [讓測試通過的最簡單方案]
- **//todo: 改善方向**: [標註所有需要後續改善的具體項目]
- **已知限制記錄**: [當前實作的限制和約束條件]
- **重構準備**: [為重構設計師提供的改善建議]

### 驗證與品質保證：

- **測試通過策略**: [如何讓每個測試案例通過的具體方法]
- **程式碼品質檢查**: [Linter 規則遵循、最佳實踐應用]
- **效能考量**: [效能要求和優化建議]

**主線程實作責任** (按照規劃執行):
1. **按指引實作功能**: 根據規劃的程式碼範例和步驟進行編碼
2. **驗證測試套件**: 確保 100% 測試通過率
3. **程式碼品質檢查**: 通過 lint 和 build 檢查
4. **記錄實作過程**: 在工作日誌中記錄實際實作結果和遇到的問題

**實作完成標準** (交接給重構設計師):
- [ ] 所有測試 100% 通過
- [ ] 功能按照設計規格和實作規劃正確實作
- [ ] 程式碼品質檢查通過
- [ ] 實作過程完整記錄，包含與規劃的差異和問題解決

### 🔍 Phase 3 專家審查：John Carmack架構效能檢查

**觸發時機**: 實作規劃師完成實作策略後，主線程實作前 + 主線程實作完成後，重構設計師開始前
**負責專家**: john-carmack (John Carmack 效能系統架構師)

**John Carmack實作架構審查重點**:
- **熱路徑清晰度**: 關鍵執行路徑是否明顯且一致
- **最壞情況優化**: 設計是否針對最壞情況效能，而非平均值
- **控制流程簡化**: 條件分支是否過深，能否扁平化
- **狀態管理純度**: 副作用是否最小化，函數式設計機會
- **架構邊界合理性**: 抽象層次是否適當，避免過度抽象

**John Carmack審查輸出標準**:
```markdown
## John Carmack架構效能審查 (Phase 3)

**熱路徑評估**: Clear / Acceptable / Obfuscated
**確定性設計**: Strong / Moderate / Weak
**控制流程**: Flat / Acceptable / Too Deep

**關鍵發現**:
- 熱路徑識別: [主要執行路徑分析]
- 狀態管理: [副作用和全域狀態評估]
- 控制流程: [條件邏輯簡化機會]
- 架構邊界: [抽象層次合理性]

**效能優化建議**:
- [具體的熱路徑優化方向]
- [狀態管理改善策略]
- [控制流程扁平化方法]
- [函數式設計機會]

**架構風險點**:
- [效能瓶頸識別]
- [確定性行為風險]
- [複雜度累積點]
```

**John Carmack審查通過標準**:

- [ ] 熱路徑清晰且優化合理
- [ ] 控制流程扁平化充分
- [ ] 狀態管理符合函數式原則
- [ ] 架構邊界設計合理
- [ ] 確定性行為設計充分

### 🧠 Phase 3 知識捕獲：Memory Network Builder

**觸發條件**: John Carmack專家審查發現重要效能洞察或架構優化時  
**負責Agent**: memory-network-builder

**自動觸發場景**:

- John Carmack識別的熱路徑優化具體方法
- 狀態管理純度改善的實作技巧
- 控制流程扁平化的具體案例
- 確定性行為設計的關鍵模式
- 實作中發現的效能瓶頸解決方案

**Memory捕獲範例**:

```markdown
Memory類型: implementation
標題範例: "使用Map代替Array查找讓搜尋效能提升10倍"
觸發原因: John Carmack專家發現關鍵效能優化點
連結: 基於 [[熱路徑識別]] → 導致 [[資料結構選擇策略]]
```

**架構模式捕獲**:

```markdown
Memory類型: concept
標題範例: "函數式狀態管理三層架構消除副作用"
觸發原因: John Carmack專家認可的狀態管理模式
連結: 基於 [[純函數設計]] → 導致 [[可預測性系統]]
```

**實作技巧捕獲**:

```markdown
Memory類型: learning
標題範例: "控制流程超過3層巢狀必定存在更簡潔的資料結構設計"
觸發原因: 實作過程驗證了John Carmack的架構原則
連結: 基於 [[複雜度控制]] → 導致 [[資料結構重設計]]
```

**知識捕獲標準**:

- [ ] 記錄具體的效能優化數據和方法
- [ ] 捕獲架構邊界設計的成功模式
- [ ] 建立實作技巧與理論原則的連結
- [ ] 記錄確定性設計的具體實作方法

### 🏗️ Phase 4: 重構設計師 - 程式碼品質改善

**負責角色**: 重構設計師  
**目標**: 改善程式碼品質和架構，執行完整的重構方法論

**重要**: 重構設計師必須按照本文件「🧠 TDD 驅動重構方法論」章節的完整流程執行

**工作流程**:

1. **建立重構工作日誌**: 按照重構方法論 Phase 1 要求建立新工作日誌
2. **執行重構**: 按照重構方法論 Phase 2 執行重構並驗證預期
3. **完成重構總結**: 按照重構方法論 Phase 3 完成工作日誌總結

**重構總結工作日誌更新**: 按照「📚 專案文件責任明確區分」章節的工作日誌品質要求進行記錄

**最終交付標準**:

- [ ] 重構方法論完整執行
- [ ] 所有技術債務已解決
- [ ] 程式碼品質達到專案標準
- [ ] 功能完整性確認無損
- [ ] 重構經驗記錄完整

### 🔍 Phase 4 專家審查：Linux最終品質檢查

**觸發時機**: 重構設計師完成所有重構工作後，TDD循環完成前
**負責專家**: linux (Linus Torvalds 程式碼品質專家)

**Linux最終品質審查重點**:

- **重構效果驗證**: 重構是否真正簡化了程式碼，而非增加複雜度
- **Good Taste最終評估**: 最終程式碼是否展現"好品味"和技術直覺
- **複雜度消除確認**: 是否成功消除了不必要的複雜度和特殊情況
- **破壞性檢查**: "Never break userspace" - 確保向後相容性
- **實用主義驗證**: 程式碼是否服務於現實需求，而非理論完美

**Linux最終審查輸出標準**:

```markdown
## Linux最終品質審查 (Phase 4)

**最終Taste Score**: Good taste / Acceptable / Garbage

**重構成效評估**:

- 複雜度變化: [重構前後複雜度對比]
- 特殊情況: [消除的特殊情況數量]
- 程式碼行數: [有意義的程式碼精簡]

**Good Taste評估**:

- 資料結構設計: [是否展現對資料結構的深度理解]
- 算法選擇: [是否選擇了最直觀的解決方法]
- 邊界處理: [特殊情況是否被優雅消除]

**向後相容性檢查**:

- [ ] 沒有破壞現有API
- [ ] 沒有改變外部行為
- [ ] 升級路徑清晰

**最終建議**:

- [如果是Good taste: 讚揚具體的優秀設計]
- [如果是Acceptable: 指出還可改善的地方]
- [如果是Garbage: 要求重新設計的具體理由]
```

**Linux最終審查通過標準**:

- [ ] 程式碼展現"Good Taste"或至少"Acceptable"
- [ ] 複雜度確實降低，沒有增加不必要複雜性
- [ ] 向後相容性完全保持
- [ ] 解決方案務實且直接
- [ ] 沒有為了理論完美而犧牲實用性

### 🧠 Phase 4 知識捕獲：Memory Network Builder

**觸發條件**: Linux最終審查發現"Good Taste"重構模式或重要品質改善時
**負責Agent**: memory-network-builder

**自動觸發場景**:

- Linux專家認證的"Good Taste"重構模式
- 成功消除特殊情況的具體重構方法
- 複雜度大幅降低的重構案例
- 向後相容性維持的重構技巧
- 實用主義導向的架構改善

**重構模式捕獲**:

```markdown
Memory類型: concept
標題範例: "消除if-else特殊情況的三種資料結構重設計模式"
觸發原因: Linux專家認證的"Good Taste"重構方法
連結: 基於 [[特殊情況識別]] → 導致 [[資料結構優化]]
```

**品質改善捕獲**:

```markdown
Memory類型: learning
標題範例: "重構後程式碼行數減少60%且可讀性提升的關鍵因素"
觸發原因: Linux專家驗證的重構成效
連結: 基於 [[複雜度分析]] → 導致 [[程式碼品質提升]]
```

**架構債務解決捕獲**:

```markdown
Memory類型: implementation
標題範例: "模組循環依賴透過事件中介者模式徹底解除"
觸發原因: 重構過程解決關鍵架構債務
連結: 基於 [[依賴解耦]] → 導致 [[模組化架構]]
```

**知識捕獲標準**:

- [ ] 記錄成功的重構模式和方法
- [ ] 捕獲複雜度簡化的具體技巧
- [ ] 建立重構前後的效果對比數據
- [ ] 記錄向後相容性維持的策略
- [ ] 捕獲"Good Taste"的具體體現方式

## 🤝 TDD 協作流程總結

### 📋 完整協作檢查清單

**階段完成驗證**:

- [ ] Phase 1: 功能設計師完成需求分析和功能規劃
  - [ ] Linux專家設計品質審查通過
  - [ ] 🧠 Memory Network Builder 知識捕獲完成 (設計決策和原則)
- [ ] Phase 2: 測試工程師完成測試案例設計和實作
  - [ ] Linux + John Carmack雙專家測試品質審查通過
  - [ ] 🧠 Memory Network Builder 知識捕獲完成 (測試策略和洞察)
- [ ] Phase 3: 實作工程師完成功能實作和測試通過
  - [ ] John Carmack架構效能審查通過
  - [ ] 🧠 Memory Network Builder 知識捕獲完成 (實作技巧和效能優化)
- [ ] Phase 4: 重構設計師完成程式碼品質改善
  - [ ] Linux最終品質審查通過
  - [ ] 🧠 Memory Network Builder 知識捕獲完成 (重構模式和品質改善)

**工作日誌品質**: 必須符合「[📚 專案文件責任明確區分](./document-responsibilities.md)」章節的文件品質標準

**最終交付標準**:

- [ ] 所有測試 100% 通過
- [ ] 程式碼品質達到專案標準
- [ ] 功能完全符合原始設計規格
- [ ] 沒有未解決的技術債務
- [ ] 完整的開發過程可追蹤
- [ ] **所有專家審查通過** (Linux設計審查 + 雙專家測試審查 + John Carmack架構審查 + Linux最終審查)
- [ ] **專家審查建議全部實施** 或有明確原因記錄為何不實施
- [ ] **🧠 知識網路完整建立**: 所有重要洞察已捕獲為Memory並建立適當連結
- [ ] **Memory品質驗證**: 所有Memory標題結論導向，內容原子化，連結關係明確

### 🔍 TODO 狀態驗證機制 (v0.9.24 新增預防措施)

**背景**: 為防止專案文件與實際狀況不一致的問題 (如 v0.9.24 發現的 Popup 狀態不一致問題)，建立強制性的狀態驗證機制。

**🚨 每個 TDD 循環完成後的必要檢查**:

**文件更新檢查**: 按照「[📚 專案文件責任明確區分](./document-responsibilities.md)」章節的要求執行：

- [ ] **工作日誌更新**: 符合工作日誌品質標準
- [ ] **TODO.md狀態同步**: 符合TODO.md品質標準
- [ ] **CHANGELOG.md更新**: 符合CHANGELOG.md品質標準

**實際狀況交叉驗證**:

- [ ] **測試檔案確認**: 聲稱完成的功能必須有對應的測試檔案
- [ ] **程式碼實作確認**: 檢查實際程式碼是否支持 TODO 中的功能聲明
- [ ] **版本號一致性**: 確保各檔案中的版本號保持一致
- [ ] **架構文件同步**: 更新相關的架構文件和說明

**版本發布前的全面驗證**:

- [ ] **批次狀態檢查**: 檢查所有聲稱完成的項目是否有實際實作
- [ ] **測試覆蓋驗證**: 確認測試覆蓋率聲明與實際測試結果一致
- [ ] **工作日誌完整性**: 驗證重要功能都有對應的開發記錄
- [ ] **CHANGELOG 同步**: 確保版本變更記錄反映真實的功能變更

**🛠️ 推薦的驗證工具**:

```bash
# 建議建立的驗證腳本概念
verify_project_consistency() {
  echo "🔍 檢查 TODO 狀態一致性..."
  # 檢查 TODO 中聲稱完成的功能是否有對應測試檔案
  # 檢查版本號在 TODO.md, CHANGELOG.md, package.json 中是否一致
  # 驗證工作日誌的完整性
}
```

**📋 問題發現時的標準處理流程**:

1. **立即停止當前工作**: 優先處理狀態不一致問題
2. **系統性調查**: 使用程式碼分析、測試檢查、歷史記錄搜尋等方法
3. **實際狀況導向修正**: 基於具體實作情況進行文件修正
4. **建立預防機制**: 設計防止類似問題再次發生的具體措施
5. **完整記錄過程**: 建立工作日誌記錄發現和修正的完整過程

---

## 🧠 TDD 驅動重構方法論：預期管理與工作日誌為核心

### 🎯 重構核心原則：預期管理與驗證

**重構是預期管理與驗證的思考框架，不是執行步驟**：

- **預期管理**: 重構前先預期哪些測試會通過、哪些會失敗、為什麼失敗
- **驗證預期**: 執行重構後檢查結果是否符合預期
- **預期偏差處理**: 若結果不符合預期，分析原因並調整計劃
- **工作日誌記錄**: 記錄整個思考和驗證過程，確保知識傳承和協作透明

### 📝 Phase 1: 重構計劃與工作日誌建立

**必須建立新工作日誌的原因**: 確保重構思考過程可追蹤、協作透明、知識不流失

**工作日誌必須回答的問題**:

1. **🎯 重構動機與目標**:

   ```markdown
   ## 為什麼要重構？

   - 當前架構的具體問題是什麼？
   - 重構後期望達成的狀態是什麼？
   - 這個重構如何解決核心問題？
   ```

2. **🔍 影響範圍分析**:

   ```markdown
   ## 預期影響的程式碼和行為

   - 哪些檔案會被修改？
   - 哪些功能的行為會改變？
   - 哪些 API 或介面會受影響？
   ```

3. **🧪 測試預期管理**:

   ```markdown
   ## 測試結果預期

   ### 預期會通過的測試：

   - [列出具體測試檔案和測試名稱]
   - 為什麼這些測試應該繼續通過？

   ### 預期會失敗的測試：

   - [列出具體測試檔案和測試名稱]
   - 為什麼這些測試會失敗？失敗的原因是什麼？
   - 怎麼修正這些失敗？

   ### 不確定的測試：

   - [可能會受影響的測試]
   - 為什麼不確定？需要特別注意什麼？
   ```

4. **📊 成功標準設定**:
   ```markdown
   ## 重構成功的標準

   - 測試結果符合預期的標準是什麼？
   - 程式碼品質的要求是什麼？
   - 效能或使用者體驗的標準是什麼？
   ```

### 🚀 Phase 2: 重構執行與預期驗證

**執行目的**: 驗證重構計劃中的預期是否正確，不是單純的執行步驟

**Step 1: 執行重構**

```bash
# 按照計劃執行重構
# [這裡是具體的重構動作]
```

**Step 2: 驗證測試結果**

```bash
npm test                # 執行所有測試
npm run test:unit       # 單元測試
npm run test:integration # 整合測試
```

**Step 3: 對比預期與實際結果**

**情境 A: 結果符合預期 ✅**

- 預期通過的測試都通過了
- 預期失敗的測試都失敗了，且失敗原因符合預期
- 不確定的測試結果都在可接受範圍內

**對應行動**: 更新工作日誌

```markdown
## 重構結果驗證 - 符合預期 ✅

### 測試結果記錄：

- [具體記錄測試結果]

### 重構過程發現：

- [記錄重構過程中的發現和決策]

### 下一步：

- 重構目標已達成，繼續後續優化
```

**情境 B: 結果不符合預期 ❌**

- 預期通過的測試失敗了
- 預期失敗的測試通過了，或失敗原因與預期不符
- 出現了預期之外的測試失敗

**對應行動**: 更新工作日誌，分析偏差

```markdown
## 重構結果驗證 - 不符合預期 ❌

### 預期偏差分析：

- [具體記錄哪些預期出現偏差]
- [分析為什麼會有偏差]
- [記錄意外發現的問題]

### 下一步行動決策：

- ☀️ 選擇1: 修正當前問題，繼續原計劃
- 🔄 選擇2: 調整重構計劃，縮小範圍
- 🏠 選擇3: 回到穩定狀態，重新設計
```

### 📝 Phase 3: 重構完成與工作日誌總結

**完成驗證目的**: 確保重構達成目標，並記錄學習成果供未來參考

**最終驗證檢查**:

```bash
# 基本功能驗證
npm test                # 所有測試必須通過
npm run test:unit       # 單元測試必須通過
npm run test:integration # 整合測試必須通過

# 品質與效能驗證
npm run lint            # Linter 檢查必須通過
npm run build           # 建置必須成功
npm run test:coverage   # 測試覆蓋率檢查
```

**工作日誌總結更新**:

```markdown
## 重構總結與學習

### 目標達成情況：

- [ ] 原定目標是否達成？
- [ ] 架構問題是否得到解決？
- [ ] 程式碼品質是否符合預期？

### 預期管理的學習：

- 哪些預期是正確的？為什麼？
- 哪些預期是錯誤的？為什麼？
- 下次類似重構應該注意什麼？

### 方法論的改進：

- 重構計劃的哪些部分需要改進？
- 測試預期的方法可以怎麼優化？
- 未來類似問題的預防策略是什麼？
```

### 📋 重構方法論檢查清單

**重構開始前**:

- [ ] 已建立新的工作日誌
- [ ] 明確記錄重構動機和目標
- [ ] 詳細分析影響範圍
- [ ] 建立測試結果預期
- [ ] 設定成功標準

**重構過程中**:

- [ ] 測試結果與預期對比
- [ ] 預期偏差的立即分析
- [ ] 工作日誌的即時更新

**重構完成後**:

- [ ] 目標達成情況的總結
- [ ] 預期管理的學習記錄
- [ ] 方法論改進建議
- [ ] 未來預防策略建立

---

**🔗 相關文件連結**:
- [返回主指導文件](./../../CLAUDE.md)
- [專案文件責任明確區分](./document-responsibilities.md)
- [Agent 協作規範](./agent-collaboration.md)