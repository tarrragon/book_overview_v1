/**
 * Chrome Extension v2.0 Áí∞Â¢ÉÊï¥ÂêàÊ∏¨Ë©¶
 *
 * Ë≤†Ë≤¨ÂäüËÉΩÔºö
 * - Background Service Worker Ëàá‰∫ã‰ª∂Á≥ªÁµ± v2.0 Êï¥ÂêàÊ∏¨Ë©¶
 * - Content Scripts ÁöÑ‰∫ã‰ª∂ËôïÁêÜÂíå DOM ‰∫íÂãïÈ©óË≠â
 * - Popup ÁïåÈù¢ÁöÑ‰∫ã‰ª∂È©ÖÂãïÂäüËÉΩÂÆåÊï¥Ê∏¨Ë©¶
 * - Ë∑®‰∏ä‰∏ãÊñá‰∫ã‰ª∂ÂÇ≥ÈÅûÂíåÈÄöË®äÂçîË≠∞È©óË≠â
 *
 * Ê∏¨Ë©¶Á≠ñÁï•Ôºö
 * - ÁúüÂØ¶ Chrome Extension Áí∞Â¢ÉÊ®°Êì¨
 * - ÂÆåÊï¥Êì¥Â±ïÁîüÂëΩÈÄ±ÊúüÊ∏¨Ë©¶
 * - Ë∑®‰∏ä‰∏ãÊñáÈÄöË®äÂçîË≠∞È©óË≠â
 * - ÂØ¶Èöõ‰ΩøÁî®ËÄÖÊìç‰ΩúÊµÅÁ®ãÊ®°Êì¨
 *
 * Êï¥ÂêàÊ∏¨Ë©¶ÁØÑÂúçÔºö
 * - Service Worker ÁîüÂëΩÈÄ±Êúü 100% Ë¶ÜËìã
 * - ‰∫ã‰ª∂ÂÇ≥ÈÅûÊ∫ñÁ¢∫ÊÄß 100% È©óË≠â
 * - UI ÈüøÊáâÊÄßËÉΩÊåáÊ®ôÈÅîÊ®ô
 * - ÈåØË™§ÊÅ¢Âæ©Ê©üÂà∂ÂÆåÊï¥Ê∏¨Ë©¶
 * - Èï∑ÊôÇÈñìÈÅãË°åÁ©©ÂÆöÊÄßÈ©óË≠â
 */

const EventBus = require('src/core/event-bus')
const ChromeEventBridge = require('src/content/bridge/chrome-event-bridge')
const EventNamingUpgradeCoordinator = require('src/core/events/event-naming-upgrade-coordinator')
const EventPriorityManager = require('src/core/events/event-priority-manager')

// Ê®°Êì¨ Chrome Extension Áí∞Â¢É
global.chrome = require('jest-chrome').chrome
global.self = global

describe('üß™ Chrome Extension v2.0 Áí∞Â¢ÉÊï¥ÂêàÊ∏¨Ë©¶', () => {
  let eventBus
  let chromeBridge
  let namingCoordinator
  let priorityManager
  let mockTabId

  beforeEach(async () => {
    // ÈáçÁΩÆ Chrome API mocks
    jest.clearAllMocks()
    if (chrome && chrome.flush) {
      chrome.flush()
    }

    // ÂàùÂßãÂåñ Chrome Extension Áí∞Â¢É
    mockTabId = 123

    // Ë®≠ÁΩÆ Chrome APIs Ê®°Êì¨
    chrome.tabs.sendMessage.mockResolvedValue({ success: true })
    chrome.runtime.sendMessage.mockResolvedValue({ success: true })
    chrome.storage.local.get.mockResolvedValue({})
    chrome.storage.local.set.mockResolvedValue()

    // ÂàùÂßãÂåñ‰∫ã‰ª∂Á≥ªÁµ±ÁµÑ‰ª∂
    eventBus = new EventBus()
    namingCoordinator = new EventNamingUpgradeCoordinator(eventBus)
    priorityManager = new EventPriorityManager()
    chromeBridge = new ChromeEventBridge(eventBus)

    // Âª∫Á´ãÊï¥ÂêàÁí∞Â¢ÉÂÆåÊàê

    // Á≠âÂæÖÂàùÂßãÂåñÂÆåÊàê
    await new Promise(resolve => setTimeout(resolve, 50))
  })

  afterEach(() => {
    // Ê∏ÖÁêÜË≥áÊ∫ê
    if (eventBus && typeof eventBus.removeAllListeners === 'function') {
      eventBus.removeAllListeners()
    }
  })

  describe('üîß Background Service Worker Êï¥ÂêàÊ∏¨Ë©¶', () => {
    describe('Service Worker ÁîüÂëΩÈÄ±ÊúüÊï¥Âêà', () => {
      test('ÊáâË©≤Âú® Service Worker ÂïüÂãïÊôÇÊ≠£Á¢∫ÂàùÂßãÂåñ‰∫ã‰ª∂Á≥ªÁµ±', async () => {
        // Ê®°Êì¨ Service Worker ÂïüÂãï‰∫ã‰ª∂
        const onStartupHandler = jest.fn()
        eventBus.on('SYSTEM.GENERIC.STARTUP.COMPLETED', onStartupHandler)

        // Ëß∏ÁôºÂïüÂãïÊµÅÁ®ã
        await chromeBridge.handleServiceWorkerStartup()

        // È©óË≠â‰∫ã‰ª∂Á≥ªÁµ±ÂàùÂßãÂåñ
        expect(eventBus).toBeDefined()
        expect(chromeBridge).toBeDefined()
        expect(namingCoordinator).toBeDefined()
        expect(priorityManager).toBeDefined()

        // ÁôºÈÄÅÂïüÂãïÂÆåÊàê‰∫ã‰ª∂
        await eventBus.emit('SYSTEM.GENERIC.STARTUP.COMPLETED', {
          timestamp: Date.now(),
          components: ['eventBus', 'chromeBridge', 'namingCoordinator']
        })

        expect(onStartupHandler).toHaveBeenCalled()
      })

      test('ÊáâË©≤Âú® Service Worker ÂÆâË£ùÊôÇË®≠ÁΩÆÈ†êË®≠ÈÖçÁΩÆ', async () => {
        // Ê®°Êì¨Êì¥Â±ïÂÆâË£ù
        const installDetails = { reason: 'install' }

        // Ëß∏ÁôºÂÆâË£ù‰∫ã‰ª∂ËôïÁêÜ
        await chromeBridge.handleInstallation(installDetails)

        // È©óË≠âÈ†êË®≠ÈÖçÁΩÆË¢´Ë®≠ÁΩÆ
        expect(chrome.storage.local.set).toHaveBeenCalledWith(
          expect.objectContaining({
            isEnabled: true,
            extractionSettings: expect.any(Object),
            eventSystemVersion: '2.0.0'
          })
        )
      })

      test('ÊáâË©≤Âú® Service Worker ÈáçÂïüÊôÇÊÅ¢Âæ©‰∫ã‰ª∂Á≥ªÁµ±ÁãÄÊÖã', async () => {
        // Ë®≠ÁΩÆ‰∏Ä‰∫õ‰∫ã‰ª∂Áõ£ËÅΩÂô®ÂíåÁãÄÊÖã
        const testHandler = jest.fn()
        namingCoordinator.registerDualTrackListener('EXTRACTION.COMPLETED', testHandler)

        const testEvent = 'EXTRACTION.READMOO.EXTRACT.COMPLETED'
        priorityManager.assignEventPriority(testEvent)

        // Ë®òÈåÑÈáçÂïüÂâçÁöÑÁãÄÊÖã

        // Ê®°Êì¨ Service Worker ÈáçÂïü
        await chromeBridge.handleServiceWorkerRestart()

        // È©óË≠âÂü∫Êú¨ÂäüËÉΩÊÅ¢Âæ©
        await namingCoordinator.intelligentEmit('EXTRACTION.COMPLETED', { test: 'restart' })

        // Á≠âÂæÖ‰∫ã‰ª∂ËôïÁêÜ
        await new Promise(resolve => setTimeout(resolve, 100))

        expect(testHandler).toHaveBeenCalled()
      })

      test('ÊáâË©≤ËôïÁêÜ Service Worker ‰ºëÁú†ÂíåÂñöÈÜí', async () => {
        // Ë®≠ÁΩÆ‰∫ã‰ª∂Áµ±Ë®à
        await namingCoordinator.intelligentEmit('STORAGE.SAVE.COMPLETED', { books: 5 })
        const preSleepStats = namingCoordinator.getConversionStats()

        // Ê®°Êì¨‰ºëÁú†
        await chromeBridge.handleServiceWorkerSleep()

        // Ê®°Êì¨ÂñöÈÜí
        await chromeBridge.handleServiceWorkerWakeup()

        // È©óË≠â‰∫ã‰ª∂Á≥ªÁµ±‰ªçÁÑ∂ÂèØÁî®
        const testHandler = jest.fn()
        eventBus.on('SYSTEM.GENERIC.WAKEUP.COMPLETED', testHandler)

        await eventBus.emit('SYSTEM.GENERIC.WAKEUP.COMPLETED', {
          previousStats: preSleepStats,
          timestamp: Date.now()
        })

        expect(testHandler).toHaveBeenCalled()
      })
    })

    describe('Ë∑®‰∏ä‰∏ãÊñáË®äÊÅØÂÇ≥ÈÅûÊï¥Âêà', () => {
      test('ÊáâË©≤Ê≠£Á¢∫ËôïÁêÜ‰æÜËá™ Content Script ÁöÑ‰∫ã‰ª∂Ë®äÊÅØ', async () => {
        const contentMessage = {
          type: 'EVENT_FORWARD',
          eventType: 'EXTRACTION.READMOO.EXTRACT.STARTED',
          eventData: {
            url: 'https://readmoo.com/book/123',
            timestamp: Date.now()
          },
          from: 'content'
        }

        const mockSender = { tab: { id: mockTabId } }
        const mockSendResponse = jest.fn()

        // Ë®≠ÁΩÆ‰∫ã‰ª∂Áõ£ËÅΩÂô®
        const eventHandler = jest.fn()
        eventBus.on('EXTRACTION.READMOO.EXTRACT.STARTED', eventHandler)

        // ËôïÁêÜ‰æÜËá™ Content Script ÁöÑË®äÊÅØ
        await chromeBridge.handleMessageFromContent(contentMessage, mockSender, mockSendResponse)

        // È©óË≠â‰∫ã‰ª∂Ë¢´Ê≠£Á¢∫ËΩâÁôº
        expect(eventHandler).toHaveBeenCalled()
        expect(mockSendResponse).toHaveBeenCalledWith({
          success: true,
          eventForwarded: true
        })
      })

      test('ÊáâË©≤Ê≠£Á¢∫ËôïÁêÜ‰æÜËá™ Popup ÁöÑÊéßÂà∂Ë®äÊÅØ', async () => {
        const popupMessage = {
          type: 'CONTROL_REQUEST',
          action: 'GET_EXTRACTION_STATUS',
          data: {},
          from: 'popup'
        }

        const mockSender = { tab: undefined } // Popup Ê≤íÊúâ tab
        const mockSendResponse = jest.fn()

        // Ë®≠ÁΩÆÁãÄÊÖãÂõûÊáâ

        // ËôïÁêÜ‰æÜËá™ Popup ÁöÑË®äÊÅØ
        await chromeBridge.handleMessageFromPopup(popupMessage, mockSender, mockSendResponse)

        // È©óË≠âÈÅ©Áï∂ÁöÑÂõûÊáâ
        expect(mockSendResponse).toHaveBeenCalledWith(
          expect.objectContaining({
            success: true,
            data: expect.any(Object)
          })
        )
      })

      test('ÊáâË©≤ÊîØÊè¥Âêë Content Script ÁôºÈÄÅÊéßÂà∂Êåá‰ª§', async () => {
        const controlCommand = {
          type: 'CONTROL_COMMAND',
          command: 'START_EXTRACTION',
          parameters: {
            target: 'bookshelf',
            mode: 'incremental'
          }
        }

        // ÁôºÈÄÅÊåá‰ª§Âà∞ Content Script
        const result = await chromeBridge.sendToContent(mockTabId, controlCommand)

        // È©óË≠â Chrome API Ë¢´Ê≠£Á¢∫Ë™øÁî®
        expect(chrome.tabs.sendMessage).toHaveBeenCalledWith(mockTabId, controlCommand)
        expect(result.success).toBe(true)
      })

      test('ÊáâË©≤ÊîØÊè¥Âêë Popup Âª£Êí≠ÁãÄÊÖãÊõ¥Êñ∞', async () => {
        const statusUpdate = {
          type: 'STATUS_UPDATE',
          data: {
            extractionProgress: 60,
            currentBook: 'Book Title',
            estimatedTimeRemaining: '2 minutes'
          }
        }

        // Âª£Êí≠ÁãÄÊÖãÊõ¥Êñ∞
        await chromeBridge.broadcastToPopups(statusUpdate)

        // È©óË≠âË®äÊÅØË¢´Ê≠£Á¢∫ÁôºÈÄÅ
        expect(chrome.runtime.sendMessage).toHaveBeenCalledWith(statusUpdate)
      })
    })

    describe('‰∫ã‰ª∂Á≥ªÁµ± v2.0 Êï¥ÂêàÈ©óË≠â', () => {
      test('ÊáâË©≤ÂÆåÊï¥ÊîØÊè¥ Legacy Âà∞ Modern ‰∫ã‰ª∂ËΩâÊèõ', async () => {
        const legacyEvents = [
          'EXTRACTION.COMPLETED',
          'STORAGE.SAVE.COMPLETED',
          'UI.POPUP.OPENED'
        ]

        // Ë®≠ÁΩÆÈõôËªåÁõ£ËÅΩÂô®
        for (let i = 0; i < legacyEvents.length; i++) {
          const legacyEvent = legacyEvents[i]

          const handler = jest.fn()
          namingCoordinator.registerDualTrackListener(legacyEvent, handler)

          // ÈÄöÈÅé Chrome Bridge Ëß∏Áôº‰∫ã‰ª∂
          await chromeBridge.forwardEventFromContent({
            eventType: legacyEvent,
            eventData: { test: `event-${i}` },
            tabId: mockTabId
          })

          // È©óË≠â‰∫ã‰ª∂Ë¢´Ê≠£Á¢∫ËôïÁêÜ
          expect(handler).toHaveBeenCalled()
        }
      })

      test('ÊáâË©≤Ê≠£Á¢∫ËôïÁêÜÂÑ™ÂÖàÁ¥ö‰∫ã‰ª∂Âú®Ë∑®‰∏ä‰∏ãÊñáÁí∞Â¢É‰∏≠', async () => {
        const highPriorityEvent = 'SYSTEM.GENERIC.ERROR.CRITICAL'
        const normalPriorityEvent = 'ANALYTICS.GENERIC.UPDATE.COMPLETED'

        // ÂàÜÈÖçÂÑ™ÂÖàÁ¥ö
        const highPriority = priorityManager.assignEventPriority(highPriorityEvent)
        const normalPriority = priorityManager.assignEventPriority(normalPriorityEvent)

        // È©óË≠âÂÑ™ÂÖàÁ¥öÂàÜÈÖçÊ≠£Á¢∫
        expect(highPriority).toBeLessThan(normalPriority) // Êï∏ÂÄºË∂äÂ∞èÂÑ™ÂÖàÁ¥öË∂äÈ´ò

        // Ë®≠ÁΩÆËôïÁêÜÂô®‰∏¶Ë®òÈåÑÂü∑Ë°åÈ†ÜÂ∫è
        const executionOrder = []

        priorityManager.registerWithPriority(eventBus, highPriorityEvent, () => {
          executionOrder.push('high')
        })

        priorityManager.registerWithPriority(eventBus, normalPriorityEvent, () => {
          executionOrder.push('normal')
        })

        // ÂêåÊôÇËß∏ÁôºÂÖ©ÂÄã‰∫ã‰ª∂
        await Promise.all([
          chromeBridge.forwardEventFromContent({
            eventType: normalPriorityEvent,
            eventData: { priority: 'normal' },
            tabId: mockTabId
          }),
          chromeBridge.forwardEventFromContent({
            eventType: highPriorityEvent,
            eventData: { priority: 'high' },
            tabId: mockTabId
          })
        ])

        // Á≠âÂæÖ‰∫ã‰ª∂ËôïÁêÜÂÆåÊàê
        await new Promise(resolve => setTimeout(resolve, 100))

        // È©óË≠âÈ´òÂÑ™ÂÖàÁ¥ö‰∫ã‰ª∂ÂÖàÂü∑Ë°å
        expect(executionOrder[0]).toBe('high')
      })

      test('ÊáâË©≤ÊîØÊè¥‰∫ã‰ª∂Áµ±Ë®àÂú® Background Áí∞Â¢É‰∏≠ÁöÑÊî∂ÈõÜ', async () => {
        const testEvents = [
          'EXTRACTION.READMOO.EXTRACT.STARTED',
          'EXTRACTION.READMOO.EXTRACT.PROGRESS',
          'EXTRACTION.READMOO.EXTRACT.COMPLETED'
        ]

        // ÈÄöÈÅé Chrome Bridge Ëß∏ÁôºÂ§öÂÄã‰∫ã‰ª∂
        for (const event of testEvents) {
          await chromeBridge.forwardEventFromContent({
            eventType: event,
            eventData: { timestamp: Date.now() },
            tabId: mockTabId
          })
        }

        // Ê™¢Êü•Áµ±Ë®àË≥áÊñô
        const conversionStats = namingCoordinator.getConversionStats()
        const priorityStats = priorityManager.getPriorityStats()

        expect(conversionStats.totalConversions).toBeGreaterThan(0)
        expect(priorityStats.totalAssignments).toBeGreaterThan(0)
      })
    })
  })

  describe('üîß Content Scripts ‰∫ã‰ª∂ËôïÁêÜÊ∏¨Ë©¶', () => {
    describe('DOM ‰∫íÂãïÂíå‰∫ã‰ª∂Áõ£ËÅΩ', () => {
      test('ÊáâË©≤Ê≠£Á¢∫Ë®≠ÁΩÆ DOM ‰∫ã‰ª∂Áõ£ËÅΩÂô®', async () => {
        // Ê®°Êì¨ Content Script Áí∞Â¢É
        const mockDocument = {
          addEventListener: jest.fn(),
          querySelector: jest.fn(),
          querySelectorAll: jest.fn()
        }

        global.document = mockDocument

        // ÂàùÂßãÂåñ Content Script ‰∫ã‰ª∂Áõ£ËÅΩ
        await chromeBridge.initializeContentScriptListeners()

        // È©óË≠â DOM ‰∫ã‰ª∂Áõ£ËÅΩÂô®Ë¢´Ë®≠ÁΩÆ
        expect(mockDocument.addEventListener).toHaveBeenCalledWith(
          'DOMContentLoaded',
          expect.any(Function)
        )
      })

      test('ÊáâË©≤Ê≠£Á¢∫ËôïÁêÜÈ†ÅÈù¢ËÆäÊõ¥‰∫ã‰ª∂', async () => {
        const pageChangeHandler = jest.fn()
        eventBus.on('PAGE.READMOO.CHANGE.DETECTED', pageChangeHandler)

        // Ê®°Êì¨È†ÅÈù¢ËÆäÊõ¥
        await chromeBridge.handlePageChange({
          url: 'https://readmoo.com/book/new-book',
          previousUrl: 'https://readmoo.com/book/old-book',
          changeType: 'navigation'
        })

        expect(pageChangeHandler).toHaveBeenCalled()
      })

      test('ÊáâË©≤ÊîØÊè¥ÂãïÊÖãÂÖßÂÆπËÆäÊõ¥Ê™¢Ê∏¨', async () => {
        const contentChangeHandler = jest.fn()
        eventBus.on('CONTENT.READMOO.DYNAMIC.UPDATED', contentChangeHandler)

        // Ê®°Êì¨ÂãïÊÖãÂÖßÂÆπËÆäÊõ¥
        const mutationEvent = {
          type: 'mutation',
          addedNodes: ['book-item-1', 'book-item-2'],
          removedNodes: [],
          target: 'bookshelf-container'
        }

        await chromeBridge.handleDynamicContentChange(mutationEvent)

        expect(contentChangeHandler).toHaveBeenCalledWith(
          expect.objectContaining({
            data: expect.objectContaining({
              addedNodes: ['book-item-1', 'book-item-2']
            })
          })
        )
      })

      test('ÊáâË©≤Ê≠£Á¢∫ÊèêÂèñÂíåËΩâÁôºÈ†ÅÈù¢Ë≥áÊñô', async () => {
        const extractionHandler = jest.fn()
        eventBus.on('EXTRACTION.READMOO.EXTRACT.COMPLETED', extractionHandler)

        // Ê®°Êì¨Ë≥áÊñôÊèêÂèñÂÆåÊàê
        const extractedData = [
          { id: 'book-1', title: 'Book 1', progress: 50 },
          { id: 'book-2', title: 'Book 2', progress: 75 }
        ]

        await chromeBridge.forwardExtractionResult({
          data: extractedData,
          source: 'content-script',
          tabId: mockTabId
        })

        // Á≠âÂæÖ‰∫ã‰ª∂ËôïÁêÜ
        await new Promise(resolve => setTimeout(resolve, 50))

        expect(extractionHandler).toHaveBeenCalled()
        expect(chrome.runtime.sendMessage).toHaveBeenCalledWith(
          expect.objectContaining({
            type: 'EXTRACTION_COMPLETED',
            data: extractedData
          })
        )
      })
    })

    describe('ÈåØË™§ËôïÁêÜÂíåÊÅ¢Âæ©Ê©üÂà∂', () => {
      test('ÊáâË©≤ËôïÁêÜ DOM Â≠òÂèñÈåØË™§', async () => {
        const errorHandler = jest.fn()
        eventBus.on('SYSTEM.GENERIC.ERROR.HANDLED', errorHandler)

        // Ê®°Êì¨ DOM Â≠òÂèñÈåØË™§
        const domError = new Error('Cannot access property of null')

        await chromeBridge.handleContentScriptError({
          error: domError,
          context: 'dom-access',
          url: 'https://readmoo.com/book/123'
        })

        expect(errorHandler).toHaveBeenCalled()
      })

      test('ÊáâË©≤ÊîØÊè¥ Content Script ÈáçÊñ∞Ê≥®ÂÖ•', async () => {
        const reinjectionHandler = jest.fn()
        eventBus.on('CONTENT.GENERIC.REINJECT.COMPLETED', reinjectionHandler)

        // Ê®°Êì¨ÈáçÊñ∞Ê≥®ÂÖ•Ë´ãÊ±Ç
        await chromeBridge.reinjectContentScript(mockTabId)

        // È©óË≠âÈáçÊñ∞Ê≥®ÂÖ•ÈÇèËºØ
        expect(chrome.tabs.sendMessage).toHaveBeenCalledWith(
          mockTabId,
          expect.objectContaining({
            type: 'REINJECT_REQUEST'
          })
        )
      })

      test('ÊáâË©≤ËôïÁêÜÁ∂≤Ë∑ØË´ãÊ±ÇÂ§±ÊïóÊÉÖÊ≥Å', async () => {
        const networkErrorHandler = jest.fn()
        eventBus.on('NETWORK.GENERIC.ERROR.DETECTED', networkErrorHandler)

        // Ê®°Êì¨Á∂≤Ë∑ØÈåØË™§
        const networkError = {
          type: 'network-error',
          status: 'timeout',
          url: 'https://readmoo.com/api/books',
          retryCount: 2
        }

        await chromeBridge.handleNetworkError(networkError)

        expect(networkErrorHandler).toHaveBeenCalledWith(
          expect.objectContaining({
            data: networkError
          })
        )
      })
    })
  })

  describe('üîß Popup ÁïåÈù¢‰∫ã‰ª∂È©ÖÂãïÊ∏¨Ë©¶', () => {
    describe('UI ÈüøÊáâÂíåÁãÄÊÖãÂêåÊ≠•', () => {
      test('ÊáâË©≤Âç≥ÊôÇÈüøÊáâÊèêÂèñÈÄ≤Â∫¶Êõ¥Êñ∞', async () => {
        const progressHandler = jest.fn()
        eventBus.on('UX.GENERIC.PROGRESS.UPDATED', progressHandler)

        // Ê®°Êì¨ÊèêÂèñÈÄ≤Â∫¶Êõ¥Êñ∞
        const progressUpdate = {
          completed: 7,
          total: 10,
          currentBook: 'Áï∂ÂâçÊõ∏Á±ç',
          estimatedTimeRemaining: 120
        }

        await chromeBridge.updateExtractionProgress(progressUpdate)

        expect(progressHandler).toHaveBeenCalledWith(
          expect.objectContaining({
            data: progressUpdate
          })
        )

        // È©óË≠âË®äÊÅØË¢´ÁôºÈÄÅÂà∞ Popup
        expect(chrome.runtime.sendMessage).toHaveBeenCalledWith(
          expect.objectContaining({
            type: 'PROGRESS_UPDATE',
            data: progressUpdate
          })
        )
      })

      test('ÊáâË©≤Ê≠£Á¢∫ËôïÁêÜ‰ΩøÁî®ËÄÖÊìç‰Ωú‰∫ã‰ª∂', async () => {
        const userActionHandler = jest.fn()
        eventBus.on('UX.GENERIC.ACTION.REQUESTED', userActionHandler)

        // Ê®°Êì¨‰ΩøÁî®ËÄÖÈªûÊìäÈñãÂßãÊèêÂèñ
        const userAction = {
          action: 'START_EXTRACTION',
          parameters: {
            mode: 'full',
            target: 'current-page'
          },
          timestamp: Date.now()
        }

        await chromeBridge.handleUserAction(userAction)

        expect(userActionHandler).toHaveBeenCalledWith(
          expect.objectContaining({
            data: userAction
          })
        )
      })

      test('ÊáâË©≤ÂêåÊ≠•È°ØÁ§∫Á≥ªÁµ±ÁãÄÊÖã', async () => {
        const statusSyncHandler = jest.fn()
        eventBus.on('UX.GENERIC.STATUS.SYNCED', statusSyncHandler)

        // Ê®°Êì¨Á≥ªÁµ±ÁãÄÊÖã
        const systemStatus = {
          isActive: true,
          platform: 'READMOO',
          lastUpdate: Date.now(),
          totalBooks: 25,
          extractionMode: 'incremental'
        }

        await chromeBridge.syncSystemStatus(systemStatus)

        expect(statusSyncHandler).toHaveBeenCalled()

        // È©óË≠âÁãÄÊÖãË¢´Ê≠£Á¢∫Âª£Êí≠
        expect(chrome.runtime.sendMessage).toHaveBeenCalledWith(
          expect.objectContaining({
            type: 'STATUS_SYNC',
            data: systemStatus
          })
        )
      })

      test('ÊáâË©≤ËôïÁêÜ Popup ÈñãÂïüÂíåÈóúÈñâ‰∫ã‰ª∂', async () => {
        const openHandler = jest.fn()
        const closeHandler = jest.fn()

        eventBus.on('UX.GENERIC.OPEN.COMPLETED', openHandler)
        eventBus.on('UX.GENERIC.CLOSE.COMPLETED', closeHandler)

        // Ê®°Êì¨ Popup ÈñãÂïü
        await chromeBridge.handlePopupOpen({
          timestamp: Date.now(),
          context: 'user-click'
        })

        expect(openHandler).toHaveBeenCalled()

        // Ê®°Êì¨ Popup ÈóúÈñâ
        await chromeBridge.handlePopupClose({
          timestamp: Date.now(),
          duration: 5000
        })

        expect(closeHandler).toHaveBeenCalled()
      })
    })

    describe('ÈåØË™§ÁãÄÊÖãËôïÁêÜ', () => {
      test('ÊáâË©≤È°ØÁ§∫ÈÅ©Áï∂ÁöÑÈåØË™§Ë®äÊÅØ', async () => {
        const errorDisplayHandler = jest.fn()
        eventBus.on('UX.GENERIC.ERROR.DISPLAYED', errorDisplayHandler)

        // Ê®°Êì¨ÈåØË™§ÊÉÖÊ≥Å
        const errorInfo = {
          type: 'extraction-failed',
          message: 'ÊèêÂèñÂ§±ÊïóÔºöÁÑ°Ê≥ïÂ≠òÂèñÊõ∏Á±çË≥áÊñô',
          suggestions: ['Ê™¢Êü•Á∂≤Ë∑ØÈÄ£Á∑ö', 'ÈáçÊñ∞ËºâÂÖ•È†ÅÈù¢', 'Á®çÂæåÂÜçË©¶'],
          severity: 'warning'
        }

        await chromeBridge.displayError(errorInfo)

        expect(errorDisplayHandler).toHaveBeenCalledWith(
          expect.objectContaining({
            data: errorInfo
          })
        )
      })

      test('ÊáâË©≤ÊîØÊè¥ÈåØË™§ÊÅ¢Âæ©Êìç‰Ωú', async () => {
        const recoveryHandler = jest.fn()
        eventBus.on('SYSTEM.GENERIC.RECOVERY.INITIATED', recoveryHandler)

        // Ê®°Êì¨ÈåØË™§ÊÅ¢Âæ©
        const recoveryAction = {
          action: 'retry-extraction',
          target: 'current-page',
          previousError: 'timeout'
        }

        await chromeBridge.initiateRecovery(recoveryAction)

        expect(recoveryHandler).toHaveBeenCalledWith(
          expect.objectContaining({
            data: recoveryAction
          })
        )
      })
    })
  })

  describe('üîß Á´ØÂ∞çÁ´ØÂ∑•‰ΩúÊµÅÁ®ãÊ∏¨Ë©¶', () => {
    describe('ÂÆåÊï¥ÊèêÂèñÂ∑•‰ΩúÊµÅÁ®ã', () => {
      test('ÊáâË©≤Âü∑Ë°åÂÆåÊï¥ÁöÑÊõ∏Á±çÊèêÂèñÊµÅÁ®ã', async () => {
        const workflowEvents = []

        // Ë®≠ÁΩÆÂ∑•‰ΩúÊµÅÁ®ã‰∫ã‰ª∂Áõ£ËÅΩÂô®
        const eventTypes = [
          'EXTRACTION.READMOO.EXTRACT.STARTED',
          'EXTRACTION.READMOO.EXTRACT.PROGRESS',
          'DATA.READMOO.SAVE.REQUESTED',
          'DATA.READMOO.SAVE.COMPLETED',
          'UX.GENERIC.NOTIFICATION.SENT',
          'EXTRACTION.READMOO.EXTRACT.COMPLETED'
        ]

        for (const eventType of eventTypes) {
          eventBus.on(eventType, (event) => {
            workflowEvents.push(event.type)
          })
        }

        // ÂïüÂãïÊèêÂèñÊµÅÁ®ã
        await chromeBridge.startExtractionWorkflow({
          tabId: mockTabId,
          mode: 'full',
          notifications: true
        })

        // Ê®°Êì¨ÊèêÂèñÈÄ≤Â∫¶
        await chromeBridge.reportProgress({ completed: 5, total: 10 })
        await chromeBridge.reportProgress({ completed: 10, total: 10 })

        // Ê®°Êì¨ÂÑ≤Â≠òÊµÅÁ®ã
        await chromeBridge.saveExtractionResults([
          { id: 'book-1', title: 'Book 1' },
          { id: 'book-2', title: 'Book 2' }
        ])

        // ÂÆåÊàêÊµÅÁ®ã
        await chromeBridge.completeExtractionWorkflow({
          totalExtracted: 10,
          duration: 30000
        })

        // Á≠âÂæÖÊâÄÊúâ‰∫ã‰ª∂ËôïÁêÜÂÆåÊàê
        await new Promise(resolve => setTimeout(resolve, 200))

        // È©óË≠âÂ∑•‰ΩúÊµÅÁ®ã‰∫ã‰ª∂È†ÜÂ∫è
        expect(workflowEvents).toContain('EXTRACTION.READMOO.EXTRACT.STARTED')
        expect(workflowEvents).toContain('EXTRACTION.READMOO.EXTRACT.PROGRESS')
        expect(workflowEvents).toContain('DATA.READMOO.SAVE.COMPLETED')
        expect(workflowEvents).toContain('EXTRACTION.READMOO.EXTRACT.COMPLETED')
      })

      test('ÊáâË©≤ËôïÁêÜ‰∏≠Êñ∑ÁöÑÊèêÂèñÊµÅÁ®ã', async () => {
        const interruptionHandler = jest.fn()
        eventBus.on('EXTRACTION.READMOO.EXTRACT.INTERRUPTED', interruptionHandler)

        // ÂïüÂãïÊèêÂèñÊµÅÁ®ã
        await chromeBridge.startExtractionWorkflow({
          tabId: mockTabId,
          mode: 'incremental'
        })

        // Ê®°Êì¨‰∏≠Êñ∑ÔºàÂ¶ÇÊ®ôÁ±§È†ÅÈóúÈñâÔºâ
        await chromeBridge.handleTabClosed(mockTabId)

        expect(interruptionHandler).toHaveBeenCalled()
      })

      test('ÊáâË©≤ÊîØÊè¥Êö´ÂÅúÂíåÊÅ¢Âæ©ÊèêÂèñ', async () => {
        const pauseHandler = jest.fn()
        const resumeHandler = jest.fn()

        eventBus.on('EXTRACTION.READMOO.EXTRACT.PAUSED', pauseHandler)
        eventBus.on('EXTRACTION.READMOO.EXTRACT.RESUMED', resumeHandler)

        // ÂïüÂãïÊèêÂèñ
        await chromeBridge.startExtractionWorkflow({ tabId: mockTabId })

        // Êö´ÂÅúÊèêÂèñ
        await chromeBridge.pauseExtraction({ tabId: mockTabId, reason: 'user-request' })
        expect(pauseHandler).toHaveBeenCalled()

        // ÊÅ¢Âæ©ÊèêÂèñ
        await chromeBridge.resumeExtraction({ tabId: mockTabId })
        expect(resumeHandler).toHaveBeenCalled()
      })
    })

    describe('Â§öÊ®ôÁ±§È†ÅÁÆ°ÁêÜ', () => {
      test('ÊáâË©≤ÁÆ°ÁêÜÂ§öÂÄã Readmoo Ê®ôÁ±§È†Å', async () => {
        const tabIds = [123, 456, 789]
        const activeExtractions = new Map()

        // Âú®Â§öÂÄãÊ®ôÁ±§È†ÅÂïüÂãïÊèêÂèñ
        for (const tabId of tabIds) {
          await chromeBridge.startExtractionWorkflow({ tabId })
          activeExtractions.set(tabId, { status: 'active', progress: 0 })
        }

        // È©óË≠âÊâÄÊúâÊèêÂèñÈÉΩË¢´Ê≠£Á¢∫ËøΩËπ§
        const status = await chromeBridge.getActiveExtractions()
        expect(status.count).toBe(3)
        expect(status.tabIds).toEqual(expect.arrayContaining(tabIds))
      })

      test('ÊáâË©≤ËôïÁêÜÊ®ôÁ±§È†ÅË°ùÁ™ÅÊÉÖÊ≥Å', async () => {
        const conflictHandler = jest.fn()
        eventBus.on('EXTRACTION.GENERIC.CONFLICT.DETECTED', conflictHandler)

        // Âú®Âêå‰∏ÄÊ®ôÁ±§È†ÅÂïüÂãïÂ§öÂÄãÊèêÂèñ
        await chromeBridge.startExtractionWorkflow({ tabId: mockTabId })
        await chromeBridge.startExtractionWorkflow({ tabId: mockTabId })

        expect(conflictHandler).toHaveBeenCalled()
      })
    })
  })

  describe('üîß ÊïàËÉΩÂíåÁ©©ÂÆöÊÄßÊ∏¨Ë©¶', () => {
    describe('È´òË≤†ËºâÊÉÖÊ≥ÅÊ∏¨Ë©¶', () => {
      test('ÊáâË©≤ËôïÁêÜÂ§ßÈáè‰∏¶Áôº‰∫ã‰ª∂', async () => {
        const startTime = Date.now()
        const eventCount = 1000
        const promises = []

        // ÁîüÊàêÂ§ßÈáè‰∏¶Áôº‰∫ã‰ª∂
        for (let i = 0; i < eventCount; i++) {
          const promise = chromeBridge.forwardEventFromContent({
            eventType: 'EXTRACTION.READMOO.EXTRACT.PROGRESS',
            eventData: { iteration: i, timestamp: Date.now() },
            tabId: mockTabId
          })
          promises.push(promise)
        }

        // Á≠âÂæÖÊâÄÊúâ‰∫ã‰ª∂ËôïÁêÜÂÆåÊàê
        await Promise.all(promises)

        const endTime = Date.now()
        const totalTime = endTime - startTime

        // È©óË≠âÊïàËÉΩÊåáÊ®ô
        expect(totalTime).toBeLessThan(10000) // Á∏ΩÊôÇÈñìÂ∞ëÊñº 10 Áßí

        const avgTimePerEvent = totalTime / eventCount
        expect(avgTimePerEvent).toBeLessThan(10) // Âπ≥ÂùáÊØèÂÄã‰∫ã‰ª∂Â∞ëÊñº 10ms
      })

      test('ÊáâË©≤Âú®Ë®òÊÜ∂È´îÈôêÂà∂‰∏ã‰øùÊåÅÁ©©ÂÆö', async () => {
        const initialMemory = process.memoryUsage()

        // ËôïÁêÜÂ§ßÈáèË≥áÊñô
        for (let round = 0; round < 10; round++) {
          const largeData = Array.from({ length: 100 }, (_, i) => ({
            id: `book-${round}-${i}`,
            title: `Large Title ${round}-${i}`.repeat(10),
            content: new Array(1000).fill(`content-${round}-${i}`).join(' ')
          }))

          await chromeBridge.forwardExtractionResult({
            data: largeData,
            source: 'stress-test',
            tabId: mockTabId
          })
        }

        // Á≠âÂæÖË®òÊÜ∂È´îÁ©©ÂÆöÂåñ
        await new Promise(resolve => setTimeout(resolve, 100))

        const finalMemory = process.memoryUsage()
        const memoryGrowth = (finalMemory.heapUsed - initialMemory.heapUsed) / initialMemory.heapUsed

        // Ë®òÊÜ∂È´îÂ¢ûÈï∑ÊáâË©≤ÊéßÂà∂Âú®ÂêàÁêÜÁØÑÂúçÂÖß
        expect(memoryGrowth).toBeLessThan(0.3) // 30% Â¢ûÈï∑ÈôêÂà∂
      })

      test('ÊáâË©≤ËôïÁêÜÂø´ÈÄüÈÄ£Á∫åÁöÑÁãÄÊÖãËÆäÊõ¥', async () => {
        const stateChanges = [
          'started', 'progress', 'progress', 'paused',
          'resumed', 'progress', 'completed'
        ]

        const stateHandler = jest.fn()
        eventBus.on('EXTRACTION.READMOO.EXTRACT.STATE_CHANGED', stateHandler)

        // Âø´ÈÄüÈÄ£Á∫åËß∏ÁôºÁãÄÊÖãËÆäÊõ¥
        for (const state of stateChanges) {
          await chromeBridge.updateExtractionState({
            tabId: mockTabId,
            newState: state,
            timestamp: Date.now()
          })

          // ÂæàÁü≠ÁöÑÂª∂ÈÅ≤Ê®°Êì¨Âø´ÈÄüËÆäÊõ¥
          await new Promise(resolve => setTimeout(resolve, 10))
        }

        // È©óË≠âÊâÄÊúâÁãÄÊÖãËÆäÊõ¥ÈÉΩË¢´Ê≠£Á¢∫ËôïÁêÜ
        expect(stateHandler).toHaveBeenCalledTimes(stateChanges.length)
      })
    })

    describe('Èï∑ÊôÇÈñìÈÅãË°åÁ©©ÂÆöÊÄß', () => {
      test('ÊáâË©≤Âú®Èï∑ÊôÇÈñìÈÅãË°åÂæå‰øùÊåÅÈüøÊáâÊÄß', async () => {
        const testDuration = 5000 // 5 ÁßíÊ®°Êì¨Èï∑ÊôÇÈñìÈÅãË°å
        let eventCount = 0

        // Ë®≠ÁΩÆÂÆöÊúü‰∫ã‰ª∂Ëß∏Áôº
        const interval = setInterval(async () => {
          eventCount++
          await chromeBridge.heartbeat({
            timestamp: Date.now(),
            sequence: eventCount
          })
        }, 100)

        // ÈÅãË°åÊåáÂÆöÊôÇÈñì
        await new Promise(resolve => setTimeout(resolve, testDuration))
        clearInterval(interval)

        // È©óË≠âÁ≥ªÁµ±‰ªçÁÑ∂ÈüøÊáâ
        const responseTest = await chromeBridge.ping()
        expect(responseTest.success).toBe(true)
        expect(responseTest.responseTime).toBeLessThan(100)

        // È©óË≠â‰∫ã‰ª∂Ë®àÊï∏Ê≠£Á¢∫
        expect(eventCount).toBeGreaterThan(40) // Ëá≥Â∞ë 40 ÂÄã‰∫ã‰ª∂
        expect(eventCount).toBeLessThan(60) // ‰∏çË∂ÖÈÅé 60 ÂÄã‰∫ã‰ª∂
      })

      test('ÊáâË©≤Ê≠£Á¢∫Ê∏ÖÁêÜË≥áÊ∫êÂíå‰∫ã‰ª∂Áõ£ËÅΩÂô®', async () => {
        const initialListenerCount = eventBus.getListenerCount()

        // Ê∑ªÂä†Â§ßÈáè‰∫ã‰ª∂Áõ£ËÅΩÂô®
        const eventTypes = [
          'EXTRACTION.READMOO.EXTRACT.STARTED',
          'EXTRACTION.READMOO.EXTRACT.PROGRESS',
          'EXTRACTION.READMOO.EXTRACT.COMPLETED',
          'DATA.READMOO.SAVE.COMPLETED',
          'UX.GENERIC.NOTIFICATION.SENT'
        ]

        const handlers = []
        for (const eventType of eventTypes) {
          const handler = jest.fn()
          handlers.push(handler)
          eventBus.on(eventType, handler)
        }

        const peakListenerCount = eventBus.getListenerCount()
        expect(peakListenerCount).toBeGreaterThan(initialListenerCount)

        // Ê∏ÖÁêÜÁõ£ËÅΩÂô®
        await chromeBridge.cleanup()

        const finalListenerCount = eventBus.getListenerCount()
        expect(finalListenerCount).toBeLessThanOrEqual(initialListenerCount + 5) // ÂÖÅË®±‰∏Ä‰∫õÊ†∏ÂøÉÁõ£ËÅΩÂô®‰øùÁïô
      })
    })
  })
})
