/**
 * ‰∫ã‰ª∂Á≥ªÁµ± v2.0 Ê†∏ÂøÉÊï¥ÂêàÊ∏¨Ë©¶
 *
 * Ë≤†Ë≤¨ÂäüËÉΩÔºö
 * - EventNamingUpgradeCoordinator ËàáÊï¥ÂÄãÁ≥ªÁµ±ÁöÑÊï¥ÂêàÈ©óË≠â
 * - EventPriorityManager ÁöÑÂÑ™ÂÖàÁ¥öËôïÁêÜÊï¥ÂêàÊ∏¨Ë©¶
 * - EventTypeDefinitions ÁöÑÈ°ûÂûãÁ≥ªÁµ±Êï¥ÂêàÈ©óË≠â
 * - ‰∏âÂ§ßÊ†∏ÂøÉÁµÑ‰ª∂ÁöÑÂçî‰ΩúÊï¥ÂêàÊ∏¨Ë©¶
 *
 * Ê∏¨Ë©¶Á≠ñÁï•Ôºö
 * - ÁúüÂØ¶Áí∞Â¢ÉÊ®°Êì¨Ê∏¨Ë©¶
 * - Á´ØÂ∞çÁ´Ø‰∫ã‰ª∂ËôïÁêÜÊµÅÁ®ãÊ∏¨Ë©¶
 * - ÊïàËÉΩÂíåÁ©©ÂÆöÊÄßÈ©óË≠â
 * - ÂêëÂæåÁõ∏ÂÆπÊÄßÂÆåÊï¥È©óË≠â
 *
 * Êï¥ÂêàÊ∏¨Ë©¶ÁØÑÂúçÔºö
 * - ‰∫ã‰ª∂ËΩâÊèõÊ∫ñÁ¢∫ÊÄß 100% È©óË≠â
 * - ÂÑ™ÂÖàÁ¥öÁÆ°ÁêÜÂÆåÊï¥ÊÄßÊ∏¨Ë©¶
 * - ‰∫ã‰ª∂È°ûÂûãÈ©óË≠âÁ≥ªÁµ±Ê∏¨Ë©¶
 * - Áµ±Ë®àÂíåÁõ£ÊéßÂäüËÉΩÊï¥ÂêàÊ∏¨Ë©¶
 */

const EventBus = require('@/core/event-bus')
const EventNamingUpgradeCoordinator = require('@/core/events/event-naming-upgrade-coordinator')
const EventPriorityManager = require('@/core/events/event-priority-manager')
const EventTypeDefinitions = require('@/core/events/event-type-definitions')

describe('üß™ ‰∫ã‰ª∂Á≥ªÁµ± v2.0 Ê†∏ÂøÉÊï¥ÂêàÊ∏¨Ë©¶', () => {
  let eventBus
  let namingCoordinator
  let priorityManager
  let typeDefinitions
  let integrationSystem

  beforeEach(async () => {
    // ÂàùÂßãÂåñÂÆåÊï¥ÁöÑ‰∫ã‰ª∂Á≥ªÁµ± v2.0 Êï¥ÂêàÁí∞Â¢É
    eventBus = new EventBus()
    priorityManager = new EventPriorityManager()
    typeDefinitions = new EventTypeDefinitions()
    namingCoordinator = new EventNamingUpgradeCoordinator(eventBus)

    // Âª∫Á´ãÊï¥ÂêàÁ≥ªÁµ±ÂØ¶‰æã
    integrationSystem = {
      eventBus,
      namingCoordinator,
      priorityManager,
      typeDefinitions
    }

    // Á≠âÂæÖÁ≥ªÁµ±ÂàùÂßãÂåñÂÆåÊàê
    await new Promise(resolve => setTimeout(resolve, 50))
  })

  afterEach(async () => {
    // Ê∏ÖÁêÜË≥áÊ∫êÂíåÈáçÁΩÆÁãÄÊÖã
    if (eventBus && typeof eventBus.removeAllListeners === 'function') {
      eventBus.removeAllListeners()
    }

    // ÈáçÁΩÆÁµ±Ë®àË≥áÊñô
    if (namingCoordinator) {
      namingCoordinator.conversionStats = namingCoordinator.initializeStats()
    }

    if (priorityManager) {
      priorityManager.priorityStats = priorityManager.initializePriorityStats()
    }
  })

  describe('üîß EventNamingUpgradeCoordinator Êï¥ÂêàÊ∏¨Ë©¶', () => {
    describe('‰∫ã‰ª∂ËΩâÊèõÊ∫ñÁ¢∫ÊÄßÈ©óË≠â', () => {
      test('ÊáâË©≤Ê≠£Á¢∫ËΩâÊèõÊâÄÊúâ Legacy ‰∫ã‰ª∂Âà∞ Modern Ê†ºÂºè', async () => {
        const legacyEvents = [
          'EXTRACTION.COMPLETED',
          'EXTRACTION.PROGRESS',
          'EXTRACTION.STARTED',
          'EXTRACTION.FAILED',
          'STORAGE.SAVE.COMPLETED',
          'STORAGE.LOAD.COMPLETED',
          'UI.POPUP.OPENED',
          'BACKGROUND.INIT.COMPLETED'
        ]

        const expectedModernEvents = [
          'EXTRACTION.READMOO.EXTRACT.COMPLETED',
          'EXTRACTION.READMOO.EXTRACT.PROGRESS',
          'EXTRACTION.READMOO.EXTRACT.STARTED',
          'EXTRACTION.READMOO.EXTRACT.FAILED',
          'DATA.READMOO.SAVE.COMPLETED',
          'DATA.READMOO.LOAD.COMPLETED',
          'UX.GENERIC.OPEN.COMPLETED',
          'SYSTEM.GENERIC.INIT.COMPLETED'
        ]

        // Ê∏¨Ë©¶ÊØèÂÄã Legacy ‰∫ã‰ª∂ÁöÑËΩâÊèõ
        for (let i = 0; i < legacyEvents.length; i++) {
          const legacyEvent = legacyEvents[i]
          const expectedModern = expectedModernEvents[i]

          const actualModern = namingCoordinator.convertToModernEvent(legacyEvent)

          expect(actualModern).toBe(expectedModern)
        }

        // È©óË≠âËΩâÊèõÁµ±Ë®à
        const stats = namingCoordinator.getConversionStats()
        expect(stats.totalConversions).toBeGreaterThanOrEqual(0)
      })

      test('ÊáâË©≤Ê≠£Á¢∫ËôïÁêÜÊô∫ËÉΩ‰∫ã‰ª∂ÂêçÁ®±Êé®Êñ∑', async () => {
        const testCases = [
          {
            input: 'ANALYTICS.COUNT.UPDATED',
            expectedDomain: 'ANALYTICS',
            expectedPlatform: 'GENERIC',
            expectedAction: 'COUNT',
            expectedState: 'UPDATED'
          },
          {
            input: 'EXPORT.DATA.REQUESTED',
            expectedDomain: 'DATA',
            expectedPlatform: 'GENERIC',
            expectedAction: 'DATA',
            expectedState: 'REQUESTED'
          }
        ]

        for (const testCase of testCases) {
          const modernEvent = namingCoordinator.buildModernEventName(testCase.input)
          const parts = modernEvent.split('.')

          expect(parts).toHaveLength(4)
          expect(parts[0]).toBe(testCase.expectedDomain)
          expect(parts[1]).toBe(testCase.expectedPlatform)
          expect(parts[2]).toBe(testCase.expectedAction)
          expect(parts[3]).toBe(testCase.expectedState)
        }
      })

      test('ÊáâË©≤ÊîØÊè¥ÈõôËªå‰∏¶Ë°å‰∫ã‰ª∂ËôïÁêÜ', async () => {
        const testEventData = { testData: 'integration-test', timestamp: Date.now() }
        const legacyEventName = 'EXTRACTION.COMPLETED'

        // Ë®≠ÁΩÆÁõ£ËÅΩÂô®‰æÜÊçïÊçâÂÖ©Á®ÆÊ†ºÂºèÁöÑ‰∫ã‰ª∂
        const legacyEventReceived = jest.fn()
        const modernEventReceived = jest.fn()

        // Ë®ªÂÜäÈõôËªåÁõ£ËÅΩÂô®
        namingCoordinator.registerDualTrackListener(legacyEventName, (event) => {
          if (event.type === legacyEventName) {
            legacyEventReceived(event)
          } else {
            modernEventReceived(event)
          }
        })

        // ÁôºÂ∞Ñ Legacy ‰∫ã‰ª∂
        await namingCoordinator.intelligentEmit(legacyEventName, testEventData)

        // Á≠âÂæÖ‰∫ã‰ª∂ËôïÁêÜÂÆåÊàê
        await new Promise(resolve => setTimeout(resolve, 100))

        // È©óË≠âÈõôËªå‰∫ã‰ª∂ÈÉΩË¢´Ê≠£Á¢∫ËôïÁêÜ
        expect(legacyEventReceived).toHaveBeenCalled()
        expect(modernEventReceived).toHaveBeenCalled()

        // È©óË≠â‰∫ã‰ª∂Ë≥áÊñôÊ≠£Á¢∫ÊÄß
        const legacyCall = legacyEventReceived.mock.calls[0][0]
        const modernCall = modernEventReceived.mock.calls[0][0]

        expect(legacyCall.data).toEqual(testEventData)
        expect(modernCall.data).toEqual(testEventData)
      })

      test('ÊáâË©≤Ê≠£Á¢∫ËôïÁêÜËΩâÊèõÊ®°ÂºèÂàáÊèõ', async () => {
        const testEventData = { mode: 'test' }
        const legacyEvent = 'STORAGE.SAVE.COMPLETED'

        // Ê∏¨Ë©¶ DUAL_TRACK Ê®°Âºè
        namingCoordinator.setConversionMode('DUAL_TRACK')
        await namingCoordinator.intelligentEmit(legacyEvent, testEventData)

        // Ê∏¨Ë©¶ MODERN_ONLY Ê®°Âºè
        namingCoordinator.setConversionMode('MODERN_ONLY')
        await namingCoordinator.intelligentEmit(legacyEvent, testEventData)

        // Ê∏¨Ë©¶ LEGACY_ONLY Ê®°Âºè
        namingCoordinator.setConversionMode('LEGACY_ONLY')
        await namingCoordinator.intelligentEmit(legacyEvent, testEventData)

        // È©óË≠âÁµ±Ë®àË≥áÊñôÂèçÊò†‰∫Ü‰∏çÂêåÊ®°ÂºèÁöÑ‰ΩøÁî®
        const stats = namingCoordinator.getConversionStats()
        expect(stats.totalConversions).toBeGreaterThan(0)
        expect(stats.conversionMode).toBe('LEGACY_ONLY') // ÊúÄÂæåË®≠ÂÆöÁöÑÊ®°Âºè
      })
    })

    describe('ËΩâÊèõÁµ±Ë®àÂíåÁõ£ÊéßÊï¥Âêà', () => {
      test('ÊáâË©≤Ê∫ñÁ¢∫Ë®òÈåÑËΩâÊèõÁµ±Ë®àË≥áÊñô', async () => {
        const initialStats = namingCoordinator.getConversionStats()
        const legacyEvents = ['EXTRACTION.COMPLETED', 'STORAGE.SAVE.COMPLETED', 'UI.POPUP.OPENED']

        // Ëß∏ÁôºÂ§öÂÄãËΩâÊèõ
        for (const event of legacyEvents) {
          await namingCoordinator.intelligentEmit(event, { test: true })
        }

        const finalStats = namingCoordinator.getConversionStats()

        // È©óË≠âÁµ±Ë®àË≥áÊñôÊõ¥Êñ∞
        expect(finalStats.totalConversions).toBeGreaterThan(initialStats.totalConversions)
        expect(finalStats.conversionSuccessRate).toBeGreaterThanOrEqual(0)
        expect(finalStats.conversionSuccessRate).toBeLessThanOrEqual(1)
        expect(finalStats.modernEventsRegistered).toBeGreaterThanOrEqual(0)
      })

      test('ÊáâË©≤Ê≠£Á¢∫Ë®àÁÆóËΩâÊèõÊàêÂäüÁéá', async () => {
        // Âü∑Ë°å‰∏ÄÁ≥ªÂàóÂ∑≤Áü•ÁöÑÊàêÂäüËΩâÊèõ
        const successfulEvents = [
          'EXTRACTION.COMPLETED',
          'STORAGE.SAVE.COMPLETED',
          'UI.POPUP.OPENED'
        ]

        for (const event of successfulEvents) {
          await namingCoordinator.intelligentEmit(event, { success: true })
        }

        const stats = namingCoordinator.getConversionStats()

        // Áî±ÊñºÈÄô‰∫õÈÉΩÊòØÈ†êÂÆöÁæ©ÁöÑËΩâÊèõÔºåÊàêÂäüÁéáÊáâË©≤ÂæàÈ´ò
        expect(stats.conversionSuccessRate).toBeGreaterThan(0.9)
        expect(stats.conversionErrors).toBe(0)
      })

      test('ÊáâË©≤ËøΩËπ§‰∫ã‰ª∂‰ΩøÁî®È†ªÁéáÁµ±Ë®à', async () => {
        const testEvent = 'EXTRACTION.COMPLETED'
        const repeatCount = 5

        // ÈáçË§áËß∏ÁôºÁõ∏Âêå‰∫ã‰ª∂
        for (let i = 0; i < repeatCount; i++) {
          await namingCoordinator.intelligentEmit(testEvent, { iteration: i })
        }

        const stats = namingCoordinator.getConversionStats()
        expect(stats.totalConversions).toBeGreaterThanOrEqual(repeatCount)
      })
    })
  })

  describe('üîß EventPriorityManager Êï¥ÂêàÊ∏¨Ë©¶', () => {
    describe('ÂÑ™ÂÖàÁ¥öÂàÜÈÖçÊ∫ñÁ¢∫ÊÄßÈ©óË≠â', () => {
      test('ÊáâË©≤ÁÇ∫‰∏çÂêåÈ°ûÂà•ÁöÑ‰∫ã‰ª∂ÂàÜÈÖçÊ≠£Á¢∫ÁöÑÂÑ™ÂÖàÁ¥ö', async () => {
        const testEvents = [
          { event: 'SYSTEM.GENERIC.ERROR.CRITICAL', expectedCategory: 'SYSTEM_CRITICAL' },
          { event: 'PLATFORM.READMOO.SWITCH.STARTED', expectedCategory: 'PLATFORM_MANAGEMENT' },
          { event: 'UX.GENERIC.OPEN.STARTED', expectedCategory: 'USER_INTERACTION' },
          { event: 'EXTRACTION.READMOO.EXTRACT.PROGRESS', expectedCategory: 'BUSINESS_PROCESSING' },
          { event: 'ANALYTICS.GENERIC.UPDATE.COMPLETED', expectedCategory: 'BACKGROUND_PROCESSING' }
        ]

        for (const testCase of testEvents) {
          const priority = priorityManager.assignEventPriority(testCase.event)
          const category = priorityManager.inferPriorityCategory(testCase.event)

          expect(category).toBe(testCase.expectedCategory)
          expect(priority).toBeDefined()
          expect(typeof priority).toBe('number')
          expect(priority).toBeGreaterThanOrEqual(0)
          expect(priority).toBeLessThan(500)

          // È©óË≠âÂÑ™ÂÖàÁ¥öÂú®Ê≠£Á¢∫ÁöÑÁØÑÂúçÂÖß
          const config = priorityManager.priorityConfig[category]
          expect(priority).toBeGreaterThanOrEqual(config.range[0])
          expect(priority).toBeLessThanOrEqual(config.range[1])
        }
      })

      test('ÊáâË©≤Ê≠£Á¢∫ËôïÁêÜÂÑ™ÂÖàÁ¥öË°ùÁ™ÅÊ™¢Ê∏¨', async () => {
        const testEvent = 'EXTRACTION.READMOO.EXTRACT.COMPLETED'

        // ÂàÜÈÖçÂàùÂßãÂÑ™ÂÖàÁ¥ö
        const priority1 = priorityManager.assignEventPriority(testEvent)

        // ÊâãÂãïË™øÊï¥ÂÑ™ÂÖàÁ¥ö
        const newPriority = priority1 + 50
        priorityManager.adjustEventPriority(testEvent, newPriority)

        // Ê™¢Ê∏¨Ë°ùÁ™Å
        const conflicts = priorityManager.detectPriorityConflicts()

        // ÊáâË©≤Ê™¢Ê∏¨Âà∞ÈÄôÂÄã‰∫ã‰ª∂ÊúâÂ§öÂÄãÂÑ™ÂÖàÁ¥öÊ≠∑Âè≤
        const eventConflict = conflicts.find(conflict => conflict.eventName === testEvent)
        expect(eventConflict).toBeDefined()
        expect(eventConflict.priorities).toContain(priority1)
        expect(eventConflict.priorities).toContain(newPriority)
      })

      test('ÊáâË©≤ÊîØÊè¥ÂãïÊÖãÂÑ™ÂÖàÁ¥öË™øÊï¥', async () => {
        const testEvent = 'UX.GENERIC.RENDER.COMPLETED'

        // ÂàÜÈÖçÂàùÂßãÂÑ™ÂÖàÁ¥ö
        const initialPriority = priorityManager.assignEventPriority(testEvent)

        // Ë®òÈåÑÊïàËÉΩÊåáÊ®ôÔºàÊ®°Êì¨ÊÖ¢‰∫ã‰ª∂Ôºâ
        priorityManager.recordPerformanceMetrics(testEvent, {
          avgExecutionTime: 400, // Ë∂ÖÈÅé 300ms ÈñæÂÄº
          callCount: 10
        })

        // Âü∑Ë°åÂü∫ÊñºÊïàËÉΩÁöÑÊúÄ‰Ω≥Âåñ
        priorityManager.optimizeBasedOnPerformance()

        // Ê™¢Êü•ÂÑ™ÂÖàÁ¥öÊòØÂê¶Ë¢´Ë™øÊï¥ÔºàÈôç‰ΩéÂÑ™ÂÖàÁ¥öÔºåÂç≥Â¢ûÂä†Êï∏ÂÄºÔºâ
        const finalPriority = priorityManager.getEventPriority(testEvent)
        expect(finalPriority).toBeGreaterThan(initialPriority)
      })

      test('ÊáâË©≤Ëàá EventBus Ê≠£Á¢∫Êï¥ÂêàË®ªÂÜä', async () => {
        const testEvent = 'PLATFORM.READMOO.DETECT.COMPLETED'
        const testHandler = jest.fn()

        // ‰ΩøÁî®ÂÑ™ÂÖàÁ¥öÁÆ°ÁêÜÂô®Ë®ªÂÜä‰∫ã‰ª∂
        priorityManager.registerWithPriority(eventBus, testEvent, testHandler)

        // Ëß∏Áôº‰∫ã‰ª∂
        await eventBus.emit(testEvent, { integration: 'test' })

        // È©óË≠âËôïÁêÜÂô®Ë¢´Ê≠£Á¢∫Ë™øÁî®
        expect(testHandler).toHaveBeenCalled()

        // È©óË≠âÂÑ™ÂÖàÁ¥öË¢´Ê≠£Á¢∫ÂàÜÈÖç
        const assignedPriority = priorityManager.getEventPriority(testEvent)
        expect(assignedPriority).toBeDefined()
      })
    })

    describe('ÊïàËÉΩÊúÄ‰Ω≥ÂåñÂäüËÉΩÊ∏¨Ë©¶', () => {
      test('ÊáâË©≤Ê∫ñÁ¢∫ËøΩËπ§ÂÑ™ÂÖàÁ¥öÂàÜÈÖçÊïàËÉΩ', async () => {
        const testEvents = Array.from({ length: 100 }, (_, i) => `TEST.EVENT.${i}`)

        const startTime = performance.now()

        // ÊâπÈáèÂàÜÈÖçÂÑ™ÂÖàÁ¥ö
        for (const event of testEvents) {
          priorityManager.assignEventPriority(event)
        }

        const endTime = performance.now()
        const totalTime = endTime - startTime

        // È©óË≠âÊïàËÉΩÁµ±Ë®à
        const stats = priorityManager.getPriorityStats()
        expect(stats.totalAssignments).toBe(testEvents.length)
        expect(stats.avgAssignmentTime).toBeGreaterThan(0)
        expect(stats.avgAssignmentTime).toBeLessThan(10) // Âπ≥ÂùáÂ∞èÊñº 10ms
      })

      test('ÊáâË©≤Ê≠£Á¢∫ËôïÁêÜÂÑ™ÂÖàÁ¥öÊúÄ‰Ω≥Âåñ', async () => {
        const testEvents = ['TEST.OPT.1', 'TEST.OPT.2', 'TEST.OPT.3']

        // ÁÇ∫ÊØèÂÄã‰∫ã‰ª∂ÂàÜÈÖçÂÑ™ÂÖàÁ¥ö‰∏¶ÂâµÂª∫Ê≠∑Âè≤
        for (const event of testEvents) {
          const priority1 = priorityManager.assignEventPriority(event)
          priorityManager.adjustEventPriority(event, priority1 + 10)
          priorityManager.adjustEventPriority(event, priority1 + 20)
        }

        // Âü∑Ë°åÊúÄ‰Ω≥Âåñ
        const initialStats = priorityManager.getPriorityStats()
        priorityManager.optimizeEventPriorities()
        const finalStats = priorityManager.getPriorityStats()

        // È©óË≠âÊúÄ‰Ω≥ÂåñË®àÊï∏Âô®Â¢ûÂä†
        expect(finalStats.optimizations).toBeGreaterThan(initialStats.optimizations)
      })
    })
  })

  describe('üîß EventTypeDefinitions Êï¥ÂêàÊ∏¨Ë©¶', () => {
    describe('‰∫ã‰ª∂È°ûÂûãÈ©óË≠âÁ≥ªÁµ±Ê∏¨Ë©¶', () => {
      test('ÊáâË©≤Ê≠£Á¢∫È©óË≠â v2.0 ‰∫ã‰ª∂Ê†ºÂºè', async () => {
        const validEvents = [
          'SYSTEM.GENERIC.INIT.COMPLETED',
          'PLATFORM.READMOO.DETECT.STARTED',
          'EXTRACTION.READMOO.EXTRACT.PROGRESS',
          'DATA.READMOO.SAVE.COMPLETED',
          'UX.GENERIC.RENDER.REQUESTED'
        ]

        const invalidEvents = [
          'INVALID',
          'INVALID.FORMAT',
          'TOO.MANY.PARTS.HERE.INVALID',
          'UNKNOWN_DOMAIN.READMOO.EXTRACT.COMPLETED',
          'EXTRACTION.UNKNOWN_PLATFORM.EXTRACT.COMPLETED'
        ]

        // Ê∏¨Ë©¶ÊúâÊïà‰∫ã‰ª∂
        for (const event of validEvents) {
          const isValid = typeDefinitions.isValidEventName(event)
          expect(isValid).toBe(true)
        }

        // Ê∏¨Ë©¶ÁÑ°Êïà‰∫ã‰ª∂
        for (const event of invalidEvents) {
          const isValid = typeDefinitions.isValidEventName(event)
          expect(isValid).toBe(false)
        }
      })

      test('ÊáâË©≤Êèê‰æõÊô∫ËÉΩÂëΩÂêçÂª∫Ë≠∞', async () => {
        const invalidEvents = [
          'EXTRACTION.COMPLETED', // Áº∫Â∞ëÂπ≥Âè∞
          'INVALID.FORMAT.HERE', // ÁÑ°ÊïàÊ†ºÂºè
          'EXTRACTION.UNKNOWN.EXTRACT.COMPLETED' // Êú™Áü•Âπ≥Âè∞
        ]

        for (const invalidEvent of invalidEvents) {
          const suggestions = typeDefinitions.suggestCorrections(invalidEvent)

          expect(Array.isArray(suggestions)).toBe(true)
          expect(suggestions.length).toBeGreaterThan(0)

          // ÊØèÂÄãÂª∫Ë≠∞ÈÉΩÊáâË©≤ÊòØÊúâÊïàÁöÑÊ†ºÂºè
          for (const suggestion of suggestions) {
            const isValid = typeDefinitions.isValidEventName(suggestion)
            expect(isValid).toBe(true)
          }
        }
      })

      test('ÊáâË©≤Ê≠£Á¢∫ËøΩËπ§‰∫ã‰ª∂‰ΩøÁî®Áµ±Ë®à', async () => {
        const testEvents = [
          'PLATFORM.READMOO.DETECT.COMPLETED',
          'EXTRACTION.READMOO.EXTRACT.STARTED',
          'EXTRACTION.READMOO.EXTRACT.COMPLETED'
        ]

        // ‰ΩøÁî®‰∫ã‰ª∂Â§öÊ¨°
        for (const event of testEvents) {
          for (let i = 0; i < 3; i++) {
            typeDefinitions.recordEventUsage(event)
          }
        }

        // È©óË≠âÁµ±Ë®à
        const stats = typeDefinitions.getUsageStats()
        expect(stats).toBeDefined()

        for (const event of testEvents) {
          expect(stats[event]).toBe(3)
        }
      })

      test('ÊáâË©≤ÊîØÊè¥‰∫ã‰ª∂È°ûÂûãÂàÜÊûêÂíåÂ†±Âëä', async () => {
        const modernEvents = [
          'SYSTEM.GENERIC.ERROR.CRITICAL',
          'PLATFORM.READMOO.SWITCH.STARTED',
          'UX.GENERIC.OPEN.COMPLETED',
          'EXTRACTION.READMOO.EXTRACT.PROGRESS',
          'ANALYTICS.GENERIC.UPDATE.COMPLETED'
        ]

        // Ë®òÈåÑ‰∫ã‰ª∂‰ΩøÁî®
        for (const event of modernEvents) {
          typeDefinitions.recordEventUsage(event)
        }

        // ÁîüÊàêÂàÜÊûêÂ†±Âëä
        const analysis = typeDefinitions.analyzeEventPatterns()

        expect(analysis).toBeDefined()
        expect(analysis.totalEvents).toBe(modernEvents.length)
        expect(analysis.domainDistribution).toBeDefined()
        expect(analysis.platformDistribution).toBeDefined()
        expect(analysis.actionDistribution).toBeDefined()
        expect(analysis.stateDistribution).toBeDefined()
      })
    })

    describe('ÈåØË™§Ê™¢Ê∏¨Âíå‰øÆÊ≠£ÂäüËÉΩÊ∏¨Ë©¶', () => {
      test('ÊáâË©≤Ê™¢Ê∏¨Â∏∏Ë¶ãÁöÑ‰∫ã‰ª∂ÂëΩÂêçÈåØË™§', async () => {
        const commonErrors = [
          'extraction.completed', // Â∞èÂØ´
          'EXTRACTION_COMPLETED', // Â∫ïÁ∑öÂàÜÈöî
          'EXTRACTION-COMPLETED', // Á†¥ÊäòËôüÂàÜÈöî
          'EXTRACTION COMPLETED', // Á©∫Ê†ºÂàÜÈöî
          'EXTRACTION.COMPLETE' // ÁãÄÊÖãÊãºÂØ´ÈåØË™§
        ]

        for (const errorEvent of commonErrors) {
          const errors = typeDefinitions.detectNamingErrors(errorEvent)

          expect(Array.isArray(errors)).toBe(true)
          expect(errors.length).toBeGreaterThan(0)

          // ÊáâË©≤ÂåÖÂê´Áõ∏ÈóúÁöÑÈåØË™§ÊèèËø∞
          const hasRelevantError = errors.some(error =>
            error.includes('Ê†ºÂºè') ||
            error.includes('ÂëΩÂêç') ||
            error.includes('ÊãºÂØ´') ||
            error.includes('ÂàÜÈöîÁ¨¶')
          )
          expect(hasRelevantError).toBe(true)
        }
      })

      test('ÊáâË©≤Êèê‰æõ‰∫ã‰ª∂ÂëΩÂêçÊúÄ‰Ω≥ÂØ¶Ë∏êÂª∫Ë≠∞', async () => {
        const bestPractices = typeDefinitions.getEventNamingBestPractices()

        expect(bestPractices).toBeDefined()
        expect(Array.isArray(bestPractices.rules)).toBe(true)
        expect(bestPractices.rules.length).toBeGreaterThan(0)

        // ÊáâË©≤ÂåÖÂê´Âü∫Êú¨Ë¶èÂâá
        const ruleTexts = bestPractices.rules.join(' ')
        expect(ruleTexts).toMatch(/4.*Â±§Á¥ö|layer/i)
        expect(ruleTexts).toMatch(/DOMAIN.*PLATFORM.*ACTION.*STATE/i)
        expect(ruleTexts).toMatch(/Â§ßÂØ´|uppercase/i)
      })
    })
  })

  describe('üîß ‰∏âÂ§ßÊ†∏ÂøÉÁµÑ‰ª∂Âçî‰ΩúÊï¥ÂêàÊ∏¨Ë©¶', () => {
    describe('ÂÆåÊï¥‰∫ã‰ª∂ËôïÁêÜÊµÅÁ®ãÊ∏¨Ë©¶', () => {
      test('ÊáâË©≤ÂÆåÊï¥ËôïÁêÜÂæû Legacy Âà∞ Modern ÁöÑ‰∫ã‰ª∂ÊµÅÁ®ã', async () => {
        const legacyEvent = 'EXTRACTION.COMPLETED'
        const testData = { bookId: 'test-book-123', extractedCount: 5 }

        // Ë®≠ÁΩÆÂÆåÊï¥ÁöÑ‰∫ã‰ª∂ËôïÁêÜÈèà
        const legacyHandler = jest.fn()
        const modernHandler = jest.fn()

        // 1. ‰ΩøÁî® EventNamingUpgradeCoordinator Ë®ªÂÜäÈõôËªåÁõ£ËÅΩÂô®
        namingCoordinator.registerDualTrackListener(legacyEvent, legacyHandler)

        // 2. Áç≤ÂèñÂ∞çÊáâÁöÑ Modern ‰∫ã‰ª∂ÂêçÁ®±
        const modernEvent = namingCoordinator.convertToModernEvent(legacyEvent)
        expect(modernEvent).toBe('EXTRACTION.READMOO.EXTRACT.COMPLETED')

        // 3. ‰ΩøÁî® EventPriorityManager ÁÇ∫ Modern ‰∫ã‰ª∂ÂàÜÈÖçÂÑ™ÂÖàÁ¥ö
        const priority = priorityManager.assignEventPriority(modernEvent)
        expect(priority).toBeDefined()

        // 4. ‰ΩøÁî® EventTypeDefinitions È©óË≠â Modern ‰∫ã‰ª∂Ê†ºÂºè
        const isValid = typeDefinitions.isValidEventName(modernEvent)
        expect(isValid).toBe(true)

        // 5. Ë®ªÂÜä Modern ‰∫ã‰ª∂ËôïÁêÜÂô®ÔºàÂ∏∂ÂÑ™ÂÖàÁ¥öÔºâ
        priorityManager.registerWithPriority(eventBus, modernEvent, modernHandler)

        // 6. Ëß∏Áôº Legacy ‰∫ã‰ª∂ÔºåÊáâË©≤ÂêåÊôÇËß∏Áôº Modern ‰∫ã‰ª∂
        await namingCoordinator.intelligentEmit(legacyEvent, testData)

        // Á≠âÂæÖ‰∫ã‰ª∂ËôïÁêÜÂÆåÊàê
        await new Promise(resolve => setTimeout(resolve, 100))

        // 7. È©óË≠âÂÆåÊï¥ÊµÅÁ®ã
        expect(legacyHandler).toHaveBeenCalled()
        expect(modernHandler).toHaveBeenCalled()

        // 8. È©óË≠âÁµ±Ë®àË≥áÊñô
        const conversionStats = namingCoordinator.getConversionStats()
        expect(conversionStats.totalConversions).toBeGreaterThan(0)

        const priorityStats = priorityManager.getPriorityStats()
        expect(priorityStats.totalAssignments).toBeGreaterThan(0)

        typeDefinitions.recordEventUsage(modernEvent)
        const usageStats = typeDefinitions.getUsageStats()
        expect(usageStats[modernEvent]).toBeGreaterThan(0)
      })

      test('ÊáâË©≤ËôïÁêÜË§áÈõúÁöÑ‰∫ã‰ª∂ËôïÁêÜÂ†¥ÊôØ', async () => {
        const complexScenario = [
          { event: 'EXTRACTION.STARTED', data: { url: 'https://readmoo.com/book/123' } },
          { event: 'EXTRACTION.PROGRESS', data: { completed: 3, total: 10 } },
          { event: 'STORAGE.SAVE.REQUESTED', data: { books: [] } },
          { event: 'STORAGE.SAVE.COMPLETED', data: { saved: 3 } },
          { event: 'UI.POPUP.OPENED', data: { timestamp: Date.now() } },
          { event: 'EXTRACTION.COMPLETED', data: { totalExtracted: 10 } }
        ]

        const handlerResults = []

        // ÁÇ∫ÊØèÂÄã‰∫ã‰ª∂Ë®≠ÁΩÆËôïÁêÜÂô®
        for (const scenario of complexScenario) {
          const handler = jest.fn((event) => {
            handlerResults.push({
              original: scenario.event,
              processed: event.type,
              data: event.data
            })
          })

          // Ë®ªÂÜäÈõôËªåÁõ£ËÅΩÂô®
          namingCoordinator.registerDualTrackListener(scenario.event, handler)
        }

        // ÊåâÈ†ÜÂ∫èËß∏ÁôºÊâÄÊúâ‰∫ã‰ª∂
        for (const scenario of complexScenario) {
          await namingCoordinator.intelligentEmit(scenario.event, scenario.data)
          await new Promise(resolve => setTimeout(resolve, 10)) // Â∞èÂª∂ÈÅ≤Á¢∫‰øùÈ†ÜÂ∫è
        }

        // Á≠âÂæÖÊâÄÊúâ‰∫ã‰ª∂ËôïÁêÜÂÆåÊàê
        await new Promise(resolve => setTimeout(resolve, 200))

        // È©óË≠âÊâÄÊúâ‰∫ã‰ª∂ÈÉΩË¢´Ê≠£Á¢∫ËôïÁêÜ
        expect(handlerResults.length).toBeGreaterThanOrEqual(complexScenario.length)

        // È©óË≠âÊØèÂÄã‰∫ã‰ª∂ÁöÑË≥áÊñôÂÆåÊï¥ÊÄß
        for (const scenario of complexScenario) {
          const relatedResults = handlerResults.filter(result =>
            result.original === scenario.event ||
            result.processed === scenario.event ||
            result.processed === namingCoordinator.convertToModernEvent(scenario.event)
          )
          expect(relatedResults.length).toBeGreaterThan(0)
        }
      })

      test('ÊáâË©≤Âú®È´òË≤†Ëºâ‰∏ã‰øùÊåÅÁ≥ªÁµ±Á©©ÂÆöÊÄß', async () => {
        const startTime = performance.now()
        const eventCount = 200
        const promises = []

        // ÁîüÊàêÂ§ßÈáè‰∏¶Áôº‰∫ã‰ª∂
        for (let i = 0; i < eventCount; i++) {
          const eventType = i % 2 === 0 ? 'EXTRACTION.COMPLETED' : 'STORAGE.SAVE.COMPLETED'
          const promise = namingCoordinator.intelligentEmit(eventType, {
            iteration: i,
            timestamp: Date.now()
          })
          promises.push(promise)
        }

        // Á≠âÂæÖÊâÄÊúâ‰∫ã‰ª∂ËôïÁêÜÂÆåÊàê
        await Promise.all(promises)

        const endTime = performance.now()
        const totalTime = endTime - startTime

        // È©óË≠âÊïàËÉΩÊåáÊ®ô
        expect(totalTime).toBeLessThan(5000) // Á∏ΩÊôÇÈñìÂ∞ëÊñº 5 Áßí

        // È©óË≠âÁ≥ªÁµ±ÁãÄÊÖã
        const conversionStats = namingCoordinator.getConversionStats()
        expect(conversionStats.totalConversions).toBeGreaterThanOrEqual(eventCount)
        expect(conversionStats.conversionErrors).toBe(0)

        const priorityStats = priorityManager.getPriorityStats()
        expect(priorityStats.errors).toBe(0)

        // Ê™¢Êü•Âπ≥ÂùáËôïÁêÜÊôÇÈñì
        const avgTimePerEvent = totalTime / eventCount
        expect(avgTimePerEvent).toBeLessThan(25) // Âπ≥ÂùáÊØèÂÄã‰∫ã‰ª∂Â∞ëÊñº 25ms
      })
    })

    describe('ÈåØË™§ËôïÁêÜÂíåÊÅ¢Âæ©Êï¥ÂêàÊ∏¨Ë©¶', () => {
      test('ÊáâË©≤ÂÑ™ÈõÖËôïÁêÜÁÑ°Êïà‰∫ã‰ª∂Ê†ºÂºè', async () => {
        const invalidEvents = [
          'INVALID',
          'INVALID.FORMAT',
          'TOO.MANY.PARTS.HERE.NOW',
          '',
          null,
          undefined
        ]

        const errorHandler = jest.fn()

        // Ë®≠ÁΩÆÈåØË™§Áõ£ËÅΩÂô®
        eventBus.on('SYSTEM.ERROR.VALIDATION.FAILED', errorHandler)

        for (const invalidEvent of invalidEvents) {
          if (invalidEvent !== null && invalidEvent !== undefined) {
            // Ê∏¨Ë©¶‰∫ã‰ª∂Ê†ºÂºèÈ©óË≠â
            const isValid = typeDefinitions.isValidEventName(invalidEvent)
            expect(isValid).toBe(false)

            // Ê∏¨Ë©¶ÂÑ™ÂÖàÁ¥öÂàÜÈÖçÈåØË™§ËôïÁêÜ
            expect(() => {
              priorityManager.assignEventPriority(invalidEvent)
            }).not.toThrow() // ÊáâË©≤ÂÑ™ÈõÖËôïÁêÜÔºå‰∏çÊããÂá∫Áï∞Â∏∏

            // Ê∏¨Ë©¶ËΩâÊèõÈåØË™§ËôïÁêÜ
            const modernEvent = namingCoordinator.convertToModernEvent(invalidEvent)
            expect(modernEvent).toBeDefined() // ÊáâË©≤ËøîÂõûÊüêÁ®ÆÂΩ¢ÂºèÁöÑÁµêÊûú
          }
        }
      })

      test('ÊáâË©≤ËôïÁêÜÁ≥ªÁµ±Ë≥áÊ∫ê‰∏çË∂≥ÊÉÖÊ≥Å', async () => {
        // Ê®°Êì¨Ë®òÊÜ∂È´îÂ£ìÂäõÊÉÖÊ≥Å
        const largeDataEvents = []

        // ÂâµÂª∫Â§ßÈáèÂ§ßË≥áÊñô‰∫ã‰ª∂
        for (let i = 0; i < 50; i++) {
          const largeData = {
            iteration: i,
            payload: new Array(1000).fill(`data-${i}`), // Â§ßÈáèË≥áÊñô
            timestamp: Date.now()
          }
          largeDataEvents.push(largeData)
        }

        // Ë®≠ÁΩÆËôïÁêÜÂô®
        const processedEvents = []
        namingCoordinator.registerDualTrackListener('EXTRACTION.COMPLETED', (event) => {
          processedEvents.push(event.data.iteration)
        })

        // Âø´ÈÄüÁôºÈÄÅÊâÄÊúâ‰∫ã‰ª∂
        const promises = largeDataEvents.map((data, index) =>
          namingCoordinator.intelligentEmit('EXTRACTION.COMPLETED', data)
        )

        // ‰∏çÊáâË©≤Âõ†ÁÇ∫Ë®òÊÜ∂È´îÂ£ìÂäõËÄåÂ§±Êïó
        await expect(Promise.all(promises)).resolves.toBeDefined()

        // Á≠âÂæÖËôïÁêÜÂÆåÊàê
        await new Promise(resolve => setTimeout(resolve, 500))

        // È©óË≠âÂ§ßÈÉ®ÂàÜ‰∫ã‰ª∂Ë¢´Ê≠£Á¢∫ËôïÁêÜ
        expect(processedEvents.length).toBeGreaterThan(largeDataEvents.length * 0.8)
      })

      test('ÊáâË©≤ÊîØÊè¥Á≥ªÁµ±ÈáçÂïüÂæåÁöÑÁãÄÊÖãÊÅ¢Âæ©', async () => {
        // Ë®òÈåÑÂàùÂßãÁãÄÊÖã
        const testEvents = ['EXTRACTION.COMPLETED', 'STORAGE.SAVE.COMPLETED']

        for (const event of testEvents) {
          await namingCoordinator.intelligentEmit(event, { test: 'before-restart' })
          priorityManager.assignEventPriority(namingCoordinator.convertToModernEvent(event))
          typeDefinitions.recordEventUsage(event)
        }

        // Ë®òÈåÑÈáçÂïüÂâçÁöÑÁµ±Ë®à
        const preRestartConversionStats = namingCoordinator.getConversionStats()
        const preRestartPriorityStats = priorityManager.getPriorityStats()
        const preRestartUsageStats = typeDefinitions.getUsageStats()

        // Ê®°Êì¨Á≥ªÁµ±ÈáçÂïü (ÈáçÊñ∞ÂàùÂßãÂåñÁµÑ‰ª∂)
        const newEventBus = new EventBus()
        const newNamingCoordinator = new EventNamingUpgradeCoordinator(newEventBus)
        const newPriorityManager = new EventPriorityManager()
        const newTypeDefinitions = new EventTypeDefinitions()

        // Ê®°Êì¨ÁãÄÊÖãÊÅ¢Âæ© (ÂØ¶ÈöõÂØ¶‰Ωú‰∏≠ÂèØËÉΩÂæûÊåÅ‰πÖÂåñÂÑ≤Â≠òÊÅ¢Âæ©)
        for (const event of testEvents) {
          await newNamingCoordinator.intelligentEmit(event, { test: 'after-restart' })
          newPriorityManager.assignEventPriority(newNamingCoordinator.convertToModernEvent(event))
          newTypeDefinitions.recordEventUsage(event)
        }

        // È©óË≠âÈáçÂïüÂæåÁ≥ªÁµ±‰ªçÊ≠£Â∏∏ÈÅã‰Ωú
        const postRestartConversionStats = newNamingCoordinator.getConversionStats()
        const postRestartPriorityStats = newPriorityManager.getPriorityStats()
        const postRestartUsageStats = newTypeDefinitions.getUsageStats()

        expect(postRestartConversionStats.totalConversions).toBeGreaterThan(0)
        expect(postRestartPriorityStats.totalAssignments).toBeGreaterThan(0)
        expect(Object.keys(postRestartUsageStats).length).toBeGreaterThan(0)
      })
    })
  })

  describe('üîß Á≥ªÁµ±Êï¥ÂêàÊïàËÉΩÈ©óË≠â', () => {
    test('ÊáâË©≤ÊªøË∂≥‰∫ã‰ª∂ËΩâÊèõÊïàËÉΩË¶ÅÊ±Ç (< 5ms)', async () => {
      const testEvents = [
        'EXTRACTION.COMPLETED',
        'STORAGE.SAVE.COMPLETED',
        'UI.POPUP.OPENED',
        'BACKGROUND.INIT.COMPLETED'
      ]

      const timings = []

      for (const event of testEvents) {
        const startTime = performance.now()
        namingCoordinator.convertToModernEvent(event)
        const endTime = performance.now()

        const conversionTime = endTime - startTime
        timings.push(conversionTime)

        // ÊØèÂÄãËΩâÊèõÊáâË©≤Â∞ëÊñº 5ms
        expect(conversionTime).toBeLessThan(5)
      }

      // Âπ≥ÂùáËΩâÊèõÊôÇÈñìÊáâË©≤Êõ¥Âø´
      const avgTime = timings.reduce((sum, time) => sum + time, 0) / timings.length
      expect(avgTime).toBeLessThan(2)
    })

    test('ÊáâË©≤ÊªøË∂≥ÂÑ™ÂÖàÁ¥öÂàÜÈÖçÊïàËÉΩË¶ÅÊ±Ç (< 1ms)', async () => {
      const testEvents = [
        'SYSTEM.GENERIC.ERROR.CRITICAL',
        'PLATFORM.READMOO.DETECT.COMPLETED',
        'UX.GENERIC.OPEN.STARTED',
        'EXTRACTION.READMOO.EXTRACT.PROGRESS',
        'ANALYTICS.GENERIC.UPDATE.COMPLETED'
      ]

      const timings = []

      for (const event of testEvents) {
        const startTime = performance.now()
        priorityManager.assignEventPriority(event)
        const endTime = performance.now()

        const assignmentTime = endTime - startTime
        timings.push(assignmentTime)

        // ÊØèÂÄãÂàÜÈÖçÊáâË©≤Â∞ëÊñº 1ms
        expect(assignmentTime).toBeLessThan(1)
      }

      // Âπ≥ÂùáÂàÜÈÖçÊôÇÈñìÊáâË©≤Êõ¥Âø´
      const avgTime = timings.reduce((sum, time) => sum + time, 0) / timings.length
      expect(avgTime).toBeLessThan(0.5)
    })

    test('ÊáâË©≤ÊªøË∂≥ÂëΩÂêçÈ©óË≠âÊïàËÉΩË¶ÅÊ±Ç (< 0.1ms)', async () => {
      const testEvents = [
        'SYSTEM.GENERIC.INIT.COMPLETED',
        'PLATFORM.READMOO.DETECT.STARTED',
        'EXTRACTION.READMOO.EXTRACT.PROGRESS',
        'DATA.READMOO.SAVE.COMPLETED',
        'UX.GENERIC.RENDER.REQUESTED'
      ]

      const timings = []

      for (const event of testEvents) {
        const startTime = performance.now()
        typeDefinitions.isValidEventName(event)
        const endTime = performance.now()

        const validationTime = endTime - startTime
        timings.push(validationTime)

        // ÊØèÂÄãÈ©óË≠âÊáâË©≤Â∞ëÊñº 0.1ms
        expect(validationTime).toBeLessThan(0.1)
      }

      // Âπ≥ÂùáÈ©óË≠âÊôÇÈñìÊáâË©≤Êõ¥Âø´
      const avgTime = timings.reduce((sum, time) => sum + time, 0) / timings.length
      expect(avgTime).toBeLessThan(0.05)
    })

    test('ÊáâË©≤ÊéßÂà∂Ë®òÊÜ∂È´îÂ¢ûÈï∑Âú® 15% ‰ª•ÂÖß', async () => {
      // Áç≤ÂèñÂàùÂßãË®òÊÜ∂È´î‰ΩøÁî® (Ê®°Êì¨)
      const initialMemory = process.memoryUsage()

      // Âü∑Ë°åÂ§ßÈáè‰∫ã‰ª∂ËôïÁêÜ
      const eventCount = 1000
      const promises = []

      for (let i = 0; i < eventCount; i++) {
        const event = i % 4 === 0
          ? 'EXTRACTION.COMPLETED'
          : i % 4 === 1
            ? 'STORAGE.SAVE.COMPLETED'
            : i % 4 === 2
              ? 'UI.POPUP.OPENED'
              : 'BACKGROUND.INIT.COMPLETED'

        const promise = namingCoordinator.intelligentEmit(event, { iteration: i })
        promises.push(promise)

        // ÂêåÊôÇÈÄ≤Ë°åÂÑ™ÂÖàÁ¥öÂàÜÈÖçÂíåÈ°ûÂûãÈ©óË≠â
        const modernEvent = namingCoordinator.convertToModernEvent(event)
        priorityManager.assignEventPriority(modernEvent)
        typeDefinitions.isValidEventName(modernEvent)
      }

      await Promise.all(promises)

      // Âº∑Âà∂ÂûÉÂúæÂõûÊî∂ (Â¶ÇÊûúÂèØÁî®)
      if (global.gc) {
        global.gc()
      }

      // Ê™¢Êü•ÊúÄÁµÇË®òÊÜ∂È´î‰ΩøÁî®
      const finalMemory = process.memoryUsage()

      // Ë®àÁÆóË®òÊÜ∂È´îÂ¢ûÈï∑Áéá
      const memoryGrowth = (finalMemory.heapUsed - initialMemory.heapUsed) / initialMemory.heapUsed

      // Ë®òÊÜ∂È´îÂ¢ûÈï∑ÊáâË©≤ÊéßÂà∂Âú® 15% ‰ª•ÂÖß
      expect(memoryGrowth).toBeLessThan(0.15)
    })
  })
})
