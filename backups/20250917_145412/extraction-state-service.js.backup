/**
 * æå–ç‹€æ…‹ç®¡ç†æœå‹™
 *
 * è² è²¬åŠŸèƒ½ï¼š
 * - æå–ä½œæ¥­çš„ç‹€æ…‹è¿½è¹¤å’Œç®¡ç†
 * - æå–é€²åº¦ç›£æ§å’Œå ±å‘Š
 * - æå–æ­·å²è¨˜éŒ„å’Œçµ±è¨ˆ
 * - ä½œæ¥­æ’ç¨‹å’Œé‡è©¦æ©Ÿåˆ¶
 *
 * è¨­è¨ˆè€ƒé‡ï¼š
 * - å³æ™‚ç‹€æ…‹æ›´æ–°å’Œé€šçŸ¥
 * - æŒä¹…åŒ–ç‹€æ…‹å„²å­˜
 * - è‡ªå‹•é‡è©¦å’ŒéŒ¯èª¤æ¢å¾©æ©Ÿåˆ¶
 * - è©³ç´°çš„ä½œæ¥­ç”Ÿå‘½é€±æœŸè¿½è¹¤
 *
 * ä½¿ç”¨æƒ…å¢ƒï¼š
 * - ç®¡ç†æ›¸ç±è³‡æ–™æå–ä½œæ¥­ç‹€æ…‹
 * - ç›£æ§æå–é€²åº¦å’Œæ•ˆèƒ½è¡¨ç¾
 * - è™•ç†æå–å¤±æ•—å’Œé‡è©¦é‚è¼¯
 */

const {
  EXTRACTION_EVENTS,
  EVENT_PRIORITIES
} = require('src/background/constants/module-constants')
const { StandardError } = require('src/core/errors/StandardError')

class ExtractionStateService {
  constructor (dependencies = {}) {
    // ä¾è³´æ³¨å…¥
    this.eventBus = dependencies.eventBus || null
    this.logger = dependencies.logger || console
    this.i18nManager = dependencies.i18nManager || null

    // æœå‹™ç‹€æ…‹
    this.state = {
      initialized: false,
      active: false,
      tracking: false
    }

    // æå–ä½œæ¥­ç®¡ç†
    this.extractionJobs = new Map()
    this.jobHistory = new Map()
    this.activeJobs = new Set()
    this.failedJobs = new Map()
    this.registeredListeners = new Map()

    // ç‹€æ…‹é…ç½®
    this.config = {
      maxActiveJobs: 5,
      maxRetryAttempts: 3,
      retryDelay: 5000,
      jobTimeout: 300000, // 5åˆ†é˜
      historyRetention: 100,
      enableAutoRetry: true
    }

    // ä½œæ¥­ç‹€æ…‹å®šç¾©
    this.JOB_STATES = {
      PENDING: 'pending',
      RUNNING: 'running',
      COMPLETED: 'completed',
      FAILED: 'failed',
      CANCELLED: 'cancelled',
      RETRYING: 'retrying'
    }

    // çµ±è¨ˆè³‡æ–™
    this.stats = {
      totalJobs: 0,
      completedJobs: 0,
      failedJobs: 0,
      retriedJobs: 0,
      averageCompletionTime: 0,
      totalProcessingTime: 0
    }

    // é€²åº¦è¿½è¹¤
    this.progressTracking = new Map()
    this.performanceMetrics = new Map()
  }

  /**
   * åˆå§‹åŒ–æå–ç‹€æ…‹æœå‹™
   */
  async initialize () {
    if (this.state.initialized) {
      this.logger.warn('âš ï¸ æå–ç‹€æ…‹æœå‹™å·²åˆå§‹åŒ–')
      return
    }

    try {
      this.logger.log('ğŸ“Š åˆå§‹åŒ–æå–ç‹€æ…‹æœå‹™')

      // åˆå§‹åŒ–ä½œæ¥­èª¿åº¦å™¨
      await this.initializeJobScheduler()

      // è¼‰å…¥æ­·å²ä½œæ¥­è¨˜éŒ„
      await this.loadJobHistory()

      // è¨»å†Šäº‹ä»¶ç›£è½å™¨
      await this.registerEventListeners()

      this.state.initialized = true
      this.logger.log('âœ… æå–ç‹€æ…‹æœå‹™åˆå§‹åŒ–å®Œæˆ')

      // ç™¼é€åˆå§‹åŒ–å®Œæˆäº‹ä»¶
      if (this.eventBus) {
        await this.eventBus.emit('EXTRACTION.STATE.INITIALIZED', {
          serviceName: 'ExtractionStateService',
          config: this.config
        })
      }
    } catch (error) {
      this.logger.error('âŒ åˆå§‹åŒ–æå–ç‹€æ…‹æœå‹™å¤±æ•—:', error)
      throw error
    }
  }

  /**
   * å•Ÿå‹•æå–ç‹€æ…‹æœå‹™
   */
  async start () {
    if (!this.state.initialized) {
      throw new StandardErrorWrapper('UNKNOWN_ERROR', 'æœå‹™å°šæœªåˆå§‹åŒ–', {
        category: 'general'
      })
    }

    if (this.state.active) {
      this.logger.warn('âš ï¸ æå–ç‹€æ…‹æœå‹™å·²å•Ÿå‹•')
      return
    }

    try {
      this.logger.log('ğŸš€ å•Ÿå‹•æå–ç‹€æ…‹æœå‹™')

      this.state.active = true
      this.state.tracking = true

      // å•Ÿå‹•è‡ªå‹•é‡è©¦æ©Ÿåˆ¶
      this.startAutoRetryMechanism()

      // å•Ÿå‹•æ¸…ç†æ©Ÿåˆ¶
      this.startCleanupMechanism()

      this.logger.log('âœ… æå–ç‹€æ…‹æœå‹™å•Ÿå‹•å®Œæˆ')

      // ç™¼é€å•Ÿå‹•å®Œæˆäº‹ä»¶
      if (this.eventBus) {
        await this.eventBus.emit('EXTRACTION.STATE.STARTED', {
          serviceName: 'ExtractionStateService'
        })
      }
    } catch (error) {
      this.logger.error('âŒ å•Ÿå‹•æå–ç‹€æ…‹æœå‹™å¤±æ•—:', error)
      throw error
    }
  }

  /**
   * åœæ­¢æå–ç‹€æ…‹æœå‹™
   */
  async stop () {
    if (!this.state.active) {
      this.logger.warn('âš ï¸ æå–ç‹€æ…‹æœå‹™æœªå•Ÿå‹•')
      return
    }

    try {
      this.logger.log('ğŸ›‘ åœæ­¢æå–ç‹€æ…‹æœå‹™')

      // åœæ­¢æ‰€æœ‰æ´»å‹•ä½œæ¥­
      await this.cancelAllActiveJobs()

      // åœæ­¢è‡ªå‹•æ©Ÿåˆ¶
      this.stopAutoMechanisms()

      // å–æ¶ˆè¨»å†Šäº‹ä»¶ç›£è½å™¨
      await this.unregisterEventListeners()

      this.state.active = false
      this.state.tracking = false

      this.logger.log('âœ… æå–ç‹€æ…‹æœå‹™åœæ­¢å®Œæˆ')

      // ç™¼é€åœæ­¢å®Œæˆäº‹ä»¶
      if (this.eventBus) {
        await this.eventBus.emit('EXTRACTION.STATE.STOPPED', {
          serviceName: 'ExtractionStateService',
          finalStats: { ...this.stats }
        })
      }
    } catch (error) {
      this.logger.error('âŒ åœæ­¢æå–ç‹€æ…‹æœå‹™å¤±æ•—:', error)
      throw error
    }
  }

  /**
   * å‰µå»ºæ–°çš„æå–ä½œæ¥­
   */
  async createExtractionJob (jobConfig) {
    try {
      const jobId = this.generateJobId()

      const job = {
        id: jobId,
        type: jobConfig.type || 'unknown',
        source: jobConfig.source || 'unknown',
        target: jobConfig.target || null,
        state: this.JOB_STATES.PENDING,
        createdAt: Date.now(),
        startedAt: null,
        completedAt: null,
        config: { ...jobConfig },
        progress: {
          current: 0,
          total: jobConfig.total || 1,
          percentage: 0
        },
        attempts: 0,
        maxAttempts: jobConfig.maxAttempts || this.config.maxRetryAttempts,
        errors: [],
        metadata: {},
        result: null
      }

      this.extractionJobs.set(jobId, job)
      this.stats.totalJobs++

      this.logger.log(`ğŸ“ å‰µå»ºæå–ä½œæ¥­: ${jobId} (${job.type})`)

      // ç™¼é€ä½œæ¥­å‰µå»ºäº‹ä»¶
      if (this.eventBus) {
        await this.eventBus.emit('EXTRACTION.JOB.CREATED', {
          jobId,
          jobType: job.type,
          jobConfig: job.config
        })
      }

      return jobId
    } catch (error) {
      this.logger.error('âŒ å‰µå»ºæå–ä½œæ¥­å¤±æ•—:', error)
      throw error
    }
  }

  /**
   * é–‹å§‹åŸ·è¡Œæå–ä½œæ¥­
   */
  async startExtractionJob (jobId) {
    try {
      const job = this.extractionJobs.get(jobId)
      if (!job) {
        throw new StandardErrorWrapper('UNKNOWN_ERROR', 'æå–ä½œæ¥­ä¸å­˜åœ¨: ${jobId}', {
          category: 'general'
        })
      }

      if (job.state !== this.JOB_STATES.PENDING && job.state !== this.JOB_STATES.RETRYING) {
        throw new StandardErrorWrapper('UNKNOWN_ERROR', 'ä½œæ¥­ç‹€æ…‹ç„¡æ•ˆï¼Œç„¡æ³•å•Ÿå‹•: ${job.state}', {
          category: 'general'
        })
      }

      // æª¢æŸ¥åŒæ™‚é€²è¡Œçš„ä½œæ¥­æ•¸é‡
      if (this.activeJobs.size >= this.config.maxActiveJobs) {
        throw new StandardErrorWrapper('UNKNOWN_ERROR', 'å·²é”åˆ°æœ€å¤§åŒæ™‚ä½œæ¥­æ•¸é‡é™åˆ¶', {
          category: 'general'
        })
      }

      // æ›´æ–°ä½œæ¥­ç‹€æ…‹
      job.state = this.JOB_STATES.RUNNING
      job.startedAt = Date.now()
      job.attempts++

      this.activeJobs.add(jobId)

      // è¨­å®šè¶…æ™‚è™•ç†
      this.setJobTimeout(jobId)

      this.logger.log(`â–¶ï¸ é–‹å§‹åŸ·è¡Œæå–ä½œæ¥­: ${jobId}`)

      // ç™¼é€ä½œæ¥­é–‹å§‹äº‹ä»¶
      if (this.eventBus) {
        await this.eventBus.emit('EXTRACTION.JOB.STARTED', {
          jobId,
          jobType: job.type,
          attempt: job.attempts
        })
      }

      return true
    } catch (error) {
      this.logger.error(`âŒ å•Ÿå‹•æå–ä½œæ¥­å¤±æ•— (${jobId}):`, error)
      throw error
    }
  }

  /**
   * æ›´æ–°ä½œæ¥­é€²åº¦
   */
  async updateJobProgress (jobId, progress) {
    try {
      const job = this.extractionJobs.get(jobId)
      if (!job) {
        throw new StandardErrorWrapper('UNKNOWN_ERROR', 'æå–ä½œæ¥­ä¸å­˜åœ¨: ${jobId}', {
          category: 'general'
        })
      }

      // æ›´æ–°é€²åº¦
      job.progress.current = Math.min(progress.current || 0, job.progress.total)
      job.progress.percentage = job.progress.total > 0
        ? (job.progress.current / job.progress.total * 100)
        : 0

      // æ›´æ–°å…ƒè³‡æ–™
      if (progress.metadata) {
        Object.assign(job.metadata, progress.metadata)
      }

      // ç™¼é€é€²åº¦æ›´æ–°äº‹ä»¶
      if (this.eventBus) {
        await this.eventBus.emit('EXTRACTION.JOB.PROGRESS', {
          jobId,
          progress: job.progress,
          metadata: progress.metadata
        })
      }
    } catch (error) {
      this.logger.error(`âŒ æ›´æ–°ä½œæ¥­é€²åº¦å¤±æ•— (${jobId}):`, error)
    }
  }

  /**
   * å®Œæˆæå–ä½œæ¥­
   */
  async completeExtractionJob (jobId, result = null) {
    try {
      const job = this.extractionJobs.get(jobId)
      if (!job) {
        throw new StandardErrorWrapper('UNKNOWN_ERROR', 'æå–ä½œæ¥­ä¸å­˜åœ¨: ${jobId}', {
          category: 'general'
        })
      }

      // æ›´æ–°ä½œæ¥­ç‹€æ…‹
      job.state = this.JOB_STATES.COMPLETED
      job.completedAt = Date.now()
      job.result = result
      job.progress.current = job.progress.total
      job.progress.percentage = 100

      // å¾æ´»å‹•ä½œæ¥­ä¸­ç§»é™¤
      this.activeJobs.delete(jobId)

      // æ›´æ–°çµ±è¨ˆ
      this.stats.completedJobs++
      const completionTime = job.completedAt - job.startedAt
      this.stats.totalProcessingTime += completionTime
      this.stats.averageCompletionTime = this.stats.totalProcessingTime / this.stats.completedJobs

      // ç§»å‹•åˆ°æ­·å²è¨˜éŒ„
      this.moveJobToHistory(jobId)

      this.logger.log(`âœ… æå–ä½œæ¥­å®Œæˆ: ${jobId} (${completionTime}ms)`)

      // ç™¼é€ä½œæ¥­å®Œæˆäº‹ä»¶
      if (this.eventBus) {
        await this.eventBus.emit('EXTRACTION.JOB.COMPLETED', {
          jobId,
          jobType: job.type,
          completionTime,
          result
        })
      }
    } catch (error) {
      this.logger.error(`âŒ å®Œæˆæå–ä½œæ¥­å¤±æ•— (${jobId}):`, error)
      throw error
    }
  }

  /**
   * è™•ç†ä½œæ¥­å¤±æ•—
   */
  async failExtractionJob (jobId, error) {
    try {
      const job = this.extractionJobs.get(jobId)
      if (!job) {
        throw new StandardErrorWrapper('UNKNOWN_ERROR', 'æå–ä½œæ¥­ä¸å­˜åœ¨: ${jobId}', {
          category: 'general'
        })
      }

      // è¨˜éŒ„éŒ¯èª¤
      job.errors.push({
        message: error.message || 'æœªçŸ¥éŒ¯èª¤',
        timestamp: Date.now(),
        attempt: job.attempts
      })

      // å¾æ´»å‹•ä½œæ¥­ä¸­ç§»é™¤
      this.activeJobs.delete(jobId)

      // æª¢æŸ¥æ˜¯å¦éœ€è¦é‡è©¦
      if (this.config.enableAutoRetry && job.attempts < job.maxAttempts) {
        job.state = this.JOB_STATES.RETRYING
        this.scheduleJobRetry(jobId)
        this.stats.retriedJobs++

        this.logger.log(`ğŸ”„ å®‰æ’é‡è©¦æå–ä½œæ¥­: ${jobId} (å˜—è©¦ ${job.attempts}/${job.maxAttempts})`)
      } else {
        job.state = this.JOB_STATES.FAILED
        job.completedAt = Date.now()
        this.stats.failedJobs++
        this.failedJobs.set(jobId, job)

        // ç§»å‹•åˆ°æ­·å²è¨˜éŒ„
        this.moveJobToHistory(jobId)

        this.logger.error(`âŒ æå–ä½œæ¥­å¤±æ•—: ${jobId}`, error)
      }

      // ç™¼é€ä½œæ¥­å¤±æ•—äº‹ä»¶
      if (this.eventBus) {
        await this.eventBus.emit('EXTRACTION.JOB.FAILED', {
          jobId,
          jobType: job.type,
          error: error.message,
          willRetry: job.state === this.JOB_STATES.RETRYING
        })
      }
    } catch (err) {
      this.logger.error(`âŒ è™•ç†ä½œæ¥­å¤±æ•—æ™‚ç™¼ç”ŸéŒ¯èª¤ (${jobId}):`, err)
    }
  }

  /**
   * å–æ¶ˆæå–ä½œæ¥­
   */
  async cancelExtractionJob (jobId) {
    try {
      const job = this.extractionJobs.get(jobId)
      if (!job) {
        throw new StandardErrorWrapper('UNKNOWN_ERROR', 'æå–ä½œæ¥­ä¸å­˜åœ¨: ${jobId}', {
          category: 'general'
        })
      }

      job.state = this.JOB_STATES.CANCELLED
      job.completedAt = Date.now()

      this.activeJobs.delete(jobId)
      this.moveJobToHistory(jobId)

      this.logger.log(`ğŸš« å–æ¶ˆæå–ä½œæ¥­: ${jobId}`)

      // ç™¼é€ä½œæ¥­å–æ¶ˆäº‹ä»¶
      if (this.eventBus) {
        await this.eventBus.emit('EXTRACTION.JOB.CANCELLED', {
          jobId,
          jobType: job.type
        })
      }
    } catch (error) {
      this.logger.error(`âŒ å–æ¶ˆæå–ä½œæ¥­å¤±æ•— (${jobId}):`, error)
      throw error
    }
  }

  /**
   * å–æ¶ˆæ‰€æœ‰æ´»å‹•ä½œæ¥­
   */
  async cancelAllActiveJobs () {
    const activeJobIds = Array.from(this.activeJobs)
    for (const jobId of activeJobIds) {
      try {
        await this.cancelExtractionJob(jobId)
      } catch (error) {
        this.logger.error(`âŒ å–æ¶ˆæ´»å‹•ä½œæ¥­å¤±æ•— (${jobId}):`, error)
      }
    }
  }

  /**
   * ç²å–ä½œæ¥­ç‹€æ…‹
   */
  getJobStatus (jobId) {
    const job = this.extractionJobs.get(jobId) || this.jobHistory.get(jobId)
    if (!job) {
      return null
    }

    return {
      id: job.id,
      type: job.type,
      state: job.state,
      progress: job.progress,
      createdAt: job.createdAt,
      startedAt: job.startedAt,
      completedAt: job.completedAt,
      attempts: job.attempts,
      errors: job.errors,
      result: job.result
    }
  }

  /**
   * ç²å–æ‰€æœ‰ä½œæ¥­ç‹€æ…‹
   */
  getAllJobStatuses () {
    const statuses = {}

    // æ´»å‹•ä½œæ¥­
    for (const [jobId] of this.extractionJobs) {
      statuses[jobId] = this.getJobStatus(jobId)
    }

    // æ­·å²ä½œæ¥­
    for (const [jobId] of this.jobHistory) {
      if (!statuses[jobId]) {
        statuses[jobId] = this.getJobStatus(jobId)
      }
    }

    return statuses
  }

  /**
   * åˆå§‹åŒ–ä½œæ¥­èª¿åº¦å™¨
   */
  async initializeJobScheduler () {
    // åˆå§‹åŒ–èª¿åº¦å™¨é‚è¼¯
    this.logger.log('âš™ï¸ ä½œæ¥­èª¿åº¦å™¨åˆå§‹åŒ–å®Œæˆ')
  }

  /**
   * è¼‰å…¥æ­·å²ä½œæ¥­è¨˜éŒ„
   */
  async loadJobHistory () {
    // å¾æŒä¹…åŒ–å„²å­˜è¼‰å…¥æ­·å²è¨˜éŒ„
    this.logger.log('ğŸ“š æ­·å²ä½œæ¥­è¨˜éŒ„è¼‰å…¥å®Œæˆ')
  }

  /**
   * å•Ÿå‹•è‡ªå‹•é‡è©¦æ©Ÿåˆ¶
   */
  startAutoRetryMechanism () {
    this.autoRetryInterval = setInterval(() => {
      this.processRetryQueue()
    }, this.config.retryDelay)
  }

  /**
   * å•Ÿå‹•æ¸…ç†æ©Ÿåˆ¶
   */
  startCleanupMechanism () {
    this.cleanupInterval = setInterval(() => {
      this.cleanupOldJobs()
    }, 60000) // æ¯åˆ†é˜æ¸…ç†ä¸€æ¬¡
  }

  /**
   * åœæ­¢è‡ªå‹•æ©Ÿåˆ¶
   */
  stopAutoMechanisms () {
    if (this.autoRetryInterval) {
      clearInterval(this.autoRetryInterval)
      this.autoRetryInterval = null
    }
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval)
      this.cleanupInterval = null
    }
  }

  /**
   * è™•ç†é‡è©¦ä½‡åˆ—
   */
  processRetryQueue () {
    // è™•ç†éœ€è¦é‡è©¦çš„ä½œæ¥­
  }

  /**
   * æ¸…ç†èˆŠä½œæ¥­
   */
  cleanupOldJobs () {
    // æ¸…ç†éæœŸçš„æ­·å²è¨˜éŒ„
    if (this.jobHistory.size > this.config.historyRetention) {
      const entries = Array.from(this.jobHistory.entries())
      entries.sort((a, b) => a[1].completedAt - b[1].completedAt)

      const toRemove = entries.slice(0, entries.length - this.config.historyRetention)
      toRemove.forEach(([jobId]) => {
        this.jobHistory.delete(jobId)
      })

      this.logger.log(`ğŸ§¹ æ¸…ç†äº† ${toRemove.length} å€‹èˆŠä½œæ¥­è¨˜éŒ„`)
    }
  }

  /**
   * å®‰æ’ä½œæ¥­é‡è©¦
   */
  scheduleJobRetry (jobId) {
    setTimeout(async () => {
      try {
        await this.startExtractionJob(jobId)
      } catch (error) {
        await this.failExtractionJob(jobId, error)
      }
    }, this.config.retryDelay)
  }

  /**
   * è¨­å®šä½œæ¥­è¶…æ™‚
   */
  setJobTimeout (jobId) {
    setTimeout(async () => {
      const job = this.extractionJobs.get(jobId)
      if (job && job.state === this.JOB_STATES.RUNNING) {
        await this.failExtractionJob(jobId, new StandardErrorWrapper('UNKNOWN_ERROR', 'ä½œæ¥­åŸ·è¡Œè¶…æ™‚', {
          category: 'general'
        }))
      }
    }, this.config.jobTimeout)
  }

  /**
   * ç§»å‹•ä½œæ¥­åˆ°æ­·å²è¨˜éŒ„
   */
  moveJobToHistory (jobId) {
    const job = this.extractionJobs.get(jobId)
    if (job) {
      this.jobHistory.set(jobId, job)
      this.extractionJobs.delete(jobId)
    }
  }

  /**
   * ç”Ÿæˆä½œæ¥­ ID
   */
  generateJobId () {
    return `job_${Date.now()}_${Math.random().toString(36).substr(2, 8)}`
  }

  /**
   * è¨»å†Šäº‹ä»¶ç›£è½å™¨
   */
  async registerEventListeners () {
    if (!this.eventBus) {
      this.logger.warn('âš ï¸ EventBus ä¸å¯ç”¨ï¼Œè·³éäº‹ä»¶ç›£è½å™¨è¨»å†Š')
      return
    }

    const listeners = [
      {
        event: EXTRACTION_EVENTS.JOB_CREATE_REQUEST,
        handler: this.handleJobCreateRequest.bind(this),
        priority: EVENT_PRIORITIES.HIGH
      },
      {
        event: EXTRACTION_EVENTS.JOB_START_REQUEST,
        handler: this.handleJobStartRequest.bind(this),
        priority: EVENT_PRIORITIES.HIGH
      },
      {
        event: EXTRACTION_EVENTS.JOB_PROGRESS_UPDATE,
        handler: this.handleJobProgressUpdate.bind(this),
        priority: EVENT_PRIORITIES.NORMAL
      },
      {
        event: EXTRACTION_EVENTS.JOB_COMPLETE_REQUEST,
        handler: this.handleJobCompleteRequest.bind(this),
        priority: EVENT_PRIORITIES.HIGH
      },
      {
        event: EXTRACTION_EVENTS.JOB_FAIL_REQUEST,
        handler: this.handleJobFailRequest.bind(this),
        priority: EVENT_PRIORITIES.HIGH
      }
    ]

    for (const { event, handler, priority } of listeners) {
      const listenerId = await this.eventBus.on(event, handler, { priority })
      this.registeredListeners.set(event, listenerId)
    }

    this.logger.log(`âœ… è¨»å†Šäº† ${listeners.length} å€‹äº‹ä»¶ç›£è½å™¨`)
  }

  /**
   * å–æ¶ˆè¨»å†Šäº‹ä»¶ç›£è½å™¨
   */
  async unregisterEventListeners () {
    if (!this.eventBus) return

    for (const [event, listenerId] of this.registeredListeners) {
      try {
        await this.eventBus.off(event, listenerId)
      } catch (error) {
        this.logger.error(`âŒ å–æ¶ˆè¨»å†Šäº‹ä»¶ç›£è½å™¨å¤±æ•— (${event}):`, error)
      }
    }

    this.registeredListeners.clear()
    this.logger.log('âœ… æ‰€æœ‰äº‹ä»¶ç›£è½å™¨å·²å–æ¶ˆè¨»å†Š')
  }

  /**
   * è™•ç†ä½œæ¥­å‰µå»ºè«‹æ±‚
   */
  async handleJobCreateRequest (event) {
    try {
      const { jobConfig, requestId } = event.data || {}
      const jobId = await this.createExtractionJob(jobConfig)

      if (this.eventBus) {
        await this.eventBus.emit('EXTRACTION.JOB_CREATE.RESULT', {
          requestId,
          jobId,
          success: true
        })
      }
    } catch (error) {
      this.logger.error('âŒ è™•ç†ä½œæ¥­å‰µå»ºè«‹æ±‚å¤±æ•—:', error)
    }
  }

  /**
   * è™•ç†ä½œæ¥­å•Ÿå‹•è«‹æ±‚
   */
  async handleJobStartRequest (event) {
    try {
      const { jobId, requestId } = event.data || {}
      await this.startExtractionJob(jobId)

      if (this.eventBus) {
        await this.eventBus.emit('EXTRACTION.JOB_START.RESULT', {
          requestId,
          jobId,
          success: true
        })
      }
    } catch (error) {
      this.logger.error('âŒ è™•ç†ä½œæ¥­å•Ÿå‹•è«‹æ±‚å¤±æ•—:', error)
    }
  }

  /**
   * è™•ç†é€²åº¦æ›´æ–°
   */
  async handleJobProgressUpdate (event) {
    try {
      const { jobId, progress } = event.data || {}
      await this.updateJobProgress(jobId, progress)
    } catch (error) {
      this.logger.error('âŒ è™•ç†é€²åº¦æ›´æ–°å¤±æ•—:', error)
    }
  }

  /**
   * è™•ç†ä½œæ¥­å®Œæˆè«‹æ±‚
   */
  async handleJobCompleteRequest (event) {
    try {
      const { jobId, result } = event.data || {}
      await this.completeExtractionJob(jobId, result)
    } catch (error) {
      this.logger.error('âŒ è™•ç†ä½œæ¥­å®Œæˆè«‹æ±‚å¤±æ•—:', error)
    }
  }

  /**
   * è™•ç†ä½œæ¥­å¤±æ•—è«‹æ±‚
   */
  async handleJobFailRequest (event) {
    try {
      const { jobId, error } = event.data || {}
      await this.failExtractionJob(jobId, new StandardError('UNKNOWN_ERROR', error, {
        category: 'general'
      }))
    } catch (error) {
      this.logger.error('âŒ è™•ç†ä½œæ¥­å¤±æ•—è«‹æ±‚å¤±æ•—:', error)
    }
  }

  /**
   * ç²å–æœå‹™ç‹€æ…‹
   */
  getStatus () {
    return {
      initialized: this.state.initialized,
      active: this.state.active,
      tracking: this.state.tracking,
      config: this.config,
      activeJobs: this.activeJobs.size,
      totalJobs: this.extractionJobs.size,
      historyJobs: this.jobHistory.size,
      failedJobs: this.failedJobs.size,
      stats: { ...this.stats }
    }
  }

  /**
   * ç²å–å¥åº·ç‹€æ…‹
   */
  getHealthStatus () {
    const failureRate = this.stats.totalJobs > 0
      ? (this.stats.failedJobs / this.stats.totalJobs)
      : 0

    const avgCompletionTime = this.stats.averageCompletionTime

    const isHealthy = this.state.initialized &&
                     failureRate < 0.2 && // å¤±æ•—ç‡ä½æ–¼20%
                     avgCompletionTime < 60000 && // å¹³å‡å®Œæˆæ™‚é–“ä½æ–¼1åˆ†é˜
                     this.activeJobs.size <= this.config.maxActiveJobs

    return {
      service: 'ExtractionStateService',
      healthy: isHealthy,
      status: this.state.active ? 'active' : 'inactive',
      tracking: this.state.tracking,
      metrics: {
        totalJobs: this.stats.totalJobs,
        completedJobs: this.stats.completedJobs,
        failedJobs: this.stats.failedJobs,
        retriedJobs: this.stats.retriedJobs,
        activeJobs: this.activeJobs.size,
        averageCompletionTime: avgCompletionTime.toFixed(2) + 'ms',
        failureRate: (failureRate * 100).toFixed(2) + '%'
      }
    }
  }
}

module.exports = ExtractionStateService
