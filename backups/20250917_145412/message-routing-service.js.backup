/**
 * è¨Šæ¯è·¯ç”±æœå‹™
 *
 * è² è²¬åŠŸèƒ½ï¼š
 * - ç®¡ç†è¨Šæ¯çš„è·¯ç”±å’Œåˆ†ç™¼é‚è¼¯
 * - è™•ç†ä¸åŒä¾†æºçš„è¨Šæ¯é¡žåž‹è­˜åˆ¥
 * - å”èª¿è¨Šæ¯è™•ç†å™¨çš„è¨»å†Šå’ŒåŸ·è¡Œ
 * - å¯¦ç¾è¨Šæ¯è½‰æ›å’Œæ ¼å¼æ¨™æº–åŒ–
 *
 * è¨­è¨ˆè€ƒé‡ï¼š
 * - æ”¯æ´å¤šç¨®è¨Šæ¯ä¾†æºå’Œç›®æ¨™
 * - å¯æ’æ‹”çš„è¨Šæ¯è™•ç†å™¨æž¶æ§‹
 * - çµ±ä¸€çš„è¨Šæ¯æ ¼å¼å’Œé©—è­‰
 * - é«˜æ•ˆèƒ½çš„è·¯ç”±æ¼”ç®—æ³•
 *
 * ä½¿ç”¨æƒ…å¢ƒï¼š
 * - Content Script èˆ‡ Background é€šè¨Š
 * - Popup èˆ‡ Background é€šè¨Š
 * - å…§éƒ¨æ¨¡çµ„é–“äº‹ä»¶è·¯ç”±
 */

const {
  MESSAGE_TYPES,
  MESSAGE_SOURCES,
  EVENT_PRIORITIES,
  TIMEOUTS
} = require('src/background/constants/module-constants')
const { StandardError } = require('src/core/errors/StandardError')

class MessageRoutingService {
  constructor (dependencies = {}) {
    // ä¾è³´æ³¨å…¥
    this.eventBus = dependencies.eventBus || null
    this.logger = dependencies.logger || console
    this.i18nManager = dependencies.i18nManager || null

    // æœå‹™ç‹€æ…‹
    this.state = {
      initialized: false,
      active: false
    }

    // è·¯ç”±ç®¡ç†
    this.messageHandlers = new Map()
    this.messageTransformers = new Map()
    this.routingRules = new Map()
    this.registeredListeners = new Map()

    // æœå‹™ä¾è³´
    this.validationService = null
    this.queueService = null
    this.sessionService = null
    this.connectionService = null

    // çµ±è¨ˆè³‡æ–™
    this.stats = {
      messagesRouted: 0,
      routingErrors: 0,
      transformationsApplied: 0,
      handlersExecuted: 0,
      averageRouteTime: 0
    }
  }

  /**
   * åˆå§‹åŒ–è·¯ç”±æœå‹™
   */
  async initialize () {
    if (this.state.initialized) {
      this.logger.warn('âš ï¸ è¨Šæ¯è·¯ç”±æœå‹™å·²åˆå§‹åŒ–')
      return
    }

    try {
      this.logger.log('ðŸ”„ åˆå§‹åŒ–è¨Šæ¯è·¯ç”±æœå‹™')

      // åˆå§‹åŒ–è¨Šæ¯è™•ç†å™¨
      await this.initializeMessageHandlers()

      // åˆå§‹åŒ–è¨Šæ¯è½‰æ›å™¨
      await this.initializeMessageTransformers()

      // åˆå§‹åŒ–è·¯ç”±è¦å‰‡
      await this.initializeRoutingRules()

      this.state.initialized = true
      this.logger.log('âœ… è¨Šæ¯è·¯ç”±æœå‹™åˆå§‹åŒ–å®Œæˆ')
    } catch (error) {
      this.logger.error('âŒ åˆå§‹åŒ–è¨Šæ¯è·¯ç”±æœå‹™å¤±æ•—:', error)
      throw error
    }
  }

  /**
   * å•Ÿå‹•è·¯ç”±æœå‹™
   */
  async start () {
    if (!this.state.initialized) {
      throw new StandardErrorWrapper('UNKNOWN_ERROR', 'è·¯ç”±æœå‹™å°šæœªåˆå§‹åŒ–', {
        category: 'general'
      })
    }

    if (this.state.active) {
      this.logger.warn('âš ï¸ è¨Šæ¯è·¯ç”±æœå‹™å·²å•Ÿå‹•')
      return
    }

    try {
      this.logger.log('ðŸš€ å•Ÿå‹•è¨Šæ¯è·¯ç”±æœå‹™')

      // è¨»å†Šäº‹ä»¶ç›£è½å™¨
      await this.registerEventListeners()

      this.state.active = true
      this.logger.log('âœ… è¨Šæ¯è·¯ç”±æœå‹™å•Ÿå‹•å®Œæˆ')
    } catch (error) {
      this.logger.error('âŒ å•Ÿå‹•è¨Šæ¯è·¯ç”±æœå‹™å¤±æ•—:', error)
      throw error
    }
  }

  /**
   * åœæ­¢è·¯ç”±æœå‹™
   */
  async stop () {
    if (!this.state.active) {
      this.logger.warn('âš ï¸ è¨Šæ¯è·¯ç”±æœå‹™æœªå•Ÿå‹•')
      return
    }

    try {
      this.logger.log('ðŸ›‘ åœæ­¢è¨Šæ¯è·¯ç”±æœå‹™')

      // å–æ¶ˆè¨»å†Šäº‹ä»¶ç›£è½å™¨
      await this.unregisterEventListeners()

      this.state.active = false
      this.logger.log('âœ… è¨Šæ¯è·¯ç”±æœå‹™åœæ­¢å®Œæˆ')
    } catch (error) {
      this.logger.error('âŒ åœæ­¢è¨Šæ¯è·¯ç”±æœå‹™å¤±æ•—:', error)
      throw error
    }
  }

  /**
   * åˆå§‹åŒ–è¨Šæ¯è™•ç†å™¨
   */
  async initializeMessageHandlers () {
    try {
      // Content Script è¨Šæ¯è™•ç†å™¨
      this.messageHandlers.set(MESSAGE_TYPES.CONTENT_TO_BACKGROUND, async (message, context) => {
        const { tabId, source } = context

        this.logger.log(`ðŸ“¨ è™•ç† Content Script è¨Šæ¯: ${message.type || 'unknown'} (Tab ${tabId})`)

        // æ›´æ–°é€£æŽ¥ç‹€æ…‹
        if (this.connectionService) {
          this.connectionService.updateConnectionState(tabId, 'active', source)
        }

        // æ ¹æ“šè¨Šæ¯é¡žåž‹è™•ç†
        switch (message.type) {
          case MESSAGE_TYPES.CONTENT_SCRIPT_READY:
            return await this.handleContentScriptReady(message, context)

          case MESSAGE_TYPES.CONTENT_EVENT_FORWARD:
            return await this.handleContentEventForward(message, context)

          case MESSAGE_TYPES.CONTENT_STATUS_UPDATE:
            return await this.handleContentStatusUpdate(message, context)

          case MESSAGE_TYPES.CONTENT_SCRIPT_ERROR:
            return await this.handleContentScriptError(message, context)

          default:
            return await this.handleGenericContentMessage(message, context)
        }
      })

      // Popup è¨Šæ¯è™•ç†å™¨
      this.messageHandlers.set(MESSAGE_TYPES.POPUP_TO_BACKGROUND, async (message, context) => {
        const { sessionId } = context

        this.logger.log(`ðŸŽ›ï¸ è™•ç† Popup è¨Šæ¯: ${message.type || 'unknown'} (Session ${sessionId})`)

        // æ ¹æ“šè¨Šæ¯é¡žåž‹è™•ç†
        switch (message.type) {
          case MESSAGE_TYPES.POPUP_SESSION_START:
            return await this.handlePopupSessionStart(message, context)

          case MESSAGE_TYPES.POPUP_STATUS_REQUEST:
            return await this.handlePopupStatusRequest(message, context)

          case MESSAGE_TYPES.POPUP_DATA_REQUEST:
            return await this.handlePopupDataRequest(message, context)

          case MESSAGE_TYPES.POPUP_OPERATION_REQUEST:
            return await this.handlePopupOperationRequest(message, context)

          case MESSAGE_TYPES.POPUP_SESSION_END:
            return await this.handlePopupSessionEnd(message, context)

          default:
            return await this.handleGenericPopupMessage(message, context)
        }
      })

      // å¥åº·æª¢æŸ¥è¨Šæ¯è™•ç†å™¨
      this.messageHandlers.set(MESSAGE_TYPES.HEALTH_CHECK, async (message, context) => {
        return {
          success: true,
          status: 'healthy',
          timestamp: Date.now(),
          service: 'MessageRoutingService'
        }
      })

      // Ping è¨Šæ¯è™•ç†å™¨
      this.messageHandlers.set(MESSAGE_TYPES.PING, async (message, context) => {
        return {
          success: true,
          pong: true,
          timestamp: Date.now()
        }
      })

      this.logger.log(`ðŸ”§ åˆå§‹åŒ–äº† ${this.messageHandlers.size} å€‹è¨Šæ¯è™•ç†å™¨`)
    } catch (error) {
      this.logger.error('âŒ åˆå§‹åŒ–è¨Šæ¯è™•ç†å™¨å¤±æ•—:', error)
      throw error
    }
  }

  /**
   * åˆå§‹åŒ–è¨Šæ¯è½‰æ›å™¨
   */
  async initializeMessageTransformers () {
    try {
      // æ¨™æº–åŒ–è¨Šæ¯è½‰æ›å™¨
      this.messageTransformers.set('standardize', (message, context) => {
        return {
          ...message,
          timestamp: message.timestamp || Date.now(),
          source: context.source || MESSAGE_SOURCES.UNKNOWN,
          id: message.id || this.generateMessageId(),
          version: '1.0'
        }
      })

      // äº‹ä»¶è½‰æ›å™¨
      this.messageTransformers.set('event_forward', (message, context) => {
        if (message.type === MESSAGE_TYPES.CONTENT_EVENT_FORWARD) {
          return {
            type: message.eventType,
            data: {
              ...message.eventData,
              tabId: context.tabId,
              forwardedFrom: 'content_script',
              originalMessage: message
            },
            timestamp: message.timestamp,
            source: context.source
          }
        }

        return message
      })

      // å›žæ‡‰æ ¼å¼è½‰æ›å™¨
      this.messageTransformers.set('response_format', (response, context) => {
        return {
          success: response.success !== false,
          data: response.data || response,
          timestamp: Date.now(),
          source: 'background',
          requestId: context.requestId
        }
      })

      this.logger.log(`ðŸ”§ åˆå§‹åŒ–äº† ${this.messageTransformers.size} å€‹è¨Šæ¯è½‰æ›å™¨`)
    } catch (error) {
      this.logger.error('âŒ åˆå§‹åŒ–è¨Šæ¯è½‰æ›å™¨å¤±æ•—:', error)
      throw error
    }
  }

  /**
   * åˆå§‹åŒ–è·¯ç”±è¦å‰‡
   */
  async initializeRoutingRules () {
    try {
      // Content Script è·¯ç”±è¦å‰‡
      this.routingRules.set(MESSAGE_SOURCES.CONTENT_SCRIPT, {
        priority: EVENT_PRIORITIES.NORMAL,
        validator: 'content_script',
        transformers: ['standardize', 'event_forward'],
        timeout: TIMEOUTS.DEFAULT_MESSAGE_TIMEOUT,
        retryCount: 2
      })

      // Popup è·¯ç”±è¦å‰‡
      this.routingRules.set(MESSAGE_SOURCES.POPUP, {
        priority: EVENT_PRIORITIES.HIGH,
        validator: 'popup',
        transformers: ['standardize'],
        timeout: TIMEOUTS.DEFAULT_MESSAGE_TIMEOUT / 2, // Popup éœ€è¦æ›´å¿«å›žæ‡‰
        retryCount: 1
      })

      // ç³»çµ±å…§éƒ¨è¨Šæ¯è·¯ç”±è¦å‰‡
      this.routingRules.set(MESSAGE_SOURCES.BACKGROUND, {
        priority: EVENT_PRIORITIES.URGENT,
        validator: 'basic',
        transformers: ['standardize'],
        timeout: TIMEOUTS.DEFAULT_MESSAGE_TIMEOUT / 4,
        retryCount: 0
      })

      this.logger.log(`ðŸ”§ åˆå§‹åŒ–äº† ${this.routingRules.size} å€‹è·¯ç”±è¦å‰‡`)
    } catch (error) {
      this.logger.error('âŒ åˆå§‹åŒ–è·¯ç”±è¦å‰‡å¤±æ•—:', error)
      throw error
    }
  }

  /**
   * è·¯ç”±è¨Šæ¯
   */
  async routeMessage (message, context) {
    const startTime = Date.now()
    this.stats.messagesRouted++

    try {
      // ç²å–è·¯ç”±è¦å‰‡
      const routingRule = this.routingRules.get(context.source) ||
                         this.routingRules.get(MESSAGE_SOURCES.UNKNOWN)

      // é©—è­‰è¨Šæ¯
      if (this.validationService) {
        const validation = await this.validationService.validateMessage(message, routingRule.validator)
        if (!validation.valid) {
          this.stats.routingErrors++
          return {
            success: false,
            error: 'Message validation failed',
            details: validation.errors
          }
        }
      }

      // è½‰æ›è¨Šæ¯
      let transformedMessage = message
      for (const transformerName of routingRule.transformers || []) {
        const transformer = this.messageTransformers.get(transformerName)
        if (transformer) {
          transformedMessage = transformer(transformedMessage, context)
          this.stats.transformationsApplied++
        }
      }

      // æŸ¥æ‰¾è¨Šæ¯è™•ç†å™¨
      const handler = this.messageHandlers.get(transformedMessage.type) ||
                     this.messageHandlers.get('default')

      if (!handler) {
        this.stats.routingErrors++
        return {
          success: false,
          error: 'No handler found for message type',
          messageType: transformedMessage.type
        }
      }

      // åŸ·è¡Œè™•ç†å™¨
      const response = await handler(transformedMessage, context)
      this.stats.handlersExecuted++

      // è½‰æ›å›žæ‡‰
      const transformedResponse = this.messageTransformers.get('response_format')(response, context)

      // æ›´æ–°æŒ‡æ¨™
      this.updateRouteTimeMetrics(startTime)

      return transformedResponse
    } catch (error) {
      this.logger.error('âŒ è·¯ç”±è¨Šæ¯å¤±æ•—:', error)
      this.stats.routingErrors++

      return {
        success: false,
        error: error.message,
        timestamp: Date.now()
      }
    }
  }

  /**
   * è™•ç†è¨Šæ¯
   */
  async handleMessage (data) {
    const { message, source, context } = data

    // æ·»åŠ åˆ°è™•ç†ä½‡åˆ—å¦‚æžœæœ‰ä½‡åˆ—æœå‹™
    if (this.queueService) {
      await this.queueService.addToQueue(message, source, context, 'inbound')
    } else {
      // ç›´æŽ¥è·¯ç”±
      return await this.routeMessage(message, { ...context, source })
    }
  }

  /**
   * è™•ç† Content Script è¨Šæ¯
   */
  async handleContentMessage (data) {
    const { message, tabId, sender } = data

    const context = {
      source: MESSAGE_SOURCES.CONTENT_SCRIPT,
      tabId,
      sender,
      requestId: message.id || this.generateMessageId()
    }

    return await this.routeMessage(message, context)
  }

  /**
   * è™•ç† Popup è¨Šæ¯
   */
  async handlePopupMessage (data) {
    const { message, sender } = data

    const context = {
      source: MESSAGE_SOURCES.POPUP,
      sender,
      sessionId: message.sessionId || this.generateSessionId(),
      requestId: message.id || this.generateMessageId()
    }

    return await this.routeMessage(message, context)
  }

  /**
   * è™•ç† Content Script å°±ç·’
   */
  async handleContentScriptReady (message, context) {
    const { tabId } = context

    // è§¸ç™¼ Content Script å°±ç·’äº‹ä»¶
    if (this.eventBus) {
      await this.eventBus.emit('CONTENT.SCRIPT.READY', {
        tabId,
        scriptInfo: message.scriptInfo,
        timestamp: Date.now()
      })
    }

    return {
      success: true,
      message: 'Content Script registered successfully',
      timestamp: Date.now()
    }
  }

  /**
   * è™•ç†äº‹ä»¶è½‰ç™¼
   */
  async handleContentEventForward (message, context) {
    try {
      // è½‰ç™¼äº‹ä»¶åˆ° EventBus
      if (this.eventBus) {
        await this.eventBus.emit(message.eventType, {
          ...message.eventData,
          tabId: context.tabId,
          source: 'content_script'
        })
      }

      return {
        success: true,
        message: 'Event forwarded successfully'
      }
    } catch (error) {
      return {
        success: false,
        error: error.message
      }
    }
  }

  /**
   * è™•ç† Popup æœƒè©±é–‹å§‹
   */
  async handlePopupSessionStart (message, context) {
    try {
      if (this.sessionService) {
        const sessionResult = await this.sessionService.startSession(context.sessionId, context)
        return sessionResult
      }

      return {
        success: true,
        sessionId: context.sessionId,
        message: 'Session established successfully'
      }
    } catch (error) {
      return {
        success: false,
        error: error.message
      }
    }
  }

  /**
   * è™•ç†ç‹€æ…‹æ›´æ–°
   */
  async handleContentStatusUpdate (message, context) {
    // æ›´æ–°é€£æŽ¥ç‹€æ…‹
    if (this.connectionService) {
      this.connectionService.updateConnectionState(
        context.tabId,
        message.status,
        context.source
      )
    }

    return {
      success: true,
      message: 'Status updated successfully'
    }
  }

  /**
   * è™•ç† Content Script éŒ¯èª¤
   */
  async handleContentScriptError (message, context) {
    this.logger.error(`Content Script éŒ¯èª¤ (Tab ${context.tabId}):`, message.error)

    // è§¸ç™¼éŒ¯èª¤äº‹ä»¶
    if (this.eventBus) {
      await this.eventBus.emit('CONTENT.SCRIPT.ERROR', {
        tabId: context.tabId,
        error: message.error,
        timestamp: Date.now()
      })
    }

    return {
      success: true,
      message: 'Error reported successfully'
    }
  }

  /**
   * è™•ç†é€šç”¨è¨Šæ¯
   */
  async handleGenericContentMessage (message, context) {
    this.logger.log(`è™•ç†é€šç”¨ Content Script è¨Šæ¯: ${message.type}`)

    return {
      success: true,
      message: 'Generic message processed',
      type: message.type
    }
  }

  /**
   * è™•ç†é€šç”¨ Popup è¨Šæ¯
   */
  async handleGenericPopupMessage (message, context) {
    this.logger.log(`è™•ç†é€šç”¨ Popup è¨Šæ¯: ${message.type}`)

    return {
      success: true,
      message: 'Generic popup message processed',
      type: message.type
    }
  }

  /**
   * è™•ç†ç‹€æ…‹è«‹æ±‚
   */
  async handlePopupStatusRequest (message, context) {
    return {
      success: true,
      status: this.getStatus(),
      timestamp: Date.now()
    }
  }

  /**
   * è™•ç†è³‡æ–™è«‹æ±‚
   */
  async handlePopupDataRequest (message, context) {
    // é€™è£¡æ‡‰è©²å§”è¨—çµ¦è³‡æ–™æœå‹™è™•ç†
    return {
      success: true,
      message: 'Data request handled',
      requestType: message.requestType
    }
  }

  /**
   * è™•ç†æ“ä½œè«‹æ±‚
   */
  async handlePopupOperationRequest (message, context) {
    // é€™è£¡æ‡‰è©²å§”è¨—çµ¦æ“ä½œæœå‹™è™•ç†
    return {
      success: true,
      message: 'Operation request handled',
      operation: message.operation
    }
  }

  /**
   * è™•ç†æœƒè©±çµæŸ
   */
  async handlePopupSessionEnd (message, context) {
    if (this.sessionService) {
      await this.sessionService.endSession(context.sessionId)
    }

    return {
      success: true,
      message: 'Session ended successfully'
    }
  }

  /**
   * è¨»å†Šäº‹ä»¶ç›£è½å™¨
   */
  async registerEventListeners () {
    // è·¯ç”±æœå‹™é€šå¸¸ä¸ç›´æŽ¥ç›£è½äº‹ä»¶ï¼Œè€Œæ˜¯è¢«å…¶ä»–æœå‹™èª¿ç”¨
    this.logger.log('âœ… è¨Šæ¯è·¯ç”±æœå‹™äº‹ä»¶ç›£è½å™¨è¨»å†Šå®Œæˆ')
  }

  /**
   * å–æ¶ˆè¨»å†Šäº‹ä»¶ç›£è½å™¨
   */
  async unregisterEventListeners () {
    this.registeredListeners.clear()
    this.logger.log('âœ… è¨Šæ¯è·¯ç”±æœå‹™äº‹ä»¶ç›£è½å™¨å·²å–æ¶ˆè¨»å†Š')
  }

  /**
   * è¨­å®šä¾è³´æœå‹™
   */
  setValidationService (service) {
    this.validationService = service
  }

  setQueueService (service) {
    this.queueService = service
  }

  setSessionService (service) {
    this.sessionService = service
  }

  setConnectionService (service) {
    this.connectionService = service
  }

  /**
   * æ›´æ–°è·¯ç”±æ™‚é–“æŒ‡æ¨™
   */
  updateRouteTimeMetrics (startTime) {
    const routeTime = Date.now() - startTime
    const totalMessages = this.stats.messagesRouted

    this.stats.averageRouteTime =
      (this.stats.averageRouteTime * (totalMessages - 1) + routeTime) / totalMessages
  }

  /**
   * ç”Ÿæˆè¨Šæ¯ ID
   */
  generateMessageId () {
    return `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  }

  /**
   * ç”Ÿæˆæœƒè©± ID
   */
  generateSessionId () {
    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  }

  /**
   * ç²å–æœå‹™ç‹€æ…‹
   */
  getStatus () {
    return {
      initialized: this.state.initialized,
      active: this.state.active,
      stats: { ...this.stats },
      handlers: this.messageHandlers.size,
      transformers: this.messageTransformers.size,
      rules: this.routingRules.size
    }
  }

  /**
   * ç²å–å¥åº·ç‹€æ…‹
   */
  getHealthStatus () {
    const isHealthy = this.state.initialized &&
                     this.state.active &&
                     this.messageHandlers.size > 0

    return {
      service: 'MessageRoutingService',
      healthy: isHealthy,
      status: this.state.active ? 'active' : 'inactive',
      metrics: {
        messagesRouted: this.stats.messagesRouted,
        routingErrors: this.stats.routingErrors,
        successRate: this.stats.messagesRouted > 0
          ? (1 - this.stats.routingErrors / this.stats.messagesRouted) * 100
          : 100
      }
    }
  }

  /**
   * ç²å–è·¯ç”±æŒ‡æ¨™
   */
  getMetrics () {
    return {
      ...this.stats,
      successRate: this.stats.messagesRouted > 0
        ? (1 - this.stats.routingErrors / this.stats.messagesRouted) * 100
        : 100
    }
  }
}

module.exports = MessageRoutingService
