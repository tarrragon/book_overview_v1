# CLAUDE.md

本文件為 Claude Code (claude.ai/code) 在此專案中的開發指導規範。

## 🚨 任何行動前的強制檢查清單

**💡 記憶口訣**: 測試先行，問題必解，架構為王，品質不妥協

### 三大不可違反的鐵律

1. **測試通過率鐵律**  
   **100% 通過率是最低標準**
   - 任何測試失敗 = 立即修正，其他工作全部暫停
   - 不存在「夠好的通過率」，只有 100% 或失敗

2. **永不放棄鐵律**  
   **沒有無法解決的問題**
   - 遇到複雜問題 → 設計師分析 → 分解 → 逐一解決
   - 禁用詞彙：「太複雜」「暫時」「跳過」「之後再改」

3. **架構債務零容忍鐵律**  
   **架構問題 = 立即停止功能開發**
   - 發現設計缺陷 → 立即修正 → 繼續開發
   - 修復成本隨時間指數增長，立即處理是唯一選擇

### ⚡ 30秒快速檢查
- [ ] 測試通過率是否 100%？不是則立即修正
- [ ] 是否想跳過/暫緩任何問題？違反永不放棄原則
- [ ] 是否發現架構債務？立即停止功能開發優先修正

### 🔍 詳細執行指導
- [🚨 違規警報與預防](docs/guidelines/violation-prevention.md)
- [📋 關鍵情境決策流程](docs/guidelines/decision-workflows.md)  
- [🔍 自我監控與糾錯機制](docs/guidelines/self-monitoring.md)

### 📚 章節快速導覽
**日常開發必讀**：
- [🤝 TDD 協作開發流程](#-tdd-協作開發流程設計師導向的團隊協作) - 四階段開發流程
- [📚 專案文件責任明確區分](#-專案文件責任明確區分) - 文件寫作規範
- [🤖 Agent 協作規範](#-agent-協作規範) - Sub-agent 使用指南

**專案特定規範**：
- [📦 Chrome Extension 與專案規範](#-chrome-extension-與專案規範) - 平台特定要求
- [🎭 事件驅動架構規範](#-事件驅動架構規範) - 架構模式指引

---

## 📖 完整開發流程指引

### 文件先行策略與敏捷開發

#### 文件驅動開發流程

**所有任務執行都必須遵循以下完整執行流程，確保工作品質和完成度**

1. **問題理解階段**: 完整理解任務需求和技術限制，識別技術要素和依賴關係
2. **方案設計階段**: 設計解決方案架構，確定實作優先順序，建立驗證檢查點
3. **文件撰寫階段**: 撰寫設計文件、API 接口定義、架構決策記錄（ADR）
4. **執行實作階段**: 按照設計文件執行，記錄決策和問題，**嚴禁**無設計文件編碼
5. **完善優化階段**: 完善技術實作細節，處理邊界情況和錯誤處理

#### 敏捷機制核心要求

- **任務設計與分派**: 預設目標為「最小、最快可交付」（MVP）
- **階段性交付**: 將大型重構分解成小型、可驗證的交付階段
- **高頻工作日誌更新**: 工作日誌作為站立會議，高頻更新進度、阻礙與決策
- **程式碼協作標註**: 使用 `//todo:` 標註協作溝通和改善方向
- **文件同步更新**: 程式碼變更後立即更新相關文件，包括工作日誌和版本記錄

#### 技術文件寫作規範

**務實記錄風格**：使用具體數據和客觀描述，避免誇大用語
- ✅ 功能性描述："實作了 5層驗證策略"
- ✅ 量化效果："測試通過率從 92% 提升到 100%"  
- ❌ 誇飾用語："完美解決"、"卓越表現"、"企業級"

## 🤝 TDD 協作開發流程：設計師導向的團隊協作

**TDD 不只是開發方法，更是一個完整的團隊協作流程**，包含：
- 🎨 **功能設計師**: 負責功能規劃和需求分析
- 🧪 **測試工程師**: 負責測試設計和測試案例撰寫
- 💻 **實作工程師**: 負責功能實作和測試通過
- 🏗️ **重構設計師**: 負責程式碼品質改善和架構優化

### 🎯 TDD 協作核心原則

1. **工作日誌驅動**: 每個階段都有對應的工作日誌，記錄思考過程和交接資訊
2. **角色明確分工**: 每個角色有明確的職責和交付物
3. **文件化交接**: 透過工作日誌進行角色間的知識傳遞
4. **測試先行**: 絕對不在沒有測試的情況下寫程式碼
5. **品質不妥協**: 每個階段都有品質門檻，不達標不進入下一階段

### 🔄 TDD 完整協作流程

TDD 協作流程分為四個明確的階段，每個階段都有專門的角色負責：

#### 🎨 Phase 1: 功能設計師 - 需求分析與功能規劃

**負責角色**: 功能設計師  
**目標**: 建立清楚的功能需求和設計規範，為後續測試和實作奠定基礎

**必須建立新工作日誌**: `docs/work-logs/vX.X.X-feature-design.md`

**工作日誌必須包含內容**:

```markdown
## 功能設計規劃

### 功能需求分析：
- 這個功能要解決什麼問題？
- 使用者的具體使用場景是什麼？
- 功能的核心價值和期望效果是什麼？

### 功能規格設計：
- 功能的輸入是什麼？（參數、資料、使用者互動）
- 功能的輸出是什麼？（回傳值、副作用、使用者回饋）
- 正常流程的步驟是什麼？
- 異常情況的處理方式是什麼？

### 邊界條件分析：
- 極端輸入情況（空值、超大值、無效值）
- 系統限制和約束條件
- 錯誤情況和例外狀況

### API/介面設計：
- 函數簽名或 API 接口定義
- 資料結構和類型定義
- 與其他模組的互動方式

### 驗收標準：
- 功能正確性的驗證方法
- 效能要求和品質標準
- 使用者體驗的期望標準
```

**交接給測試工程師**:
- [ ] 功能需求清楚且具體
- [ ] API 介面定義完整
- [ ] 邊界條件和異常情況已識別
- [ ] 驗收標準明確可驗證

#### 🔍 Phase 1 專家審查：Linux設計品質檢查

**觸發時機**: 功能設計師完成設計規劃後，測試工程師開始前
**負責專家**: linux (Linus Torvalds 程式碼品質專家)

**Linux專家審查重點**:
- **實際問題驗證**: "Is this a real problem or imaginary?" - 拒絕過度設計
- **簡化機會識別**: "Is there a simpler way?" - 尋找最簡解決方案  
- **複雜度評估**: 設計是否超過必要複雜度，能否消除特殊情況
- **Good Taste評分**: 設計是否展現技術直覺和經驗積累

**Linux審查輸出標準**:
```markdown
## Linux專家設計審查 (Phase 1)

**Taste Score**: Good taste / Acceptable / Garbage

**核心判斷**: Worth doing [reason] / Not worth doing [reason]

**關鍵洞察**:
- 資料結構: [最關鍵的資料關係]
- 複雜度: [可以消除的複雜度]
- 風險點: [最大的破壞性風險]

**改善建議**:
- [具體的設計簡化建議]
- [特殊情況消除方法]
- [資料結構優化方向]
```

**審查通過標準**:
- [ ] 設計解決實際存在的問題
- [ ] 複雜度合理且必要
- [ ] 沒有可消除的特殊情況
- [ ] 符合"Good Taste"原則

#### 🧠 Phase 1 知識捕獲：Memory Network Builder

**觸發條件**: Linux專家審查評定為"Good Taste"或發現重要設計洞察時
**負責Agent**: memory-network-builder

**自動觸發場景**:
- Linux專家評定為"Good Taste"的設計模式
- 發現可消除特殊情況的資料結構設計
- 重要的架構決策和設計原則
- 複雜度簡化的具體方法

**Memory捕獲範例**:
```markdown
Memory類型: decision
標題範例: "使用事件驅動架構消除模組間直接依賴"
觸發原因: Linux專家識別出消除特殊情況的優秀設計
連結: 基於 [[SOLID原則]] → 導致 [[模組解耦策略]]
```

**知識捕獲標準**:
- [ ] 捕獲具體的設計決策和原理  
- [ ] 建立與相關概念的連結
- [ ] 記錄決策的前因後果
- [ ] 使用結論導向的標題格式

#### 🧪 Phase 2: 測試工程師 - 測試案例設計與實作

**負責角色**: 測試工程師  
**目標**: 根據功能設計，設計並實作完整的測試案例

**在原工作日誌中新增測試設計章節**:

```markdown
## 測試案例設計

### 測試策略規劃：
基於功能設計師的需求分析，設計以下測試策略：
- 單元測試：測試核心邏輯和邊界條件
- 整合測試：測試與其他模組的互動
- 端對端測試：測試完整的使用者流程

### 具體測試案例：

#### 正常流程測試：
- [測試案例1]: Given [前置條件], When [執行動作], Then [預期結果]
- [測試案例2]: Given [前置條件], When [執行動作], Then [預期結果]

#### 邊界條件測試：
- [邊界測試1]: Given [邊界情況], When [執行動作], Then [預期結果]
- [邊界測試2]: Given [極端輸入], When [執行動作], Then [預期結果]

#### 異常情況測試：
- [異常測試1]: Given [錯誤條件], When [執行動作], Then [預期錯誤處理]
- [異常測試2]: Given [無效輸入], When [執行動作], Then [預期錯誤回應]

### 測試環境設置：
- Mock 物件設計：[列出需要的 Mock]
- 測試資料準備：[列出測試所需資料]
- 測試清理策略：[說明測試後的清理方法]

### 測試實作記錄：
- 實作的測試檔案：[列出建立的測試檔案]
- 測試覆蓋的功能點：[記錄測試涵蓋範圍]
- 發現的設計問題：[記錄在設計測試過程中發現的問題]
```

**實際執行工作**:
1. **撰寫失敗的測試**: 根據設計實作具體的測試程式碼
2. **驗證測試失敗**: 確保測試在沒有實作時會失敗
3. **測試品質檢查**: 確保測試程式碼品質和覆蓋率

**交接給實作工程師**:
- [ ] 所有測試案例已實作為程式碼
- [ ] 測試在沒有功能實作時會失敗（紅燈狀態）
- [ ] 測試覆蓋率達到設計要求
- [ ] 測試程式碼品質良好且可維護

#### 🔍 Phase 2 專家審查：雙專家測試品質檢查

**觸發時機**: 測試工程師完成測試案例實作後，實作規劃師開始前
**負責專家**: linux + john-carmack (雙專家聯合審查)

**Linux專家測試審查重點**:
- **測試複雜度評估**: 測試是否過度複雜，能否簡化
- **邊界條件充分性**: 是否測試了所有實際可能的邊界情況
- **真實問題覆蓋**: 測試是否針對實際存在的問題，避免理論測試

**John Carmack效能測試審查重點**:
- **熱路徑測試覆蓋**: 效能關鍵路徑是否有充分測試
- **確定性行為驗證**: 測試是否驗證可預測的行為模式
- **最壞情況測試**: 是否包含最壞情況和極端負載的測試場景
- **狀態管理測試**: 副作用最小化和純函數測試覆蓋

**雙專家審查輸出標準**:
```markdown
## 雙專家測試審查 (Phase 2)

### Linux測試品質審查
**Taste Score**: Good taste / Acceptable / Garbage
**致命問題**: [如有，直接指出最差的部分]
**改善方向**: 
- [消除這個特殊情況]
- [這些10行可以變成3行]

### John Carmack效能測試審查  
**熱路徑覆蓋**: Comprehensive / Adequate / Insufficient
**確定性驗證**: Strong / Moderate / Weak
**關鍵發現**:
- [效能關鍵路徑識別]
- [狀態管理模式評估]
- [最壞情況處理]

### 聯合建議
- [測試架構改善建議]
- [效能測試加強方向]
- [測試複雜度簡化方法]
```

**雙專家審查通過標準**:
- [ ] Linux: 測試複雜度合理，覆蓋實際問題
- [ ] John Carmack: 效能關鍵路徑測試充分
- [ ] 確定性行為驗證完整
- [ ] 最壞情況測試涵蓋適當

#### 🧠 Phase 2 知識捕獲：Memory Network Builder

**觸發條件**: 雙專家審查發現有效測試策略或測試設計洞察時
**負責Agent**: memory-network-builder

**自動觸發場景**:
- 發現特別有效的邊界條件測試策略
- John Carmack識別的效能測試關鍵點
- Linux認可的測試複雜度控制方法
- 確定性行為驗證的創新方法

**Memory捕獲範例**:
```markdown
Memory類型: learning  
標題範例: "邊界條件測試比正常流程測試更容易暴露設計缺陷"
觸發原因: Linux專家發現測試策略的重要洞察
連結: 基於 [[邊界條件分析]] → 導致 [[測試驅動設計改善]]
```

**雙專家協作捕獲**:
```markdown
Memory類型: concept
標題範例: "熱路徑測試需要最壞情況和平均情況雙重覆蓋"  
觸發原因: John Carmack + Linux 專家聯合發現
連結: 基於 [[確定性系統設計]] → 導致 [[效能測試策略]]
```

**知識捕獲標準**:
- [ ] 記錄有效的測試方法和策略
- [ ] 捕獲專家認可的測試模式
- [ ] 建立測試策略間的知識連結
- [ ] 記錄測試複雜度控制的原則

#### 💻 Phase 3: 實作規劃師 - 實作策略規劃與開發指引

**負責角色**: 實作規劃師  
**目標**: 規劃實作策略，提供主線程完整的開發指引和程式碼範例

**在原工作日誌中新增實作規劃章節**: 包含實作策略設計、詳細實作指引、權宜方案與技術債務、驗證與品質保證
- **實作步驟**: [Step-by-step 具體編碼指引]
- **預期問題與解決方案**: [可能遇到的技術挑戰和建議解法]

#### 第二階段實作指引：
- **目標測試群組**: [下一組要通過的測試]
- **程式碼範例**: [繼續實作的關鍵程式碼]
- **整合策略**: [與前一階段程式碼的整合方法]

### 權宜方案與技術債務：
- **最小可用實作**: [讓測試通過的最簡單方案]
- **//todo: 改善方向**: [標註所有需要後續改善的具體項目]
- **已知限制記錄**: [當前實作的限制和約束條件]
- **重構準備**: [為重構設計師提供的改善建議]

### 驗證與品質保證：
- **測試通過策略**: [如何讓每個測試案例通過的具體方法]
- **程式碼品質檢查**: [Linter 規則遵循、最佳實踐應用]
- **效能考量**: [效能要求和優化建議]
```

**主線程實作責任** (按照規劃執行):
1. **按指引實作功能**: 根據規劃的程式碼範例和步驟進行編碼
2. **驗證測試套件**: 確保 100% 測試通過率
3. **程式碼品質檢查**: 通過 lint 和 build 檢查
4. **記錄實作過程**: 在工作日誌中記錄實際實作結果和遇到的問題

**實作完成標準** (交接給重構設計師):
- [ ] 所有測試 100% 通過
- [ ] 功能按照設計規格和實作規劃正確實作
- [ ] 程式碼品質檢查通過
- [ ] 實作過程完整記錄，包含與規劃的差異和問題解決

#### 🔍 Phase 3 專家審查：John Carmack架構效能檢查

**觸發時機**: 實作規劃師完成實作策略後，主線程實作前 + 主線程實作完成後，重構設計師開始前
**負責專家**: john-carmack (John Carmack 效能系統架構師)

**John Carmack實作架構審查重點**:
- **熱路徑清晰度**: 關鍵執行路徑是否明顯且一致
- **最壞情況優化**: 設計是否針對最壞情況效能，而非平均值
- **控制流程簡化**: 條件分支是否過深，能否扁平化
- **狀態管理純度**: 副作用是否最小化，函數式設計機會
- **架構邊界合理性**: 抽象層次是否適當，避免過度抽象

**John Carmack審查輸出標準**:
```markdown
## John Carmack架構效能審查 (Phase 3)

**熱路徑評估**: Clear / Acceptable / Obfuscated
**確定性設計**: Strong / Moderate / Weak
**控制流程**: Flat / Acceptable / Too Deep

**關鍵發現**:
- 熱路徑識別: [主要執行路徑分析]
- 狀態管理: [副作用和全域狀態評估]
- 控制流程: [條件邏輯簡化機會]
- 架構邊界: [抽象層次合理性]

**效能優化建議**:
- [具體的熱路徑優化方向]
- [狀態管理改善策略]  
- [控制流程扁平化方法]
- [函數式設計機會]

**架構風險點**:
- [效能瓶頸識別]
- [確定性行為風險]
- [複雜度累積點]
```

**John Carmack審查通過標準**:
- [ ] 熱路徑清晰且優化合理
- [ ] 控制流程扁平化充分
- [ ] 狀態管理符合函數式原則  
- [ ] 架構邊界設計合理
- [ ] 確定性行為設計充分

#### 🧠 Phase 3 知識捕獲：Memory Network Builder

**觸發條件**: John Carmack專家審查發現重要效能洞察或架構優化時  
**負責Agent**: memory-network-builder

**自動觸發場景**:
- John Carmack識別的熱路徑優化具體方法
- 狀態管理純度改善的實作技巧
- 控制流程扁平化的具體案例
- 確定性行為設計的關鍵模式
- 實作中發現的效能瓶頸解決方案

**Memory捕獲範例**:
```markdown
Memory類型: implementation
標題範例: "使用Map代替Array查找讓搜尋效能提升10倍"
觸發原因: John Carmack專家發現關鍵效能優化點
連結: 基於 [[熱路徑識別]] → 導致 [[資料結構選擇策略]]
```

**架構模式捕獲**:
```markdown
Memory類型: concept
標題範例: "函數式狀態管理三層架構消除副作用"
觸發原因: John Carmack專家認可的狀態管理模式
連結: 基於 [[純函數設計]] → 導致 [[可預測性系統]]
```

**實作技巧捕獲**:
```markdown
Memory類型: learning
標題範例: "控制流程超過3層巢狀必定存在更簡潔的資料結構設計"
觸發原因: 實作過程驗證了John Carmack的架構原則
連結: 基於 [[複雜度控制]] → 導致 [[資料結構重設計]]
```

**知識捕獲標準**:
- [ ] 記錄具體的效能優化數據和方法
- [ ] 捕獲架構邊界設計的成功模式  
- [ ] 建立實作技巧與理論原則的連結
- [ ] 記錄確定性設計的具體實作方法

#### 🏗️ Phase 4: 重構設計師 - 程式碼品質改善

**負責角色**: 重構設計師  
**目標**: 改善程式碼品質和架構，執行完整的重構方法論

**重要**: 重構設計師必須按照本文件「🧠 TDD 驅動重構方法論」章節的完整流程執行

**工作流程**:
1. **建立重構工作日誌**: 按照重構方法論 Phase 1 要求建立新工作日誌
2. **執行重構**: 按照重構方法論 Phase 2 執行重構並驗證預期
3. **完成重構總結**: 按照重構方法論 Phase 3 完成工作日誌總結

**重構總結工作日誌更新**: 按照「📚 專案文件責任明確區分」章節的工作日誌品質要求進行記錄

**最終交付標準**:
- [ ] 重構方法論完整執行
- [ ] 所有技術債務已解決
- [ ] 程式碼品質達到專案標準
- [ ] 功能完整性確認無損
- [ ] 重構經驗記錄完整

#### 🔍 Phase 4 專家審查：Linux最終品質檢查

**觸發時機**: 重構設計師完成所有重構工作後，TDD循環完成前
**負責專家**: linux (Linus Torvalds 程式碼品質專家)

**Linux最終品質審查重點**:
- **重構效果驗證**: 重構是否真正簡化了程式碼，而非增加複雜度
- **Good Taste最終評估**: 最終程式碼是否展現"好品味"和技術直覺
- **複雜度消除確認**: 是否成功消除了不必要的複雜度和特殊情況
- **破壞性檢查**: "Never break userspace" - 確保向後相容性
- **實用主義驗證**: 程式碼是否服務於現實需求，而非理論完美

**Linux最終審查輸出標準**:
```markdown
## Linux最終品質審查 (Phase 4)

**最終Taste Score**: Good taste / Acceptable / Garbage

**重構成效評估**:
- 複雜度變化: [重構前後複雜度對比]
- 特殊情況: [消除的特殊情況數量]
- 程式碼行數: [有意義的程式碼精簡]

**Good Taste評估**:
- 資料結構設計: [是否展現對資料結構的深度理解]
- 算法選擇: [是否選擇了最直觀的解決方法]
- 邊界處理: [特殊情況是否被優雅消除]

**向後相容性檢查**:
- [ ] 沒有破壞現有API
- [ ] 沒有改變外部行為
- [ ] 升級路徑清晰

**最終建議**:
- [如果是Good taste: 讚揚具體的優秀設計]
- [如果是Acceptable: 指出還可改善的地方]
- [如果是Garbage: 要求重新設計的具體理由]
```

**Linux最終審查通過標準**:
- [ ] 程式碼展現"Good Taste"或至少"Acceptable"
- [ ] 複雜度確實降低，沒有增加不必要複雜性
- [ ] 向後相容性完全保持
- [ ] 解決方案務實且直接
- [ ] 沒有為了理論完美而犧牲實用性

#### 🧠 Phase 4 知識捕獲：Memory Network Builder

**觸發條件**: Linux最終審查發現"Good Taste"重構模式或重要品質改善時
**負責Agent**: memory-network-builder

**自動觸發場景**:
- Linux專家認證的"Good Taste"重構模式
- 成功消除特殊情況的具體重構方法
- 複雜度大幅降低的重構案例
- 向後相容性維持的重構技巧
- 實用主義導向的架構改善

**重構模式捕獲**:
```markdown
Memory類型: concept
標題範例: "消除if-else特殊情況的三種資料結構重設計模式"
觸發原因: Linux專家認證的"Good Taste"重構方法
連結: 基於 [[特殊情況識別]] → 導致 [[資料結構優化]]
```

**品質改善捕獲**:
```markdown
Memory類型: learning
標題範例: "重構後程式碼行數減少60%且可讀性提升的關鍵因素"
觸發原因: Linux專家驗證的重構成效
連結: 基於 [[複雜度分析]] → 導致 [[程式碼品質提升]]
```

**架構債務解決捕獲**:
```markdown
Memory類型: implementation
標題範例: "模組循環依賴透過事件中介者模式徹底解除"
觸發原因: 重構過程解決關鍵架構債務
連結: 基於 [[依賴解耦]] → 導致 [[模組化架構]]
```

**知識捕獲標準**:
- [ ] 記錄成功的重構模式和方法
- [ ] 捕獲複雜度簡化的具體技巧
- [ ] 建立重構前後的效果對比數據
- [ ] 記錄向後相容性維持的策略
- [ ] 捕獲"Good Taste"的具體體現方式

### 🤝 TDD 協作流程總結

#### 📋 完整協作檢查清單

**階段完成驗證**:
- [ ] Phase 1: 功能設計師完成需求分析和功能規劃
  - [ ] Linux專家設計品質審查通過
  - [ ] 🧠 Memory Network Builder 知識捕獲完成 (設計決策和原則)
- [ ] Phase 2: 測試工程師完成測試案例設計和實作  
  - [ ] Linux + John Carmack雙專家測試品質審查通過
  - [ ] 🧠 Memory Network Builder 知識捕獲完成 (測試策略和洞察)
- [ ] Phase 3: 實作工程師完成功能實作和測試通過
  - [ ] John Carmack架構效能審查通過
  - [ ] 🧠 Memory Network Builder 知識捕獲完成 (實作技巧和效能優化)
- [ ] Phase 4: 重構設計師完成程式碼品質改善
  - [ ] Linux最終品質審查通過
  - [ ] 🧠 Memory Network Builder 知識捕獲完成 (重構模式和品質改善)

**工作日誌品質**: 必須符合「📚 專案文件責任明確區分」章節的文件品質標準

**最終交付標準**:
- [ ] 所有測試 100% 通過
- [ ] 程式碼品質達到專案標準
- [ ] 功能完全符合原始設計規格
- [ ] 沒有未解決的技術債務
- [ ] 完整的開發過程可追蹤
- [ ] **所有專家審查通過** (Linux設計審查 + 雙專家測試審查 + John Carmack架構審查 + Linux最終審查)
- [ ] **專家審查建議全部實施** 或有明確原因記錄為何不實施
- [ ] **🧠 知識網路完整建立**: 所有重要洞察已捕獲為Memory並建立適當連結
- [ ] **Memory品質驗證**: 所有Memory標題結論導向，內容原子化，連結關係明確

#### 🔍 TODO 狀態驗證機制 (v0.9.24 新增預防措施)

**背景**: 為防止專案文件與實際狀況不一致的問題 (如 v0.9.24 發現的 Popup 狀態不一致問題)，建立強制性的狀態驗證機制。

**🚨 每個 TDD 循環完成後的必要檢查**:

**文件更新檢查**: 按照「📚 專案文件責任明確區分」章節的要求執行：
- [ ] **工作日誌更新**: 符合工作日誌品質標準
- [ ] **TODO.md狀態同步**: 符合TODO.md品質標準
- [ ] **CHANGELOG.md更新**: 符合CHANGELOG.md品質標準

**3. 實際狀況交叉驗證**:
- [ ] **測試檔案確認**: 聲稱完成的功能必須有對應的測試檔案
- [ ] **程式碼實作確認**: 檢查實際程式碼是否支持 TODO 中的功能聲明
- [ ] **版本號一致性**: 確保各檔案中的版本號保持一致
- [ ] **架構文件同步**: 更新相關的架構文件和說明

**4. 版本發布前的全面驗證**:
- [ ] **批次狀態檢查**: 檢查所有聲稱完成的項目是否有實際實作
- [ ] **測試覆蓋驗證**: 確認測試覆蓋率聲明與實際測試結果一致
- [ ] **工作日誌完整性**: 驗證重要功能都有對應的開發記錄
- [ ] **CHANGELOG 同步**: 確保版本變更記錄反映真實的功能變更

**🛠️ 推薦的驗證工具**:
```bash
# 建議建立的驗證腳本概念
verify_project_consistency() {
  echo "🔍 檢查 TODO 狀態一致性..."
  # 檢查 TODO 中聲稱完成的功能是否有對應測試檔案
  # 檢查版本號在 TODO.md, CHANGELOG.md, package.json 中是否一致
  # 驗證工作日誌的完整性
}
```

**📋 問題發現時的標準處理流程**:
1. **立即停止當前工作**: 優先處理狀態不一致問題
2. **系統性調查**: 使用程式碼分析、測試檢查、歷史記錄搜尋等方法
3. **實際狀況導向修正**: 基於具體實作情況進行文件修正
4. **建立預防機制**: 設計防止類似問題再次發生的具體措施
5. **完整記錄過程**: 建立工作日誌記錄發現和修正的完整過程

---

### 🧠 TDD 驅動重構方法論：預期管理與工作日誌為核心

#### 🎯 重構核心原則：預期管理與驗證

**重構是預期管理與驗證的思考框架，不是執行步驟**：
- **預期管理**: 重構前先預期哪些測試會通過、哪些會失敗、為什麼失敗
- **驗證預期**: 執行重構後檢查結果是否符合預期
- **預期偏差處理**: 若結果不符合預期，分析原因並調整計劃
- **工作日誌記錄**: 記錄整個思考和驗證過程，確保知識傳承和協作透明

#### 📝 Phase 1: 重構計劃與工作日誌建立

**必須建立新工作日誌的原因**: 確保重構思考過程可追蹤、協作透明、知識不流失

**工作日誌必須回答的問題**:

1. **🎯 重構動機與目標**:
   ```markdown
   ## 為什麼要重構？
   - 當前架構的具體問題是什麼？
   - 重構後期望達成的狀態是什麼？
   - 這個重構如何解決核心問題？
   ```

2. **🔍 影響範圍分析**:
   ```markdown
   ## 預期影響的程式碼和行為
   - 哪些檔案會被修改？
   - 哪些功能的行為會改變？
   - 哪些 API 或介面會受影響？
   ```

3. **🧪 測試預期管理**:
   ```markdown
   ## 測試結果預期
   ### 預期會通過的測試：
   - [列出具體測試檔案和測試名稱]
   - 為什麼這些測試應該繼續通過？
   
   ### 預期會失敗的測試：
   - [列出具體測試檔案和測試名稱]
   - 為什麼這些測試會失敗？失敗的原因是什麼？
   - 怎麼修正這些失敗？
   
   ### 不確定的測試：
   - [可能會受影響的測試]
   - 為什麼不確定？需要特別注意什麼？
   ```

4. **📊 成功標準設定**:
   ```markdown
   ## 重構成功的標準
   - 測試結果符合預期的標準是什麼？
   - 程式碼品質的要求是什麼？
   - 效能或使用者體驗的標準是什麼？
   ```

#### 🚀 Phase 2: 重構執行與預期驗證

**執行目的**: 驗證重構計劃中的預期是否正確，不是單純的執行步驟

**Step 1: 執行重構**
```bash
# 按照計劃執行重構
# [這裡是具體的重構動作]
```

**Step 2: 驗證測試結果**
```bash
npm test                # 執行所有測試
npm run test:unit       # 單元測試
npm run test:integration # 整合測試
```

**Step 3: 對比預期與實際結果**

**情境 A: 結果符合預期 ✅**
- 預期通過的測試都通過了
- 預期失敗的測試都失敗了，且失敗原因符合預期
- 不確定的測試結果都在可接受範圍內

**對應行動**: 更新工作日誌
```markdown
**情境 A: 結果符合預期 ✅**
- 預期通過的測試都通過了
- 預期失敗的測試都失敗了，且失敗原因符合預期
- 不確定的測試結果都在可接受範圍內

**對應行動**: 更新工作日誌
```markdown
## 重構結果驗證 - 符合預期 ✅
### 測試結果記錄：
- [具體記錄測試結果]
### 重構過程發現：
- [記錄重構過程中的發現和決策]
### 下一步：
- 重構目標已達成，繼續後續優化
```

**情境 B: 結果不符合預期 ❌**
- 預期通過的測試失敗了
- 預期失敗的測試通過了，或失敗原因與預期不符
- 出現了預期之外的測試失敗

**對應行動**: 更新工作日誌，分析偏差
```markdown
**情境 B: 結果不符合預期 ❌**
- 預期通過的測試失敗了
- 預期失敗的測試通過了，或失敗原因與預期不符
- 出現了預期之外的測試失敗

**對應行動**: 更新工作日誌，分析偏差
```markdown
## 重構結果驗證 - 不符合預期 ❌
### 預期偏差分析：
- [具體記錄哪些預期出現偏差]
- [分析為什麼會有偏差]
- [記錄意外發現的問題]

### 下一步行動決策：
- ☀️ 選擇1: 修正當前問題，繼續原計劃
- 🔄 選擇2: 調整重構計劃，縮小範圍
- 🏠 選擇3: 回到穩定狀態，重新設計
```

#### 📝 Phase 3: 重構完成與工作日誌總結

**完成驗證目的**: 確保重構達成目標，並記錄學習成果供未來參考

**最終驗證檢查**:
```bash
# 基本功能驗證
npm test                # 所有測試必須通過
npm run test:unit       # 單元測試必須通過  
npm run test:integration # 整合測試必須通過

# 品質與效能驗證
npm run lint            # Linter 檢查必須通過
npm run build           # 建置必須成功
npm run test:coverage   # 測試覆蓋率檢查
```

**工作日誌總結更新**:
```markdown
**工作日誌總結更新**:
```markdown
## 重構總結與學習

### 目標達成情況：
- [ ] 原定目標是否達成？
- [ ] 架構問題是否得到解決？
- [ ] 程式碼品質是否符合預期？

### 預期管理的學習：
- 哪些預期是正確的？為什麼？
- 哪些預期是錯誤的？為什麼？
- 下次類似重構應該注意什麼？

### 方法論的改進：
- 重構計劃的哪些部分需要改進？
- 測試預期的方法可以怎麼優化？
- 未來類似問題的預防策略是什麼？
```

#### 📋 重構方法論檢查清單

**重構開始前**:
- [ ] 已建立新的工作日誌
- [ ] 明確記錄重構動機和目標
- [ ] 詳細分析影響範圍
- [ ] 建立測試結果預期
- [ ] 設定成功標準

**重構過程中**:
- [ ] 測試結果與預期對比
- [ ] 預期偏差的立即分析
- [ ] 工作日誌的即時更新

**重構完成後**:
- [ ] 目標達成情況的總結
- [ ] 預期管理的學習記錄
- [ ] 方法論改進建議
- [ ] 未來預防策略建立

## 📚 專案文件責任明確區分

### 三大核心文件的不同用途與寫作風格

**文件責任分工的重要性**: 每種文件都有明確且不同的目標讀者和用途，絕不可混淆責任或寫作風格

#### 📰 CHANGELOG.md - 使用者導向的版本更新記錄

**目標讀者**: 產品使用者、專案維護者  
**核心用途**: 快速了解版本更新帶來的變化和影響  
**寫作風格**: 簡潔、直接、聚焦於「對使用者的價值」

**✅ 應該包含的內容**:
- **新功能**: 使用者可以使用的新功能
- **改進項目**: 效能提升、使用體驗改善
- **錯誤修正**: 已解決的問題和 bug
- **重大變更**: 可能影響使用者的變更

**✅ 正確的寫作風格範例**: 使用 feat/fix/change 分類，每項描述具體的使用者價值和功能變更

**📋 標準分類說明**:
- **feat**: 新功能 (使用者可以做之前做不到的事)
- **fix**: 錯誤修正 (修正使用者遇到的問題或當機)  
- **change**: 重要變更 (改變現有功能的運作方式)

**✅ 寫作原則**:
- 描述使用者可直接感受到的功能變化
- 使用具體的操作和結果描述，避免抽象概念
- 說明實際的使用者體驗改變

**❌ 不應該包含的內容**:
- 詳細的技術實作過程
- 開發思考過程和決策原因
- 具體的程式碼變更細節
- 內部協作和溝通記錄
- 冗長的工作流程描述

**❌ 避免抽象或無法驗證的描述**:
- "提升核心功能穩定性" → ✅ 改為 "修正匯入JSON時程式當機問題"
- "強化資料品質保證" → ✅ 改為 "新增重複書籍檢查功能"
- "架構複雜度降低90%" → ✅ 改為 "移除自動同步設定介面"
- "大幅降低維護成本" → ✅ 改為 "簡化為單一匯出/匯入按鈕"
- "提升使用者體驗" → ✅ 改為 "錯誤訊息改為中文顯示"

#### 📋 TODO.md - 開發規劃與進度追蹤

**目標讀者**: 開發團隊、專案經理  
**核心用途**: 追蹤開發進度和規劃未來工作  
**寫作風格**: 結構化、狀態明確、優先級清楚

**✅ 應該包含的內容**:
- **當前專案狀態**: 版本號、整體進度
- **進行中的工作**: 具體的開發任務
- **待完成項目**: 按優先級排序的工作清單
- **完成狀態追蹤**: 明確的完成度標記

**✅ 正確的寫作風格範例**:
```markdown
### ✅ Popup 模組化整合已完成 (架構完成度: 100%)
- [x] PopupController 依賴注入架構
- [x] 事件系統架構完整實作
- [x] 完整測試覆蓋 (18 個測試檔案)

### 🎯 下一步高優先級工作
- [ ] 職責拆分檢查 - data-synchronization-service.js (1689行)
```

**❌ 不應該包含的內容**:
- 詳細的開發過程記錄
- 技術問題的分析過程
- 完整的解決方案描述
- 給使用者的功能說明

#### 📝 工作日誌 - 協作者知識交換平台

**目標讀者**: 開發團隊成員、未來的協作者  
**核心用途**: 詳細記錄開發過程，知識傳承和協作溝通  
**寫作風格**: 詳細、分析性、教學性

**✅ 應該包含的內容**:
- **完整的思考過程**: 如何發現問題、分析原因
- **技術決策記錄**: 為什麼選擇某種解決方案
- **問題解決流程**: 詳細的調查和修正步驟
- **學習和改進**: 經驗總結和預防機制
- **協作交接資訊**: 為下一個開發者提供的詳細脈絡

**✅ 正確的寫作風格範例**:
```markdown
### 系統性調查方法論
#### Phase 1: 實際程式碼狀況驗證
調查步驟：
1. 程式碼架構分析：檢查 PopupController 實際實作
   - 發現完整的依賴注入架構
   - 支援 EventManager 和降級機制

#### Phase 2: 測試執行狀況驗證
執行測試：npm test -- --testPathPattern="popup" --verbose
結果分析：
- 測試檔案存在且可執行
- 測試結構顯示完整的模組化架構已建立
```

**❌ 不應該包含的內容**:
- 簡化的狀態更新
- 面向使用者的功能說明
- 缺乏分析深度的流水帳記錄

### 📏 文件寫作品質標準

#### CHANGELOG.md 品質要求
- **標準格式**: 使用 feat/fix/change 三大分類，每項控制在 3-5 行
- **使用者價值**: 每個項目都要能回答「這對使用者有什麼好處？」
- **具體描述**: 使用動作詞彙，明確說明功能改進或問題解決
- **影響導向**: 聚焦於使用者可感知的變更和影響

#### TODO.md 品質要求
- **狀態準確**: 狀態必須與實際程式碼狀況 100% 一致
- **優先級明確**: 工作項目按重要性和緊急性排序
- **可追蹤性**: 每個項目都有明確的完成標準
- **定期更新**: 每完成一個工作立即更新狀態

#### 工作日誌品質要求
- **教學性**: 新協作者能夠從中學習和理解
- **完整性**: 記錄完整的思考和決策過程
- **可重現性**: 其他人能夠根據記錄重現相同的分析
- **預防性**: 包含防止類似問題的具體建議

### 🚨 文件責任混淆的風險提醒

**文件責任混淆會導致**:
- **使用者困惑**: CHANGELOG 過於技術化，使用者無法理解版本變更價值
- **開發規劃混亂**: TODO 包含過多細節，重點不清楚
- **知識流失**: 工作日誌過於簡化，協作者無法獲得足夠資訊
- **維護困難**: 各文件責任重疊，更新時容易遺漏或不一致

**最佳實踐檢查清單**:
- [ ] CHANGELOG 是否簡潔且聚焦於使用者價值？
- [ ] TODO 是否狀態明確且優先級清楚？
- [ ] 工作日誌是否包含完整的思考和決策過程？
- [ ] 三種文件是否各司其職，沒有責任重疊？

## 📋 版本控制與工作日誌管理

### 版本號系統規範

#### 版本類型明確區分

**🎯 專案版本（數字版本號）**：
- **格式**: v0.9.x, v1.0.0（影響整個產品發布）
- **用途**: 實際的產品發布版本，面向使用者
- **範例**: v0.9.18, v1.0.0, v1.2.5

**🏗 架構版本（希臘字母）**：
- **格式**: α (Alpha), β (Beta), γ (Gamma), δ (Delta), ε (Epsilon), ζ (Zeta), η (Eta), θ (Theta)
- **用途**: 內部技術架構演進標記，不影響產品版本號
- **範例**: 事件系統架構-α, BookSearchFilter重構-β, Content模組化-γ
- **排序**: α → β → γ → δ → ε → ζ → η → θ → ι → κ → λ → μ

**🔧 功能版本（模組內部）**：
- **格式**: API v1.2, Engine v3.1（特定功能模組版本）
- **用途**: 模組內部版本追蹤，與專案版本無關

#### 版本號規則
- **v0.9.x 階段**: 重構和準備階段，為 v1.0 做準備
- **v1.0.0**: 第一個正式發布版本
- **v1.x.x**: 功能更新和改進
- **v2.0.0**: 重大架構變更或突破性更新

#### 版本確認檢查點

**任何版本相關工作前，必須先確認當前專案狀態**：

**必須檢查的檔案（按優先順序）**：
1. **`docs/todolist.md`** - 查看「🎯 專案當前狀態」章節的版本號
2. **`CHANGELOG.md`** - 確認最新版本記錄 
3. **`package.json`** - 查看專案版本號
4. **最新工作日誌** - 在 `docs/work-logs/` 中找到最新的 `vX.X.X-work-log.md`

### TDD 循環合規檢查與版本提交

#### 每個 TDD 循環完成後的標準流程

**1. 完整合規檢查**
```bash
# 執行完整檢查套件
npm test && npm run test:coverage && npm run lint && npm run build
```

**品質標準驗證**：
- [ ] 測試覆蓋率達到 100%
- [ ] 所有 linter 檢查通過
- [ ] 建置成功無錯誤
- [ ] 效能沒有明顯退化

**2. Git 操作驗證**
```bash
git status      # 檢查變更狀態
git diff        # 確認變更內容
```

**變更驗證**：
- [ ] 變更範圍與功能描述一致
- [ ] 沒有不相關的程式碼變更
- [ ] 沒有敏感資訊洩漏

**3. 文件同步更新**

**必須更新的三大核心文件**: 按照「📚 專案文件責任明確區分」章節的責任分工和品質標準執行

**文件更新檢查清單**:
- [ ] **TODO.md**: 符合開發規劃與進度追蹤標準
- [ ] **工作日誌**: 符合協作者知識交換平台標準  
- [ ] **CHANGELOG.md**: 符合使用者導向版本更新記錄標準
- [ ] **專家審查記錄**: 所有專家審查報告已歸檔到 `docs/context/expert_reviews/`
- [ ] **🧠 Memory知識網路**: 重要洞察已原子化為Memory並建立連結關係

**4. Git Commit 提交**
```bash
git add .
git commit -m "$(cat <<'EOF'
[commit message here]

EOF
)"
```

**Commit 品質標準**：
- [ ] 使用 Conventional Commits 格式
- [ ] 訊息清楚描述變更內容和原因

### 工作日誌管理規範

- **建立時機**: 每個中版本號變更時建立新的工作日誌檔案
- **檔案命名**: `docs/work-logs/vX.X.X-work-log.md`
- **更新頻率**: 每完成一個 TDD 循環或重要修復後立即更新

#### 🧠 Context 使用量管理機制

**Context 容量預警規則**:
- **80% 容量觸發點**: 當偵測到 context 使用量達到上限的 80% 時，必須立即執行以下流程
- **預防性工作日誌更新**: 立即停止當前工作，更新當前進度到工作日誌
- **Context 清理重載**: 清除舊的思考內容和暫存資訊，重新讀取工作日誌內容接續工作
- **工作連續性保證**: 確保重載後能夠無縫接續中斷前的工作狀態

**Context 管理工作流程**:
1. **即時偵測**: 持續監控 context 使用量，接近 80% 時主動提醒
2. **緊急記錄**: 將當前思考過程、決策依據、下一步計劃完整記錄到工作日誌
3. **狀態保存**: 記錄當前 TDD 階段、測試狀態、技術債務、待解決問題
4. **Context 重置**: 清除所有暫存內容，從乾淨的 context 狀態重新開始
5. **工作恢復**: 重新讀取工作日誌，快速恢復到中斷前的工作狀態

**Context 重載檢查清單**:
- [ ] 當前進度已完整記錄到工作日誌
- [ ] 重要決策和發現已保存
- [ ] 下一步行動計劃已明確記錄
- [ ] 技術債務和已知問題已列出
- [ ] 測試狀態和通過/失敗情況已記錄
- [ ] 重新讀取工作日誌後能快速理解當前狀況

#### 工作日誌必須包含內容

- TDD 循環的完整 Red-Green-Refactor 過程
- **詳細的思考過程和決策邏輯**
- **問題發現過程**: 如何檢查到錯誤、錯誤症狀描述
- **問題原因分析**: 深入分析錯誤為什麼會發生、根本原因追溯
- **解決方案過程**: 解決方法的選擇、嘗試過程、最終方案
- **重構思路**: 原程式碼的不佳問題、優化思路、改善效果
- **架構決策與專案結構調整**
- **技術棧選擇與工具變更決策**
- **除錯過程**: 包含錯誤訊息、診斷步驟、修復驗證
- **效能優化**: 效能問題識別、分析方法、優化成果

#### 🧠 Memory與工作日誌協同機制

**工作日誌與Memory的分工**:
- **工作日誌**: 記錄完整的思考過程、調查步驟、解決方案選擇過程
- **Memory**: 萃取工作日誌中的關鍵洞察，以結論導向的原子化知識單元儲存

**Memory萃取觸發時機**:
- **專家審查階段**: 當Linux或John Carmack專家發現重要洞察時
- **問題解決完成**: 當找到根本原因和有效解決方案時
- **效能突破**: 當發現顯著的效能優化方法時
- **架構洞察**: 當重構過程發現重要的架構模式時

**工作日誌中的Memory引用**:
```markdown
### 重要發現記錄
本次開發過程中的關鍵洞察已萃取為以下Memory:
- [[使用Map代替Array查找讓搜尋效能提升10倍]] - 效能優化洞察
- [[消除if-else特殊情況的三種資料結構重設計模式]] - 重構模式

詳細的調查和實作過程記錄於上述章節。
```

**Memory與工作日誌的連結**:
- Memory中的「關鍵文件」章節必須引用對應的工作日誌檔案
- 工作日誌完成後，必須檢查是否有值得萃取的Memory
- Memory的觸發原因必須能追溯到具體的工作日誌章節

**協同品質標準**:
- [ ] 工作日誌記錄完整的過程，Memory記錄精煉的結論
- [ ] Memory標題必須比工作日誌章節標題更具結論性
- [ ] 重要的技術決策同時出現在工作日誌和Memory中
- [ ] Memory的連結網路能反映專案的技術演進脈絡

### 版本混淆防範機制

#### 絕對禁止的行為
- ❌ **將架構版本當作專案版本**: 不可將 "α, β, γ" 用於專案發布
- ❌ **跳過版本確認步驟**: 任何版本變更前必須確認當前狀態
- ❌ **版本號自動提升**: 不可未經確認自動提升大版本號
- ❌ **混合使用版本系統**: 同一文件中不可混用不同版本系統

#### 強制檢查機制
- ✅ **工作日誌強制標註**: 必須明確標註版本類型（專案/架構/功能）
- ✅ **TODO 更新前確認**: 更新 TODO 前必須確認當前專案版本
- ✅ **架構文件版本分離**: 架構文件使用希臘字母，工作日誌使用專案版本
- ✅ **Commit 訊息版本正確**: 提交訊息必須使用正確的版本號類型

## 🏗 架構債務管理與程式碼品質規範

### 永不放棄原則 - 架構問題及早修正策略

**核心原則**: 架構問題和設計債務是第一優先修正目標，絕不可「先將就」或「之後再處理」

#### 🚨 立即處理原則

1. **架構問題發現 = 立即修正**: 一旦識別出架構債務，立即停止功能開發，優先修正
2. **修復成本會指數增長**: 架構問題拖延修復的成本隨時間呈指數增長
3. **絕不妥協的品質標準**: 寧可延遲功能發布，也不允許技術債務累積
4. **根本原因必須徹底解決**: 不接受「暫時性修正」或「症狀緩解」

#### 🔍 專家驅動的架構債務識別機制

**雙專家交叉檢查系統**:
- **Linux專家視角**: 從"Good Taste"和實用主義角度識別過度複雜的設計債務
- **John Carmack專家視角**: 從效能和確定性角度識別架構效能債務
- **交叉驗證機制**: 兩位專家必須對架構債務的嚴重程度達成一致

**架構債務分類與優先級**:

**🔴 Critical (必須立即停止開發修正)**:
- Linux判斷為"Garbage"的設計
- John Carmack識別的效能關鍵路徑阻塞
- 違反"Never break userspace"的變更
- 確定性行為被破壞的架構

**🟡 High (下一個TDD循環前必須修正)**:
- Linux判斷為需要重大簡化的複雜設計  
- John Carmack識別的狀態管理純度問題
- 可消除但未消除的特殊情況
- 控制流程過深的架構問題

**🟢 Medium (版本發布前修正)**:
- Linux建議的程式碼品味改善
- John Carmack建議的效能優化機會
- 可改善的抽象邊界設計

#### 🔍 架構債務識別標準

**高優先級架構債務**（必須立即修正）:
- 依賴注入不一致或缺失
- 測試困難或無法測試的程式碼
- 違反 SOLID 原則的設計
- 模組間高耦合或循環依賴
- 不一致的錯誤處理模式
- 缺乏適當的抽象層

**檢查觸發條件**:
- 任何測試失敗都必須深入分析根本原因
- 程式碼重複超過 3 次必須抽象化
- 函數超過 30 行必須考慮重構
- 模組責任不明確必須重新設計

#### 🛠 專家驅動修正流程與標準

**Step 1: 雙專家問題分析**
- **Linux專家分析**: 從複雜度和實用性角度分析債務根因
- **John Carmack專家分析**: 從效能和架構角度分析債務影響
- **建立債務分析文件** (`docs/architecture/expert-debt-analysis/`)
- **雙專家達成修復優先級共識**

**Step 2: 專家指導的TDD修正**
- **專家審查修正計劃**: 修正方案必須通過兩位專家審查
- **TDD驅動實作**: 使用完整的 Red-Green-Refactor 循環
- **階段性專家驗證**: 每個修正步驟都要專家確認方向正確
- **效果驗證**: John Carmack驗證效能影響，Linux驗證複雜度改善

**Step 3: 專家驗證架構一致性**
- **Linux專家檢查**: 確保修正體現"Good Taste"原則
- **John Carmack專家檢查**: 確保修正沒有引入效能債務  
- **跨組件一致性**: 專家指導統一整個專案的設計模式
- **預防機制建立**: 專家提供防止類似問題的具體指導原則

**專家修正驗收標準**:
- [ ] Linux專家: 修正後複雜度確實降低，展現"Good Taste"
- [ ] John Carmack專家: 修正後效能影響可接受，架構邊界清晰
- [ ] 雙專家一致認可: 債務已徹底解決，未引入新債務
- [ ] 預防機制到位: 有明確的指導原則防止同類問題復發

### 程式碼品質規範

#### 檔案路徑規範 (強制要求)

**完整路徑名稱原則**:
- **每個資料夾都明確寫出實際名稱**: 所有檔案導入必須包含完整的資料夾名稱，讓domain結構一目了然
- **禁止相對深度寫法**: 絕不使用 `../../../` 等相對深度計算方式
- **禁止系統絕對路徑**: 絕不使用 `/Users/...` 等系統絕對路徑
- **Domain可見性**: 路徑必須清楚顯示domain分類和功能分類，便於除錯和維護

**正確路徑格式範例**:
```javascript
// ✅ 正確：完整路徑名稱，domain結構清楚
const EventBus = require('src/core/event-bus')
const DataValidationService = require('src/background/domains/data-management/services/data-validation-service')
const ReadmooAdapter = require('src/content/adapters/readmoo-adapter')
const PopupController = require('src/popup/controllers/popup-controller')
const CrossDeviceSyncService = require('src/background/domains/data-management/services/cross-device-sync-service')

// ❌ 錯誤：使用相對深度，domain結構不明
const EventBus = require('../../../src/core/event-bus')
const DataValidationService = require('../../../../src/background/domains/data-management/services/data-validation-service')
const ReadmooAdapter = require('../../src/content/adapters/readmoo-adapter')

// ❌ 錯誤：系統絕對路徑
const EventBus = require('/Users/project/src/core/event-bus')
const ReadmooAdapter = require('/Users/tarragon/Projects/book_overview_v1/src/content/adapters/readmoo-adapter')
```

**Domain結構可見性檢查**:
從路徑名稱應該能夠直接判斷：
- **Domain分類**: `background/domains/data-management` 表示資料管理域
- **功能分類**: `services` 表示服務層，`controllers` 表示控制層
- **平台特定**: `content` 表示內容腳本，`popup` 表示彈出介面
- **核心組件**: `core` 表示核心基礎設施

**除錯便利性**:
- ✅ 路徑錯誤立即可見：如果看到 `src/background/domains/ui-management/services/data-validation-service` 就知道domain錯誤
- ✅ 缺少層級立即可見：`src/background/services/data-validation-service` 缺少 `domains/data-management`
- ✅ 多餘層級立即可見：`src/background/domains/data-management/sub-domain/services/` 有多餘的 `sub-domain`

**路徑重構時機**:
- **測試全部通過後**: 必須等所有測試 100% 通過後，才可進行全專案路徑標準化
- **批次處理**: 使用自動化工具進行批次路徑轉換，避免手動錯誤
- **驗證完整性**: 路徑更改後必須重新運行所有測試確保無破損

**違規後果**:
- 任何使用相對深度路徑的程式碼將被視為技術債務，必須立即修正
- 新增程式碼如使用相對深度路徑，該 commit 不得通過程式碼審查
- 路徑不清晰會導致domain結構模糊，嚴重影響程式碼可維護性和除錯效率

#### Five Lines 規則與單一責任原則

**Five Lines 規則 (強制要求)**:
- 每個方法不應超過5行程式碼，排除大括號 `{` 和 `}`
- 一行指任何以分號結尾的語句：if、for、while、賦值、方法呼叫、return等
- 空白行和大括號不計算在內

**單一職責原則**:
- 每個函數只負責一個明確定義的功能
- 判斷責任範圍：如需用"和"或"或"描述功能，必須拆分
- 函數命名必須清楚表達其單一職責和行為目的

#### 重構專屬原則

**重構策略轉換**:
- **最小實現階段 (Green)**: 以可用為目標，允許權宜實作
- **重構階段 (Refactor)**: 秉持Five Lines規則和單一職責原則進行拆分

**語意化重構方法**:
- **行為導向命名**: 每個函數名稱必須明確描述其行為目的
- **單檔核心概念**: 每個檔案基於一個核心概念組織相關行為
- **任務觸發設計**: 每個case基於單一任務去觸發對應行為

**函數拆分策略**:
- **超過5行立即拆分**: 任何超過5行的函數必須拆分為語意化的輔助函數
- **職責明確分離**: 每個拆分後的函數只負責一個明確的操作
- **組合勝於複雜**: 透過小函數組合實現複雜邏輯，而非單一複雜函數

**重構執行標準**:
- **語意化命名**: 函數名稱必須清楚表達「做什麼」而非「怎麼做」
- **參數語意化**: 函數參數名稱必須表達其在操作中的角色
- **單一入口出口**: 每個函數有明確的輸入輸出，避免副作用
- **可測試設計**: 重構後的每個小函數都應該容易進行單元測試

**重構範例參考**: `docs/refactoring-examples/color-library-refactoring-example.js`

#### 命名與文件規範

**命名規範**:
- 使用描述性且有意義的名稱，清楚表明用途
- 函數名稱以動詞開頭 (如: calculateTotal, validateInput)
- 變數名稱使用名詞 (如: userProfile, paymentAmount)
- 布林變數使用 is, has, can 前綴 (如: isValid, hasPermission)

**文件規範**:
- 每個函數、類別或模組都必須有註解描述其目的和功能
- 註解應解釋"為什麼"這樣實作，而不只是"做了什麼"
- 核心功能必須遵循標準化註解結構

#### 程式碼撰寫與錯誤處理規範

**程式碼撰寫規範**:
- 優先考慮可讀性和可維護性，而非過度最佳化
- 防禦性程式設計：驗證輸入參數，處理邊界情況和例外
- 必須立即修正明顯的 linter 錯誤
- 同一檔案的 linter 錯誤修正不超過 3 次循環

**錯誤處理規範**:
- 清楚定義錯誤處理策略
- 使用有意義的錯誤訊息協助問題診斷
- 在適當層級處理例外，避免例外洩漏
- 記錄關鍵錯誤訊息供後續分析

**程式碼風格**:
- 使用 ES6+ 語法
- 優先使用 const/let 而非 var
- 使用模組化匯入/匯出
- 遵循 JSDoc 註解規範

#### 品質標準與檢查點

**在任何程式碼被標記為「完成」之前，必須驗證**:
1. **測試覆蓋率達標**: 所有測試類型覆蓋率必須達到 100%
2. **零架構債務**: 沒有已知的設計缺陷或債務
3. **一致的模式**: 與專案其他部分設計模式一致
4. **完整的錯誤處理**: 所有可能的錯誤情況都有適當處理
5. **效能基準達標**: 符合或超越效能要求
6. **文件完整性**: 程式碼意圖和使用方式都有清楚文件

#### 🚨 絕對禁止的妥協行為

- ❌ **「先這樣，之後再改」**: 架構問題必須當下解決
- ❌ **「測試之後再寫」**: 違反 TDD 原則
- ❌ **「這個 bug 不影響功能」**: 所有已知問題都必須修復
- ❌ **「複製貼上這段程式碼」**: 重複程式碼必須立即重構
- ❌ **「暫時用 try-catch 包起來」**: 錯誤處理必須有明確策略

## 🎭 事件驅動架構規範

### 事件命名規範
- **格式**: `MODULE.ACTION.STATE`
- **範例**: `EXTRACTOR.DATA.EXTRACTED`、`STORAGE.SAVE.COMPLETED`、`UI.POPUP.OPENED`

### 事件優先級
- `URGENT` (0-99): 系統關鍵事件
- `HIGH` (100-199): 使用者互動事件
- `NORMAL` (200-299): 一般處理事件
- `LOW` (300-399): 背景處理事件

### 事件處理原則
- 每個模組通過事件總線通訊
- 避免直接模組間依賴
- 事件處理器必須有錯誤處理機制
- 實現事件的重試與降級機制

### 模組通訊方式
- Background ↔ Content Script: Chrome Runtime 訊息傳遞
- Background ↔ Popup: Chrome Extension APIs
- 內部模組: Event Bus 模式

## 📦 Chrome Extension 與專案規範

### Chrome Extension 特定要求

**Manifest V3 規範**:
- 嚴格遵循 Manifest V3 API
- 使用 Service Worker 而非 Background Pages
- 實現適當的權限請求策略

**安全性要求**:
- 所有資料處理在本地進行
- 避免將敏感資料傳送到外部服務
- 實現適當的 CSP (Content Security Policy)
- 最小權限原則：只請求必要的權限

**技術規格**:
- **測試框架**: Jest + Chrome Extension API Mocks
- **建置工具**: npm scripts
- **程式碼檢查**: ESLint
- **版本控制**: Git
- **無外部依賴**: 為了安全性和效能考量

### 專案概覽

這是一個基於 **Chrome Extension (Manifest V3)** 的 Readmoo 電子書平台資料提取和管理工具。專案嚴格遵循 **TDD (測試驅動開發)** 和 **事件驅動架構**。

**核心架構原則**:
1. **事件驅動架構**: 所有模組通過中央化事件系統通訊
2. **單一責任原則**: 每個模組、處理器和組件只有一個明確目的
3. **TDD 優先**: 所有程式碼必須先寫測試，使用 Red-Green-Refactor 循環
4. **Chrome Extension 最佳實踐**: 遵循 Manifest V3 規範

**主要組件**:
- **Background Service Worker** (`src/background/`): 處理擴展生命週期和跨上下文事件
- **Content Scripts** (`src/content/`): 從 Readmoo 頁面提取資料
- **Popup 界面** (`src/popup/`): 主要使用者互動界面
- **儲存系統** (`src/storage/`): 管理資料持久化，支援多種適配器
- **事件系統** (`src/core/`): 模組通訊的中央事件總線

### 檔案管理嚴格規則
- **絕對不創建非必要的檔案**
- **優先編輯現有檔案而非創建新檔案**
- **永不主動創建文件檔案 (\*.md) 或 README 檔案**，除非使用者明確要求
- 臨時檔案和輔助腳本在任務完成後必須清理

### 語言規範
**所有回應必須使用繁體中文 (zh-TW)**
- 產品使用者和開發者為台灣人，使用台灣特有的程式術語
- 程式碼中的中文註解和變數命名嚴格遵循台灣語言慣例
- 如不確定用詞，優先使用英文而非中國用語

## 🤖 Agent 協作規範

根據 Claude Code sub-agent 最佳實踐，本專案採用**文件先行的研究規劃模式**，所有 sub-agent 均為純研究員和規劃者，主線程負責所有實際實作工作。

### 📋 核心設計原則

**Sub-agent 最佳實踐應用**:
- **純研究規劃角色**: Sub-agent 專注於分析現有程式碼庫，提出實作計劃，絕不執行實際實作
- **上下文優化**: 透過檔案系統管理上下文，避免大量 token 消耗和上下文壓縮問題
- **主線程實作**: 所有程式碼修改、測試執行、檔案建立均由主線程執行，確保完整上下文

**工作流程模式**:
1. **主線程建立專案上下文檔案** (`docs/context/session_contexts/`)
2. **委派任務給專業 sub-agent 進行研究規劃**
3. **Sub-agent 閱讀上下文，產出詳細實作計劃** (`docs/context/agent_plans/`)
4. **主線程閱讀計劃並執行所有實際實作工作**
5. **更新上下文檔案，記錄進度和決策**

**工作流程控管**
無論是從主線程交接給Sub-agent或者從Sub-agent交付回主線程，都要做commit，不應該累積還沒commit的程式或者文件就把任務交付出去

### 🎯 Sub-agent 角色定位

**🧠 知識管理層級** (新增知識捕獲層)：
- **memory-network-builder** (🧠): 記憶網路架構師
  - 負責知識原子化捕獲、洞察連結建立、決策記錄管理
  - **觸發時機**: 每個TDD Phase完成後 + 專家審查發現重要洞察時
  - **核心職責**: 將洞察轉化為可連結的記憶單元、建立知識圖譜

**🔍 專家審查層級** (品質把關層)：
- **linux** (🔨): Linus Torvalds 程式碼品質專家  
  - 負責設計合理性審查、複雜度評估、"Good Taste"品質把關
  - **觸發時機**: Phase 1設計完成後 + Phase 4重構完成後
  - **核心職責**: 拒絕過度設計、消除特殊情況、確保實用主義
  - **知識協作**: 與memory-network-builder協作記錄"Good Taste"設計模式

- **john-carmack** (⚡): John Carmack 效能系統架構師
  - 負責架構效能審查、熱路徑優化、確定性設計評估  
  - **觸發時機**: Phase 2測試完成後 + Phase 3實作完成後
  - **核心職責**: 熱路徑識別、控制流程簡化、狀態管理純度
  - **知識協作**: 與memory-network-builder協作記錄效能優化洞察和架構模式

**🔄 TDD協作流程導向層級**:
- **lavender-interface-designer** (🎨): 功能設計師專家 - 對應TDD Phase 1
  - 負責功能規劃和需求分析，建立清楚的功能需求和設計規範
  - 建立工作日誌：`docs/work-logs/vX.X.X-feature-design.md`
  - 交接標準：功能需求清楚、API介面定義完整、驗收標準明確

- **sage-test-architect** (🧪): 測試工程師專家 - 對應TDD Phase 2  
  - 根據功能設計，設計並實作完整的測試案例
  - 更新工作日誌：新增測試設計章節到既有工作日誌
  - 交接標準：測試案例實作為程式碼、測試覆蓋率達標、測試程式碼品質良好

- **pepper-test-implementer** (💻): TDD實作規劃師專家 - 對應TDD Phase 3
  - 負責實作策略規劃、權宜方案識別、技術債務記錄，提供詳細實作指引
  - 更新工作日誌：新增實作記錄章節到既有工作日誌  
  - 交接標準：實作策略完整規劃、程式碼範例提供、開發過程設計完整記錄

- **cinnamon-refactor-owl** (🏗️): 重構設計師專家 - 對應TDD Phase 4
  - 執行「🧠 TDD 驅動重構方法論」完整流程，改善程式碼品質和架構
  - 建立重構工作日誌：按照重構方法論要求建立獨立工作日誌
  - 交接標準：重構方法論完整執行、技術債務已解決、重構經驗記錄完整

**🎯 專業支援層級**:
- **rosemary-project-manager** (📋): 敏捷專案管理專家
  - 文件先行策略監督，最小任務分派，跨Agent協調
  - 確保嚴格遵循敏捷開發原則，維護高頻工作日誌更新

- **project-compliance-agent**: 執行層級合規專家
  - 完成小功能或TDD循環後立即執行合規檢查，版本控制標準驗證
  - 操作合規驗證，在rosemary-project-manager策略指導下工作

**🔧 架構與技術專家層級**:
- **basil-event-architect**: 事件驅動架構專家
  - 設計和維護事件驅動架構模式、事件命名規範、模組通訊協議
  - **必須主動使用**於架構設計和事件系統開發

- **oregano-data-miner**: 資料提取專家  
  - 網頁抓取、DOM操作、資料處理專家
  - **必須主動使用**於資料提取策略、資料清理和驗證

- **ginger-performance-tuner**: 效能優化專家
  - 效能分析、記憶體優化、載入速度改善專家
  - **必須主動使用**於效能分析和Chrome Extension效能優化

- **coriander-integration-tester**: 系統整合測試專家
  - 端到端測試、跨元件整合測試、系統級測試專家
  - **必須主動使用**於測試元件互動和完整使用者工作流程

### 📁 上下文管理機制

**檔案系統上下文管理**:
- **上下文檔案**: `docs/context/session_contexts/context_session_X.md`
- **Agent 規劃**: `docs/context/agent_plans/[類別]/[檔案名稱].md`
- **標準模板**: `docs/context/templates/` 提供統一格式

**🔄 TDD流程Agent專用路徑**:
- **功能設計規劃**: `docs/context/agent_plans/feature-design/[功能名稱]-design.md`
- **測試策略規劃**: `docs/context/agent_plans/test-architecture/[功能名稱]-tests.md`
- **實作策略規劃**: `docs/context/agent_plans/implementation/[功能名稱]-impl.md`
- **重構策略規劃**: `docs/context/agent_plans/refactoring/[功能名稱]-refactor.md`

**🔍 專家審查專用路徑**:
- **Linux設計審查**: `docs/context/expert_reviews/linux/[功能名稱]-design-review.md`
- **雙專家測試審查**: `docs/context/expert_reviews/combined/[功能名稱]-test-review.md`  
- **John Carmack架構審查**: `docs/context/expert_reviews/john-carmack/[功能名稱]-arch-review.md`
- **Linux最終審查**: `docs/context/expert_reviews/linux/[功能名稱]-final-review.md`

**🧠 知識管理專用路徑**:
- **Memory儲存目錄**: `memory/` (專案根目錄)
- **Memory檔案命名**: 使用結論導向的中文標題作為檔名
- **Memory連結圖譜**: 透過 `[[memory-id]]` 格式建立知識連結
- **Memory分類索引**: 依據type (decision/implementation/learning/concept/issue) 自動分類

**📚 文件責任合規要求**:
所有Agent輸出必須嚴格遵循 [📚 專案文件責任明確區分](#-專案文件責任明確區分) 章節的標準，特別是工作日誌品質要求。

**🏗️ 重構Agent特殊要求**:
cinnamon-refactor-owl必須按照「🧠 TDD 驅動重構方法論」執行：
- 輸出預期管理計劃，包含測試結果預期
- 記錄預期偏差分析和調整決策  
- 提供完整的重構學習總結

**標準輸出格式**:
```
我已經完成 [任務名稱] 的 [TDD階段] 規劃工作。

📋 **規劃檔案**: `docs/context/agent_plans/[類別]/[檔案名稱].md`
🔄 **上下文更新**: 已更新專案上下文檔案  
🔍 **主要發現**: [重要發現簡要總結]
🎯 **建議行動**: [對主線程的具體建議]
📚 **文件合規**: 規劃內容符合工作日誌品質標準

**下一階段準備**:
- [ ] [列出為下一TDD階段準備的交接檢查點]

請在繼續實作前先閱讀規劃檔案並確認交接標準。
```

### 🔄 實作反饋與協作機制

**主線程實作過程支援**:
- **即時諮詢機制**: 實作過程中遇到規劃外問題，主線程可建立新的上下文檔案快速諮詢專業Agent
- **實作驗證回饋**: 完成關鍵實作步驟後，可請Agent檢視實作結果與規劃的一致性
- **問題解決支援**: 遇到技術難題時，Agent提供深度分析和替代方案建議

**反饋檔案標準格式**: `docs/context/implementation_feedback/[功能名稱]-[問題類型].md`
- **問題描述**: 遇到的具體技術問題或與規劃的偏差
- **當前狀況**: 已嘗試的解決方法和結果
- **諮詢需求**: 希望Agent提供的具體協助類型

**Agent學習改進機制**:
- **規劃品質追蹤**: 收集主線程實作過程中的問題，改進未來規劃品質
- **預測準確度**: 分析實作結果與規劃預期的差異，提升技術判斷準確度
- **協作效率優化**: 根據實作反饋調整規劃細節程度和重點領域

### ⚠️ 嚴格禁止事項

**Sub-agent 絕對禁止行為**:
- ❌ **實作程式碼**: 不得修改、建立或刪除任何程式碼檔案
- ❌ **執行測試**: 不得運行任何測試指令或驗證程式碼
- ❌ **檔案操作**: 不得建立非規劃文件的任何檔案
- ❌ **工具執行**: 不得呼叫實作相關的開發工具

**📚 文件責任違規行為**:
- ❌ **違反文件責任區分**: 不得產出使用者導向CHANGELOG內容
- ❌ **混淆文件用途**: 不得將技術分析寫成TODO.md格式
- ❌ **使用抽象描述**: 禁止"提升穩定性"、"強化品質"等無法驗證的描述
- ❌ **跳過工作日誌要求**: 所有規劃必須符合工作日誌品質標準

**🔄 TDD流程違規行為**:
- ❌ **跨階段執行**: 不得跨越TDD階段或跳過前置階段
- ❌ **違反交接標準**: 不得輸出不符合階段交接檢查點的內容
- ❌ **忽略角色職責**: 必須嚴格按照對應TDD階段的角色職責執行

**🏗️ 重構Agent特殊禁止事項**:
- ❌ **跳過預期管理**: 不得直接提供實作步驟，必須先建立預期管理計劃
- ❌ **忽略偏差分析**: 必須記錄預期與實際結果的對比分析

**🔍 專家審查特殊要求**:
- ✅ **技術判斷必須明確**: Linux必須給出"Good taste/Acceptable/Garbage"判斷
- ✅ **具體改善建議**: 不得只說"需要改善"，必須提供具體方向
- ✅ **效能影響評估**: John Carmack必須評估熱路徑和確定性設計
- ✅ **審查結果可追蹤**: 所有專家建議必須記錄實施狀況
- ❌ **禁止和稀泥**: 專家必須給出明確技術判斷，不得為了"友善"模糊判斷

**🧠 Memory Network Builder特殊要求**:
- ✅ **結論導向標題**: 所有Memory標題必須表達具體結論，不得使用主題式標題
- ✅ **原子化知識**: 每個Memory只記錄一個核心洞察，不得混合多個概念
- ✅ **明確連結關係**: 必須建立基於/導致/相關的明確連結，不得孤立存在
- ✅ **具體觸發記錄**: 必須記錄Memory的觸發原因和專家來源
- ❌ **禁止主題式命名**: 不得使用"快取策略"等主題式標題
- ❌ **禁止內容冗長**: 不得將完整分析過程放入Memory，保持精簡
- ❌ **禁止缺失連結**: 每個Memory必須有至少一個有意義的連結關係

**主線程必須負責**:
- ✅ **所有程式碼實作**: 包括測試、功能、重構
- ✅ **檔案系統操作**: 建立、修改、刪除程式碼檔案
- ✅ **測試執行**: 運行測試套件、驗證功能
- ✅ **工具執行**: 使用 linter、builder、部署工具
- ✅ **除錯和問題解決**: 處理所有技術問題
- ✅ **文件責任執行**: 按照「📚 專案文件責任明確區分」更新CHANGELOG、TODO、工作日誌

### 🔄 Agent與TDD流程整合

**TDD流程執行方式**: Agent 嚴格按照 [🤝 TDD 協作開發流程](#-tdd-協作開發流程設計師導向的團隊協作) 章節定義的四個階段執行，每個 Agent 對應一個 TDD Phase。

**Agent 與 TDD Phase 對應關係**:
- **lavender-interface-designer** → TDD Phase 1 (功能設計)
- **sage-test-architect** → TDD Phase 2 (測試設計)  
- **pepper-test-implementer** → TDD Phase 3 (實作規劃)
- **cinnamon-refactor-owl** → TDD Phase 4 (重構設計)

**Agent 特殊要求**:
- **工作日誌格式**: 必須符合 [📚 專案文件責任明確區分](#-專案文件責任明確區分) 章節的工作日誌標準
- **交接標準**: 嚴格遵循 TDD 協作流程中定義的各階段交接檢查點
- **品質要求**: 輸出內容必須達到詳細、分析性、教學性標準

#### Agent協作品質驗證

**品質檢查標準**: 參考 [🤝 TDD 協作開發流程](#-tdd-協作開發流程設計師導向的團隊協作) 章節的「完整協作檢查清單」和 [📚 專案文件責任明確區分](#-專案文件責任明確區分) 章節的品質標準。

### 🔍 專家審查標準格式與輸出要求

#### 📋 專家審查通用格式標準

**所有專家審查必須包含的核心要素**:
1. **明確技術判斷**: 不得模糊或和稀泥，必須給出清楚的評級
2. **具體改善建議**: 提供可執行的具體改善方向  
3. **風險點識別**: 指出潛在的技術和架構風險
4. **實施優先級**: 建議的實施順序和重要性評級

#### 🔨 Linux專家審查標準格式

**適用階段**: Phase 1 (設計審查) + Phase 4 (最終審查)

**必要輸出格式**:
```markdown
# Linux專家審查報告

## 技術判斷評級
**Taste Score**: Good taste / Acceptable / Garbage
**實用性評估**: Pragmatic / Acceptable / Over-engineered  
**複雜度評估**: Simple / Reasonable / Too Complex

## 核心分析 (Linus三層思考)
**第一層 - 資料結構分析**:
- 核心資料關係: [最關鍵的資料結構設計]
- 資料流動: [資料擁有權和修改權分析]
- 優化機會: [不必要的資料複製或轉換]

**第二層 - 特殊情況識別**:
- 發現的if/else分支: [列出主要條件分支]
- 真正業務邏輯 vs 設計補丁: [區分必要和不必要的複雜度]  
- 消除建議: [如何重新設計資料結構來消除分支]

**第三層 - 複雜度檢查**:
- 功能本質: [用一句話說明功能核心]
- 概念數量: [當前解決方案使用的概念數]
- 簡化路徑: [減半複雜度的具體方法]

## 關鍵問題與建議
**致命問題** (如有): [直接指出最差的設計部分]

**改善方向**:
- [消除特殊情況的具體方法]
- [程式碼行數減少的具體建議] 
- [資料結構改善的具體方向]

## 實施建議
**優先級**: Critical / High / Medium / Low
**預估影響**: [對整體架構的影響評估]
**實施複雜度**: [修改的預估工作量]
```

#### ⚡ John Carmack專家審查標準格式

**適用階段**: Phase 2 (測試審查) + Phase 3 (架構審查)

**必要輸出格式**:
```markdown  
# John Carmack效能架構審查報告

## 效能系統評估
**熱路徑評估**: Clear / Acceptable / Obfuscated
**確定性設計**: Strong / Moderate / Weak
**控制流程**: Flat / Acceptable / Too Deep
**狀態管理**: Pure / Acceptable / Side-effect Heavy

## 關鍵路徑分析
**熱路徑識別**:
- 主要執行路徑: [關鍵效能路徑描述]
- 瓶頸點: [潛在效能瓶頸識別]
- 最壞情況: [最壞情況效能分析]

**控制流程分析**:
- 條件分支深度: [當前巢狀層次]
- 扁平化機會: [可簡化的控制邏輯]
- 狀態流動: [狀態變化的可預測性]

**架構邊界評估**:
- 抽象層次: [當前抽象是否合理]
- 職責分離: [組件間職責劃分清晰度]
- 耦合度: [組件間依賴複雜度]

## 函數式設計機會
**純函數機會**: [可轉為純函數的代碼識別]
**副作用最小化**: [全域狀態和副作用減少建議]
**資料不可變性**: [不可變資料結構的應用機會]

## 效能優化建議
**立即改善**:
- [熱路徑優化的具體方向]
- [控制流程扁平化方法]
- [狀態管理改善策略]

**架構改善**:
- [架構邊界調整建議]
- [函數式設計導入方向]
- [確定性行為強化方法]

## 風險評估
**效能風險**: [潛在的效能瓶頸風險]
**維護風險**: [複雜度累積的維護風險] 
**擴展風險**: [架構擴展性的限制風險]
```

#### 👥 雙專家聯合審查格式

**適用階段**: Phase 2 (測試品質審查) + 重大架構決策

**必要輸出格式**:
```markdown
# 雙專家聯合審查報告

## Linux專家觀點
[按照Linux專家標準格式輸出]

## John Carmack專家觀點  
[按照John Carmack專家標準格式輸出]

## 聯合結論
**技術判斷一致性**: 
- 共識點: [兩位專家一致認同的判斷]
- 分歧點: [兩位專家觀點不同的部分]
- 最終建議: [基於雙專家討論的最終建議]

**優先級排序**:
1. [最高優先級改善項目]
2. [次優先級改善項目] 
3. [建議改善項目]

**實施路徑**:
- 第一階段: [立即必須處理的項目]
- 第二階段: [中期改善項目]
- 第三階段: [長期優化項目]
```

#### ✅ 專家審查品質驗收標準

**Linux專家審查驗收**:
- [ ] 提供明確的"Good taste/Acceptable/Garbage"判斷
- [ ] 具體分析資料結構設計合理性
- [ ] 識別並提供特殊情況消除方法
- [ ] 給出具體的複雜度簡化建議
- [ ] 評估向後相容性影響

**John Carmack專家審查驗收**:
- [ ] 明確識別熱路徑和效能關鍵點
- [ ] 評估控制流程的扁平化程度
- [ ] 分析狀態管理的純度和副作用
- [ ] 提供確定性設計改善建議
- [ ] 評估架構邊界的合理性

**雙專家聯合審查驗收**:
- [ ] 兩位專家觀點完整呈現
- [ ] 對分歧點有明確討論和結論
- [ ] 提供明確的實施優先級排序
- [ ] 給出階段性實施路徑建議

## 🔧 開發工具和指令

### 測試指令
```bash
# 執行所有測試
npm test

# 監視模式執行測試
npm run test:watch

# 執行特定類型測試
npm run test:unit
npm run test:integration
npm run test:e2e

# 執行測試並產生覆蓋率報告
npm run test:coverage
```

### 建置指令
```bash
# 安裝依賴項 (注意：使用 --legacy-peer-deps)
npm install --legacy-peer-deps

# 開發版本建置
npm run build:dev

# 生產版本建置
npm run build:prod

# 啟動開發工作流程 (建置 + 監視測試)
npm run dev
```

### 程式碼品質指令
```bash
# 執行程式碼檢查
npm run lint

# 自動修正程式碼檢查問題
npm run lint:fix

# 清理建置產物
npm run clean
```

## 📊 任務追蹤管理

### 任務管理
- 所有任務記錄在 `docs/todolist.md`
- 使用圖例追蹤進度：⭕ 待開始、🔴 紅燈、🟢 綠燈、🔵 重構、✅ 完成
- 每完成一個 TDD 循環立即更新狀態

### 里程碑追蹤
- v0.0.x: 基礎架構與測試框架
- v0.x.x: 開發階段，逐步實現功能
- v1.0.0: 完整功能，準備上架 Chrome Web Store

## 📚 重要文件參考

- `docs/architecture/event-system.md` - 詳細事件系統設計
- `docs/struct.md` - 完整專案結構說明
- `docs/todolist.md` - 開發任務追蹤
- `docs/work-logs/` - 詳細開發工作日誌
- `CHANGELOG.md` - 版本變更記錄