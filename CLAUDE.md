# CLAUDE.md

本文件為 Claude Code (claude.ai/code) 在此專案中的開發指導規範。

## 🚨 絕對不可違反的核心規則

1. **架構債務零容忍**: 一旦發現架構問題，立即停止功能開發，優先修正，絕不妥協
2. **永不放棄原則**: 複雜問題不得用 "sorry" 或 "暫時處理" 解決，必須找到根本解法
3. **絕對遵循 TDD**: 沒有測試就不寫程式碼，Red-Green-Refactor 循環不可跳步
4. **保持測試通過**: 任何時候都不能讓測試套件失敗，100% 通過率是最低標準
5. **最低完成策略**: 以可用為目標，允許權宜實作，但必須以 `//todo:` 註記後續重構方向
6. **工作品質要求**: 深入分析問題根因、應用系統化方法、詳細記錄思考過程
7. **文件同步更新**: 程式碼變更後立即更新相關文件，包括工作日誌和版本記錄，然後確實無論大階段或者小步驟的更新都應該提交 commit，不可節省
8. **繁體中文**: 所有溝通和文件使用台灣繁體中文，技術術語遵循台灣慣例
9. **版本管理嚴格要求**: 必須明確區分專案版本與架構版本，任何版本變更前必須確認當前版本狀態

## 🚨 核心執行準則

**所有任務執行都必須遵循以下完整執行流程，確保工作品質和完成度**

### 標準工作執行流程

#### 1. 問題理解階段 (必須完成)

- 完整理解任務需求和技術限制
- 識別所有相關的技術要素和依賴關係
- 尋找現有程式碼中的相似實作模式
- 將複雜任務分解成具體可執行的工作項目

#### 2. 方案設計階段 (必須完成)

- 設計解決方案的整體架構
- 確定實作的優先順序和執行順序
- 建立可驗證的中間成果檢查點
- 準備必要的工具和資源
- **文件先行**：必須先撰寫設計文件、架構規範、API 接口定義後才開始實作

#### 3. 文件撰寫階段 (必須在實作前完成)

- 撰寫詳細的技術設計文件
- 定義明確的 API 接口和資料結構
- 建立架構決策記錄（ADR）
- 撰寫重構計劃和風險評估文件
- 更新相關的工作日誌作為站立會議記錄
- **文件驗證**：確保設計方案可行且符合既有架構

#### 4. 執行實作階段

- 按照設計文件執行具體工作
- 遇到技術問題時使用基本方法先建立可用版本
- 在必要時可先以權宜實作完成功能，但必須於相關程式碼以 `//todo:` 註記後續重構方向
- 記錄實作過程中的決策和遇到的問題
- 建立必要的輔助功能來支援主要功能
- **嚴禁**在沒有設計文件的情況下開始編碼

#### 5. 完善優化階段 (在核心功能完成後執行)

- 完善技術實作細節
- 尋找和應用最佳實務
- 處理邊界情況和錯誤處理
- 優化性能和使用者體驗

### 執行品質要求

- **最低完成策略**：允許以暫時較差的架構或設計先讓功能可用；所有已知的架構/設計問題必須在程式碼以 `//todo:` 註記，簡要說明後續修正方向
- **註記格式**：使用 `//todo: <修正方向>`，例如 `//todo: 重構資料流，改用事件總線以移除直接依賴`
- **文件記錄**：記錄工作過程、決策理由和遭遇的問題
- **解決方案導向**：提供具體可用的解決方案，而非抽象說明
- **持續改進**：從每次執行中學習並改進工作方法

### 工作流程合規要求

- 不得因技術複雜度而跳過必要的工作階段
- 不得在未完成基本功能的情況下結束任務
- 必須提供足夠詳細的工作記錄以便後續維護
- 需要協助時必須已完成大部分基礎工作

### 文件撰寫監督檢視規範

#### 💼 務實監督報告風格要求

**撰寫工作日誌、技術報告和架構文件時，必須採用監督檢視的客觀評估角度**：

#### ❌ 絕對禁止的誇飾用語
- **過度讚譽詞彙**: 企業級、完美、太棒了、卓越、優秀、驚艷
- **誇大成就用語**: 突破性、革命性、劃時代、史上最佳
- **情緒化描述**: 令人興奮、振奮人心、激動人心
- **絕對化表述**: 完全解決、徹底消除、百分百成功

#### ✅ 必須採用的務實記錄方式

**功能性描述**:
- ❌ "完美實現了企業級架構" 
- ✅ "實作了 5層驗證策略，支援配置檢查、事件轉換、功能驗證"

**效果記錄**:
- ❌ "效能提升令人驚艷"
- ✅ "測試執行時間從 45秒 降低至 23秒，提升 49%"

**問題處理**:
- ❌ "完美解決了所有架構問題"
- ✅ "修正了 3個主要架構問題：循環依賴、錯誤處理不一致、測試覆蓋不足"

**風險評估**:
- ❌ "沒有任何風險"
- ✅ "識別風險：跨模組通訊延遲可能影響響應時間，需持續監控"

#### 📊 標準報告結構要求

**技術實現記錄**：
- 具體功能列表和技術規格
- 實際測試覆蓋率數字和通過狀態
- 程式碼行數、模組數量等量化指標
- 實作時間和資源消耗記錄

**問題與解決方案**：
- 具體問題描述和發生情境
- 嘗試的解決方案和效果評估
- 最終採用方案的選擇理由
- 殘留問題和後續工作項目

**品質指標客觀評估**：
- 測試通過率具體數字
- 效能指標的實際數據對比
- 程式碼複雜度和維護性評估
- 架構債務存在狀況和影響程度

#### 🎯 監督檢視核心原則

1. **客觀事實報告**: 記錄實際發生的事情和具體成果
2. **量化成果展示**: 使用具體數字和可驗證的指標
3. **風險誠實揭露**: 不隱瞞潛在問題和技術限制
4. **改善空間識別**: 主動指出可以優化的領域
5. **成本效益分析**: 評估投入資源與產出成果的合理性

### 敏捷開發機制作業規範

#### 📋 文件先行策略（Document-First Strategy）

- **設計文件優先**：任何架構變更、重構或新功能開發前，必須先撰寫完整的設計文件
- **API 接口定義**：明確定義所有接口、資料結構和行為契約後才開始編碼
- **架構決策記錄（ADR）**：重要的技術決策必須以文件形式記錄，包含決策背景、選項比較和理由
- **風險評估文件**：任何可能影響現有功能的變更都必須撰寫風險評估和緩解策略

#### 📊 最小分派最快交付（MVP Strategy）

- **任務設計與分派**：預設目標為「最小、最快可交付」（MVP）
- **文件驗證點**：設計文件完成後必須經過可行性驗證，確認符合既有架構
- **階段性交付**：將大型重構分解成多個小型、可驗證的交付階段
- **即時回饋循環**：每個階段完成後立即驗證和回饋，快速調整方向

#### 📝 高頻工作日誌更新（Stand-up via Logs）

- **工作日誌即站立會議**：每位任務執行者須高頻更新工作日誌，作為同步進度、阻礙與決策之主要管道
- **主動文件更新責任**：依照敏捷開發原則，必須更頻繁且主動的更新工作日誌和相關文件，向下一個接手的人說明當前任務進度和預計計畫
- **決策透明化**：所有架構決策、問題發現、解決方案都必須記錄在工作日誌中
- **阻礙及時回報**：遇到技術阻礙或需要決策支援時立即更新工作日誌
- **進度可視化**：透過工作日誌讓所有協作者了解當前進度和狀態
- **交接文件完整性**：每個任務完成後必須更新或建立相關文件，確保知識傳承和工作連續性

#### 🔄 協作標註與重構循環

- **程式碼協作標註**：於程式碼使用 `//todo:` 作為協作溝通管道，明確描述後續改善方向與依賴
- **重構循環**：先達成最小可交付，於重構階段依據工作日誌與 `//todo:` 標註重新評估優先順序與工作量，安排優化與重構
- **文件同步更新**：程式碼變更後必須同步更新相關設計文件，保持文件與實作一致
- **與既有規範對齊**：本機制與「最低完成策略」「📋 版本控制強制要求」「工作日誌管理規範」共同運作

#### 🎯 敏捷文件更新強制要求

- **開始任何開發工作前**：必須先建立或更新對應版本的工作日誌，記錄規劃思路、技術方案和預期目標
- **開發過程中同步記錄**：工作日誌必須與開發思考同步進行，即時記錄：
  - 技術決策的思考過程和選擇理由
  - 遇到的問題、錯誤和解決過程
  - 架構設計的演進和調整
  - 測試設計思路和發現的問題
  - 重構決策和效果評估
- **每個 TDD 循環完成後**：立即更新工作日誌記錄具體進度和成果
- **功能模組完成後**：必須更新架構文件、API 文件和使用說明
- **版本變更時**：必須同步更新 CHANGELOG.md、todolist.md 和版本記錄
- **絕對禁止事後補寫**：工作日誌不得在完成後才補寫，必須反映真實的開發思考過程
- **知識傳承責任**：記錄技術發現、最佳實踐、陷阱和後續改善建議

### TDD 循環完成後的標準流程

此流程統一由「📋 版本控制強制要求」章節規範，避免重複。

## 🧪 TDD (測試驅動開發) 嚴格要求

### ❗ 絕對不可違反的 TDD 規則

1. **絕對不能在沒有測試的情況下寫程式碼**
2. **每次只實現讓測試通過的最小程式碼**
3. **重構時必須保持所有測試通過**
4. **定期執行完整測試套件**

### 🔍 TDD 完整開發流程

TDD 的完整流程包含以下階段，確保每一步都有明確的交付物和驗證標準：

#### 📋 階段一：問題分析與測試清單建立

**目標：將複雜問題拆解成可測試的小部分**

在開始編寫任何程式碼之前，必須完成：

1. **需求分析文件化**：
   - 明確定義功能需求和驗收標準
   - 識別邊界條件和異常情況
   - 定義輸入輸出格式和行為期望

2. **建立動態測試清單**：
   - 將功能拆解成獨立的測試案例
   - 為每個測試案例定義明確的輸入和期望輸出
   - 按優先級排序測試案例（核心功能 → 邊界條件 → 異常處理）
   - 建立測試案例依賴關係圖

3. **測試架構設計**：
   - 設計測試資料結構和Mock物件
   - 規劃測試組織方式（describe/it結構）
   - 定義測試設置和清理策略

**交付物**：
- 測試清單文件（列出所有測試案例和優先級）
- 測試架構設計文件
- Mock物件和測試資料設計

**驗證標準**：
- [ ] 測試清單涵蓋所有主要功能和邊界條件
- [ ] 每個測試案例都有明確的驗收標準
- [ ] 測試架構設計完整且可執行

#### 🎯 階段二：測試案例文件化設計

**目標：在編寫程式碼之前完成完整的測試案例設計**

1. **詳細測試案例撰寫**：
   - 為測試清單中的每個項目撰寫詳細的測試規格
   - 定義測試情境（Given-When-Then格式）
   - 指定具體的斷言和驗證邏輯

2. **測試分類與組織**：
   - 按功能領域組織測試（Construction, Core Logic, Integration, Performance）
   - 建立測試案例間的依賴關係
   - 定義測試執行順序和分組策略

3. **測試環境規劃**：
   - 設計Mock服務和依賴
   - 規劃測試資料管理策略
   - 定義測試隔離和清理機制

**交付物**：
- 完整的測試案例文件
- 測試環境設置指南
- Mock物件設計規格

**驗證標準**：
- [ ] 每個測試案例都有詳細的Given-When-Then描述
- [ ] 測試環境設計完整且可重現
- [ ] 測試案例覆蓋率達到設計目標

### Red-Green-Refactor 循環（主線程完整實作）

**前提：已完成階段一和階段二的文件化設計工作**

#### 🔴 Red 階段：撰寫失敗的測試

**目標：從測試清單中選擇一項，撰寫會失敗的測試**

1. **選擇測試項目**：
   - 從階段一建立的測試清單中選擇一個測試案例
   - 優先選擇核心功能或當前開發重點
   - 確保選擇的測試案例具有明確的驗收標準

2. **撰寫失敗測試**：
   - 根據階段二的測試案例文件，實作具體的測試程式碼
   - 測試必須描述期望的行為，而非實作細節
   - 使用 Given-When-Then 結構組織測試邏輯
   - 測試命名清楚，描述測試場景和期望結果

3. **確保測試失敗**：
   - 執行測試，確認測試真的會失敗
   - 驗證失敗原因符合預期（因為功能尚未實作）
   - 確保測試失敗不是因為語法錯誤或測試設計問題

**品質檢查點**：
- [ ] 從測試清單中正確選擇了一個測試案例
- [ ] 測試程式碼語法正確且可執行
- [ ] 測試執行失敗（紅燈狀態）
- [ ] 失敗原因明確且符合預期
- [ ] 測試描述清楚，易於理解
- [ ] 系統處於「只有一個測試失敗」的已知狀態

#### 🟢 Green 階段：讓測試通過

**目標：撰寫剛好足夠的程式碼使測試通過**

1. **最小實作原則**：
   - 只寫剛好讓失敗測試通過的程式碼
   - 這個階段可以暫時忽略程式碼的品質
   - 重點是快速實現功能，即使程式碼有重複或設計不佳
   - 優先可用性，不追求完美設計

2. **實作策略**：
   - 使用最簡單、最直接的方案讓測試通過
   - **權宜實作允許**：可使用暫時方案，但須標註 `//todo: [改善方向]`
   - 避免過度設計或預測未來需求
   - 專注於當前測試要求，不要試圖解決未來可能的問題

3. **驗證測試通過**：
   - 執行完整測試套件，確保所有測試都通過
   - 確認新增的程式碼確實解決了失敗的測試
   - 驗證沒有破壞既有的功能

**品質檢查點**：
- [ ] 失敗的測試現在通過了
- [ ] 所有其他測試仍然通過（綠燈狀態）
- [ ] 沒有新增不必要的複雜性或過度設計
- [ ] 暫時實作已標註 `//todo:` 註記
- [ ] 程式碼可以正常執行且達到基本功能要求
- [ ] 系統回到「所有測試都通過」的已知狀態

#### 🔵 Refactor 階段：改善程式碼設計

**目標：在所有測試都通過的前提下，改善程式碼的結構和設計**

1. **重構前準備**：
   - 確認當前所有測試都通過（處於綠燈狀態）
   - 識別程式碼中的問題：重複、複雜度、命名、結構
   - 規劃重構步驟，每次只進行一個小的改動

2. **執行重構**：
   - **消除重複**：找出重複的程式碼並提取共用邏輯
   - **提升可讀性**：改善變數和函數命名，增加程式碼清晰度
   - **簡化設計**：移除不必要的複雜性，讓程式碼更簡潔
   - **解決技術債務**：處理所有 `//todo:` 標註的改善項目

3. **保持測試通過**：
   - 每次重構後立即執行測試套件
   - 確保所有測試仍然通過
   - 如果測試失敗，立即回退變更

**重構檢查清單**：
- **命名改善**：函數、變數、類別名稱是否清楚表達意圖
- **程式碼組織**：是否符合單一責任原則
- **重複消除**：是否存在可以抽象化的重複程式碼
- **複雜度降低**：是否可以簡化複雜的邏輯
- **設計模式**：是否與專案其他部分保持一致

**品質檢查點**：
- [ ] 所有測試仍然通過（維持已知狀態）
- [ ] 消除了所有 `//todo:` 標註的問題
- [ ] 程式碼符合專案編碼規範
- [ ] 沒有明顯的設計問題
- [ ] 效能沒有明顯退化
- [ ] 程式碼更清晰、簡潔、易維護
- [ ] 系統仍處於「所有測試都通過」的已知狀態

### 🔄 維持已知狀態

**TDD 的核心安全機制：整個開發過程中，系統始終處於已知且可控的狀態**

#### 🎯 已知狀態的定義

在 TDD 開發過程中，系統只能處於以下兩種已知狀態之一：

1. **綠燈狀態（Green State）**：
   - 所有測試都通過
   - 系統功能穩定且可用
   - 可以安全進行重構或開始下一個測試

2. **紅燈狀態（Red State）**：
   - 只有一個測試失敗
   - 失敗原因明確且可預期
   - 正在實作該測試對應的功能

#### ⚠️ 禁止的不穩定狀態

以下狀態都是不被允許的，必須立即修正：

- **多個測試同時失敗**：表示系統失控，需要回退到上一個穩定狀態
- **測試失敗原因不明**：可能是測試設計問題或意外的副作用
- **無測試狀態**：沒有測試覆蓋的程式碼開發
- **測試通過但功能錯誤**：測試設計不當，需要重新設計測試

#### 🛡️ 維持已知狀態的策略

1. **頻繁執行測試**：
   - 每次程式碼變更後立即執行測試
   - 使用快速的單元測試提供即時回饋
   - 定期執行完整測試套件確保整體穩定性

2. **小步前進**：
   - 每次只進行一個小的變更
   - 避免同時修改多個功能或模組
   - 在確認當前狀態穩定後才進行下一步

3. **立即修正**：
   - 發現測試失敗立即處理，不累積問題
   - 遇到不明原因的失敗時，回退到上一個穩定狀態
   - 絕不允許在不穩定狀態下繼續開發

4. **狀態追蹤**：
   - 記錄每次狀態變更的原因和預期結果
   - 使用版本控制系統保存每個穩定狀態
   - 建立清楚的回退機制

#### 🔍 狀態檢查檢查清單

在每個 TDD 循環階段都必須驗證系統狀態：

**Red 階段後檢查**：
- [ ] 只有一個測試失敗
- [ ] 失敗原因明確且符合預期
- [ ] 其他所有測試仍然通過

**Green 階段後檢查**：
- [ ] 所有測試都通過
- [ ] 新功能按預期工作
- [ ] 沒有破壞既有功能

**Refactor 階段中檢查**：
- [ ] 每次重構後所有測試仍通過
- [ ] 功能行為沒有改變
- [ ] 系統保持在綠燈狀態

#### 💡 已知狀態的價值

**開發者信心**：
- 每一步修改都是安全的
- 可以大膽進行重構而不怕破壞功能
- 問題定位快速且準確

**團隊協作**：
- 任何時候接手程式碼都處於穩定狀態
- 清楚的進度指標和品質保證
- 降低整合風險和衝突

**產品品質**：
- 每個功能都有測試保護
- 回歸問題能夠快速發現
- 持續的品質改進和維護

### 📊 TDD 品質度量標準

#### 測試覆蓋率要求
- **單元測試覆蓋率**: 100%
- **整合測試覆蓋率**: 主要流程 100%
- **E2E 測試覆蓋率**: 核心使用者場景 100%

#### 程式碼品質指標
- **函數長度**: 一般不超過 30 行
- **圈複雜度**: 單一函數不超過 10
- **重複程式碼**: 不允許超過 3 次重複
- **技術債標註**: 所有 `//todo:` 必須在重構階段解決

#### 執行效能標準
- **測試執行時間**: 單元測試套件不超過 30 秒
- **建置時間**: 完整建置不超過 2 分鐘
- **Linter 檢查**: 必須通過，不允許警告

### 🔄 TDD 循環執行流程

#### 每個循環必須執行的命令
1. **開始前檢查**：
   ```bash
   npm test        # 確認現有測試通過
   npm run lint    # 確認程式碼品質
   ```

2. **Red 階段後檢查**：
   ```bash
   npm test        # 確認新測試失敗
   ```

3. **Green 階段後檢查**：
   ```bash
   npm test              # 確認所有測試通過
   npm run test:coverage # 檢查測試覆蓋率
   ```

4. **Refactor 階段後檢查**：
   ```bash
   npm test        # 確認重構後測試仍通過
   npm run lint    # 確認程式碼品質
   npm run build   # 確認建置成功
   ```

### ⚠️ TDD 常見陷阱與防範

#### 避免的不良實踐
- ❌ **跳過測試**：直接寫實作程式碼
- ❌ **測試後寫**：實作完成後才補測試
- ❌ **過度實作**：Green 階段寫超過需要的程式碼
- ❌ **忽略重構**：滿足於能通過測試的程式碼

#### 品質保證機制
- ✅ **嚴格順序**：必須按 Red-Green-Refactor 順序執行
- ✅ **小步迭代**：每次只處理一個小功能
- ✅ **持續驗證**：每個階段都要執行相關檢查
- ✅ **技術債清理**：重構階段必須處理所有已知問題

### 🏗️ TDD 驅動重構方法論 

#### 🎯 重構核心原則：一次只有一個測試失敗

**基本要求**：
- **重構期間維持已知狀態**: 任何時刻只能有一個測試失敗，其他所有測試必須通過
- **小步漸進原則**: 每次重構只改變一小部分，立即驗證測試狀態
- **測試先行策略**: 重構前必須建立完整的測試影響評估和更新計劃

#### 🔍 重構前必備評估階段

**Phase 0: 重構前測試影響評估**

1. **📋 測試影響分析**:
   - 識別所有會受到重構影響的測試檔案
   - 分析測試與程式碼的依賴關係
   - 建立測試更新清單和優先級

2. **🎯 測試架構評估**:
   - 評估測試架構是否需要相應調整
   - 檢查是否需要新增測試覆蓋重構範圍
   - 設計測試的向後相容和遷移策略

3. **📊 基準線建立**:
   - 記錄重構前的測試覆蓋率基準
   - 建立重構前的效能基準
   - 確保重構後測試覆蓋率不低於重構前

4. **🗺️ 重構路徑規劃**:
   - 制定詳細的小步重構計劃
   - 每個步驟都有明確的測試驗證點
   - 建立每個階段的測試同步更新計劃

#### 🔄 TDD 重構執行循環

**🔴 Red 階段 (重構準備)**:
1. **現狀分析**: 詳細分析當前架構和測試覆蓋狀況
2. **單一測試失敗**: 選擇一個需要重構的小範圍，讓對應測試失敗
3. **影響範圍確認**: 確認只有一個測試失敗，其他測試都通過
4. **失敗原因記錄**: 明確記錄為什麼這個測試需要失敗

**🟢 Green 階段 (最小重構實施)**:
1. **最小範圍重構**: 只重構讓失敗測試通過的最小程式碼
2. **即時測試驗證**: 每個小改動後立即執行測試套件
3. **測試同步更新**: 如需要，同步更新相關測試檔案
4. **全套件驗證**: 確保所有測試都通過（綠燈狀態）

**🔵 Refactor 階段 (重構優化)**:
1. **程式碼品質提升**: 在測試通過前提下優化程式碼品質
2. **架構一致性**: 確保重構後的程式碼與整體架構一致
3. **效能驗證**: 確認重構沒有造成效能退化
4. **文件同步**: 同步更新相關技術文件

#### 📋 重構執行中的嚴格檢查點

**每次重構步驟後必須驗證**:

```bash
# 步驟 1: 基本功能驗證
npm test                # 必須 100% 通過
npm run test:unit       # 必須 100% 通過  
npm run test:integration # 必須 100% 通過

# 步驟 2: 程式碼品質檢查
npm run lint            # 必須通過，零警告容忍
npm run build           # 必須成功建置

# 步驟 3: 覆蓋率維持驗證
npm run test:coverage   # 覆蓋率不得低於重構前基準
```

#### ⚠️ 重構期間絕對禁止的行為

- ❌ **同時多個測試失敗**: 絕不允許同時有多個測試失敗
- ❌ **跳過測試驗證**: 每個重構步驟後都必須執行完整測試
- ❌ **延遲測試更新**: 程式碼重構必須同步更新對應測試
- ❌ **接受測試失敗**: 任何測試失敗都必須立即停止重構並修復
- ❌ **忽略整合測試**: 不能只跑單元測試，必須包含整合測試

#### ✅ 重構完成驗證標準

**重構完成檢查清單**:
- [ ] **單元測試**: 100% 通過，零失敗容忍
- [ ] **整合測試**: 100% 通過，所有整合點驗證
- [ ] **E2E 測試**: 100% 通過，端對端功能確認
- [ ] **測試覆蓋率**: 不低於重構前基準線
- [ ] **效能基準**: 重構後效能不低於重構前
- [ ] **功能回歸**: 所有既有功能完整保留
- [ ] **文件同步**: 所有相關文件已同步更新
- [ ] **架構一致性**: 符合專案整體架構模式

#### 🚨 重構中斷與恢復機制

**觸發中斷條件**:
- 任何測試套件失敗率超過 0%
- 重構步驟過大導致影響不可控
- 發現未預期的架構問題

**中斷後處理流程**:
1. **立即停止**: 停止所有重構活動
2. **狀態評估**: 分析當前系統狀態和問題原因
3. **回退選擇**: 決定回退到上一個穩定狀態或修復當前問題
4. **重新規劃**: 重新評估重構計劃，縮小重構範圍

#### 🎯 重構成功的關鍵要素

1. **測試是安全網**: 完善的測試覆蓋是重構成功的基礎
2. **小步漸進**: 每次只改變一小部分，降低風險
3. **持續驗證**: 每個步驟都要驗證系統仍處於已知狀態
4. **文件同步**: 重構和文件更新必須同步進行
5. **品質不妥協**: 絕不因進度壓力妥協測試完整性

## 📋 版本控制與合規自主管理

### 🔍 主線程自主合規原則

基於 Claude Code 最佳實踐，**主線程擁有完整實作上下文**，因此最適合執行合規檢查和文件更新，確保資訊準確性和即時同步。

#### 核心理念
- **第一手資訊**：基於實際實作過程進行檢查
- **即時同步**：開發過程中即時更新文件
- **完整上下文**：了解所有技術決策和問題解決過程
- **自我負責**：對工作品質承擔完全責任

### 🔄 TDD 循環整合合規檢查

#### 每個 TDD 階段後的合規檢查

**🔴 Red 階段後**：
```bash
npm test        # 確認新測試失敗
```
- [ ] 測試命名清晰，描述測試場景
- [ ] 測試確實失敗（紅燈狀態）
- [ ] 記錄測試設計的思考過程

**🟢 Green 階段後**：
```bash
npm test              # 確認所有測試通過
npm run test:coverage # 檢查測試覆蓋率
```
- [ ] 所有測試通過（綠燈狀態）
- [ ] 暫時實作已標註 `//todo:` 註記
- [ ] 記錄實作過程中的重要決策

**🔵 Refactor 階段後**：
```bash
npm test        # 確認重構後測試仍通過
npm run lint    # 確認程式碼品質
npm run build   # 確認建置成功
```
- [ ] 消除了所有 `//todo:` 標註的問題
- [ ] 程式碼符合專案編碼規範
- [ ] 記錄重構的原因和效果

### 每個 TDD 循環完成後必須執行以下步驟

#### 1. 完整合規檢查
```bash
# 執行完整檢查套件
npm test && npm run test:coverage && npm run lint && npm run build
```

**品質標準驗證**：
- [ ] 測試覆蓋率達到 100%
- [ ] 所有 linter 檢查通過
- [ ] 建置成功無錯誤
- [ ] 效能沒有明顯退化

#### 2. Git 操作驗證
```bash
git status      # 檢查變更狀態
git diff        # 確認變更內容
```

**變更驗證**：
- [ ] 變更範圍與功能描述一致
- [ ] 沒有不相關的程式碼變更
- [ ] 沒有敏感資訊洩漏

#### 3. 文件同步更新（主線程執行）

**必須更新的文件**：
1. **更新 `docs/todolist.md` 進度**
2. **更新工作日誌 `docs/work-logs/vX.X.X-work-log.md`**
3. **強制更新 `CHANGELOG.md`** 記錄小版本號 (v0.X.Y)

**文件品質標準**：
- [ ] 工作日誌反映真實開發過程
- [ ] 技術決策有清楚的理由說明
- [ ] 問題發現和解決過程詳細記錄
- [ ] 重構思路和效果有具體描述

#### 4. Git Commit 提交
```bash
git add .
git commit -m "$(cat <<'EOF'
[commit message here]

🤖 Generated with [Claude Code](https://claude.ai/code)

Co-Authored-By: Claude <noreply@anthropic.com>
EOF
)"
```

**Commit 品質標準**：
- [ ] 使用 Conventional Commits 格式
- [ ] 訊息清楚描述變更內容和原因
- [ ] 包含必要的 co-author 資訊

### 版本號管理規範

- **小版本號 (v0.X.Y)**: 對應每個 TDD 循環完成
- **中版本號 (v0.X.0)**: 對應主要功能模組完成
- **主版本號 (v1.0.0)**: 產品完整功能，準備上架
- **每個 TDD 循環必須對應一個小版本號記錄**

### 工作日誌管理規範

- **建立時機**: 每個中版本號變更時建立新的工作日誌檔案
- **檔案命名**: `docs/work-logs/vX.X.X-work-log.md`
- **更新頻率**: 每完成一個 TDD 循環或重要修復後立即更新

#### 工作日誌必須包含內容

- TDD 循環的完整 Red-Green-Refactor 過程
- **詳細的思考過程和決策邏輯**
- **問題發現過程**: 如何檢查到錯誤、錯誤症狀描述
- **問題原因分析**: 深入分析錯誤為什麼會發生、根本原因追溯
- **解決方案過程**: 解決方法的選擇、嘗試過程、最終方案
- **重構思路**: 原程式碼的不佳問題、優化思路、改善效果
- **架構決策與專案結構調整**
- **技術棧選擇與工具變更決策**
- **除錯過程**: 包含錯誤訊息、診斷步驟、修復驗證
- **效能優化**: 效能問題識別、分析方法、優化成果

## 📋 版本管理嚴格規範

### 🎯 版本確認檢查點

**任何版本相關工作前，必須先確認當前專案狀態**：

#### 必須檢查的檔案（按優先順序）：
1. **`docs/todolist.md`** - 查看「🎯 專案當前狀態」章節的版本號
2. **`CHANGELOG.md`** - 確認最新版本記錄 
3. **`package.json`** - 查看專案版本號
4. **最新工作日誌** - 在 `docs/work-logs/` 中找到最新的 `vX.X.X-work-log.md`

#### 版本類型明確區分：

**🎯 專案版本（數字版本號）**：
- **格式**: v0.9.x, v1.0.0（影響整個產品發布）
- **用途**: 實際的產品發布版本，面向使用者
- **範例**: v0.9.18, v1.0.0, v1.2.5

**🏗 架構版本（希臘字母）**：
- **格式**: α (Alpha), β (Beta), γ (Gamma), δ (Delta), ε (Epsilon), ζ (Zeta), η (Eta), θ (Theta)
- **用途**: 內部技術架構演進標記，不影響產品版本號
- **範例**: 事件系統架構-α, BookSearchFilter重構-β, Content模組化-γ
- **排序**: α → β → γ → δ → ε → ζ → η → θ → ι → κ → λ → μ

**🔧 功能版本（模組內部）**：
- **格式**: API v1.2, Engine v3.1（特定功能模組版本）
- **用途**: 模組內部版本追蹤，與專案版本無關

#### 版本號規則：
- **v0.9.x 階段**：重構和準備階段，為 v1.0 做準備
- **v1.0.0**：第一個正式發布版本
- **v1.x.x**：功能更新和改進
- **v2.0.0**：重大架構變更或突破性更新

#### 版本變更流程：
1. 確認當前版本號
2. 判斷變更類型（patch/minor/major）
3. 更新 CHANGELOG.md
4. 建立對應的工作日誌
5. 提交時使用正確的版本號

### 🎯 希臘字母架構版本命名系統

#### 核心原則
- **明確分離**: 架構版本與專案版本完全分離
- **循序漸進**: 按希臘字母順序標記架構演進
- **語意明確**: 每個希臘字母代表一個重大架構階段

#### 希臘字母對應表
```
α (Alpha)   - 初始架構設計或重大重構開始
β (Beta)    - 核心架構實現完成
γ (Gamma)   - 架構整合與優化
δ (Delta)   - 架構驗證與測試完善
ε (Epsilon) - 架構穩定與效能優化
ζ (Zeta)    - 架構擴展與彈性設計
η (Eta)     - 架構成熟與最佳化
θ (Theta)   - 架構完善與文件化
```

#### 命名格式範例
- **BookSearchFilter重構-β**: BookSearchFilter 模組重構的第二階段
- **事件系統架構-γ**: 事件驅動架構的第三次重大演進
- **Content模組化-δ**: Content Script 模組化的驗證階段

### ⚠️ 版本混淆防範機制

#### 絕對禁止的行為
- ❌ **將架構版本當作專案版本**: 不可將 "α, β, γ" 用於專案發布
- ❌ **跳過版本確認步驟**: 任何版本變更前必須確認當前狀態
- ❌ **版本號自動提升**: 不可未經確認自動提升大版本號
- ❌ **混合使用版本系統**: 同一文件中不可混用不同版本系統

#### 強制檢查機制
- ✅ **工作日誌強制標註**: 必須明確標註版本類型（專案/架構/功能）
- ✅ **TODO 更新前確認**: 更新 TODO 前必須確認當前專案版本
- ✅ **架構文件版本分離**: 架構文件使用希臘字母，工作日誌使用專案版本
- ✅ **Commit 訊息版本正確**: 提交訊息必須使用正確的版本號類型

## 📁 檔案管理嚴格規則

### 檔案操作原則

- **絕對不創建非必要的檔案**
- **優先編輯現有檔案而非創建新檔案**
- **永不主動創建文件檔案 (\*.md) 或 README 檔案**，除非使用者明確要求
- 臨時檔案和輔助腳本在任務完成後必須清理

## 🏗 架構債務管理與持續改善

### 永不放棄原則 - 架構問題及早修正策略

**核心原則**: 架構問題和設計債務是第一優先修正目標，絕不可「先將就」或「之後再處理」

#### 🚨 立即處理原則

1. **架構問題發現 = 立即修正**: 一旦識別出架構債務，立即停止功能開發，優先修正
2. **修復成本會指數增長**: 架構問題拖延修復的成本隨時間呈指數增長
3. **絕不妥協的品質標準**: 寧可延遲功能發布，也不允許技術債務累積
4. **根本原因必須徹底解決**: 不接受「暫時性修正」或「症狀緩解」

#### 🔍 架構債務識別標準

**高優先級架構債務**（必須立即修正）:

- 依賴注入不一致或缺失
- 測試困難或無法測試的程式碼
- 違反 SOLID 原則的設計
- 模組間高耦合或循環依賴
- 不一致的錯誤處理模式
- 缺乏適當的抽象層

**檢查觸發條件**:

- 任何測試失敗都必須深入分析根本原因
- 程式碼重複超過 3 次必須抽象化
- 函數超過 30 行必須考慮重構
- 模組責任不明確必須重新設計

#### 🛠 修正流程與標準

**Step 1: 問題分析**

- 建立詳細的債務分析文件 (`docs/architecture/`)
- 評估影響範圍和修復複雜度
- 制定具體的修復計劃和時程

**Step 2: TDD 驅動修正**

- 使用完整的 Red-Green-Refactor 循環
- 先寫測試驗證修正目標
- 實現最小可行的修正方案
- 重構確保程式碼品質

**Step 3: 架構一致性驗證**

- 檢查相同模式在其他組件的應用
- 統一整個專案的設計模式
- 建立防止類似問題的指導原則

#### 💡 品質標準與檢查點

**在任何程式碼被標記為「完成」之前，必須驗證**:

1. **測試覆蓋率達標**: 依「測試覆蓋率要求」章節的門檻
2. **零架構債務**: 沒有已知的設計缺陷或債務
3. **一致的模式**: 與專案其他部分設計模式一致
4. **完整的錯誤處理**: 所有可能的錯誤情況都有適當處理
5. **效能基準達標**: 符合或超越效能要求
6. **文件完整性**: 程式碼意圖和使用方式都有清楚文件

#### 🚨 絕對禁止的妥協行為

- ❌ **「先這樣，之後再改」**: 架構問題必須當下解決
- ❌ **「測試之後再寫」**: 違反 TDD 原則
- ❌ **「這個 bug 不影響功能」**: 所有已知問題都必須修復
- ❌ **「複製貼上這段程式碼」**: 重複程式碼必須立即重構
- ❌ **「暫時用 try-catch 包起來」**: 錯誤處理必須有明確策略

#### 📈 持續改善機制

**每完成一個 TDD 循環後檢查**:

- 是否引入新的技術債務？
- 現有設計模式是否一致？
- 測試覆蓋率是否維持或提升？
- 程式碼複雜度是否在可接受範圍？

**每週架構健康檢查**:

- 回顧本週解決的架構問題
- 識別潛在的設計風險
- 更新架構決策文件
- 規劃下週的改善重點

## 測試覆蓋率要求

- 所有測試類型覆蓋率必須達到 100%

## 📝 程式碼品質規範

### 架構設計原則

#### 1. 單一責任原則

- 每個函數、類別或模組只負責一個明確定義的功能
- 判斷責任範圍：如需用"和"或"或"描述功能，考慮拆分
- 建議函數長度不超過 30 行，超過則考慮重構

#### 2. 命名規範

- 使用描述性且有意義的名稱，清楚表明用途
- 函數名稱以動詞開頭 (如: calculateTotal, validateInput)
- 變數名稱使用名詞 (如: userProfile, paymentAmount)
- 布林變數使用 is, has, can 前綴 (如: isValid, hasPermission)

#### 3. 文件規範

- 每個函數、類別或模組都必須有註解描述其目的和功能
- 註解應解釋"為什麼"這樣實作，而不只是"做了什麼"
- 核心功能必須遵循標準化註解結構：
  - 簡短的功能目的描述
  - "負責功能："列出責任清單
  - "設計考量："說明實作決策
  - "處理流程："用數字步驟記錄流程
  - "使用情境："說明何時及如何呼叫此函數

### 程式碼撰寫規範

- 優先考慮可讀性和可維護性，而非過度最佳化
- 防禦性程式設計：驗證輸入參數，處理邊界情況和例外
- 必須立即修正明顯的 linter 錯誤
- 同一檔案的 linter 錯誤修正不超過 3 次循環

### 錯誤處理規範

- 清楚定義錯誤處理策略
- 使用有意義的錯誤訊息協助問題診斷
- 在適當層級處理例外，避免例外洩漏
- 記錄關鍵錯誤訊息供後續分析

### 程式碼風格

- 使用 ES6+ 語法
- 優先使用 const/let 而非 var
- 使用模組化匯入/匯出
- 遵循 JSDoc 註解規範

## 🎭 事件驅動架構規範

### 事件命名規範

- **格式**: `MODULE.ACTION.STATE`
- **範例**: `EXTRACTOR.DATA.EXTRACTED`、`STORAGE.SAVE.COMPLETED`、`UI.POPUP.OPENED`

### 事件優先級

- `URGENT` (0-99): 系統關鍵事件
- `HIGH` (100-199): 使用者互動事件
- `NORMAL` (200-299): 一般處理事件
- `LOW` (300-399): 背景處理事件

### 事件處理原則

- 每個模組通過事件總線通訊
- 避免直接模組間依賴
- 事件處理器必須有錯誤處理機制
- 實現事件的重試與降級機制

### 模組通訊方式

- Background ↔ Content Script: Chrome Runtime 訊息傳遞
- Background ↔ Popup: Chrome Extension APIs
- 內部模組: Event Bus 模式

## 🔄 上下文管理規範

#### 循環完成後上下文管理

每完成一個 TDD 循環後，必須：

1. **對話結束宣告**: 明確告知使用者 TDD 循環已完成
4. **新對話開始**: 使用者開始新對話進行下一個循環

文件記錄與版本提交請依「📋 版本控制強制要求」執行。

**技術實現方式**:

- 由於 Claude Code 沒有 `clear` 指令功能
- 透過明確的對話結束和新對話開始來達成上下文隔離
- 每個循環的程式碼設計必須獨立，不依賴上下文記憶

#### 獨立功能設計原則

每個 TDD 循環必須：

- **可獨立測試**: 不依賴其他模組的實作細節
- **明確邊界**: 清楚定義輸入輸出接口
- **領域隔離**: 符合 DDD 的有界上下文概念
- **事件解耦**: 透過事件系統與其他模組通訊

## 🌐 語言規範

**所有回應必須使用繁體中文 (zh-TW)**

- 產品使用者和開發者為台灣人，使用台灣特有的程式術語
- 程式碼中的中文註解和變數命名嚴格遵循台灣語言慣例
- 如不確定用詞，優先使用英文而非中國用語

## 🏗 Chrome Extension 特定要求

### Manifest V3 規範

- 嚴格遵循 Manifest V3 API
- 使用 Service Worker 而非 Background Pages
- 實現適當的權限請求策略

### 安全性要求

- 所有資料處理在本地進行
- 避免將敏感資料傳送到外部服務
- 實現適當的 CSP (Content Security Policy)
- 最小權限原則：只請求必要的權限

### 技術規格

- **測試框架**: Jest + Chrome Extension API Mocks
- **建置工具**: npm scripts
- **程式碼檢查**: ESLint
- **版本控制**: Git
- **無外部依賴**: 為了安全性和效能考量

## 🏗 專案概覽

這是一個基於 **Chrome Extension (Manifest V3)** 的 Readmoo 電子書平台資料提取和管理工具。專案嚴格遵循 **TDD (測試驅動開發)** 和 **事件驅動架構**。

### 核心架構原則

1. **事件驅動架構**: 所有模組通過中央化事件系統通訊
2. **單一責任原則**: 每個模組、處理器和組件只有一個明確目的
3. **TDD 優先**: 所有程式碼必須先寫測試，使用 Red-Green-Refactor 循環
4. **Chrome Extension 最佳實踐**: 遵循 Manifest V3 規範

### 主要組件

- **Background Service Worker** (`src/background/`): 處理擴展生命週期和跨上下文事件
- **Content Scripts** (`src/content/`): 從 Readmoo 頁面提取資料
- **Popup 界面** (`src/popup/`): 主要使用者互動界面
- **儲存系統** (`src/storage/`): 管理資料持久化，支援多種適配器
- **事件系統** (`src/core/`): 模組通訊的中央事件總線

### 專案結構

```
src/
├── background/         # Service Worker 和背景事件
├── content/           # Readmoo 頁面的 Content Scripts
├── popup/             # 擴展 Popup 界面
├── storage/           # 資料持久化層
│   ├── adapters/      # 儲存適配器 (Chrome, Local, IndexedDB)
│   └── handlers/      # 儲存事件處理器
├── core/              # 核心事件系統
└── extractors/        # 資料提取邏輯

tests/
├── unit/              # 單元測試
├── integration/       # 整合測試
└── e2e/               # 端對端測試

docs/
├── architecture/      # 架構設計文件
├── work-logs/         # 開發工作日誌
├── todolist.md        # 任務追蹤清單
└── struct.md          # 完整專案結構
```

## 🤖 Agent 協作規範

根據 Claude Code sub-agent 最佳實踐，本專案採用**文件先行的研究規劃模式**，所有 sub-agent 均為純研究員和規劃者，主線程負責所有實際實作工作。

### 📋 核心設計原則

#### Sub-agent 最佳實踐應用
- **純研究規劃角色**: Sub-agent 專注於分析現有程式碼庫，提出實作計劃，絕不執行實際實作
- **上下文優化**: 透過檔案系統管理上下文，避免大量 token 消耗和上下文壓縮問題
- **主線程實作**: 所有程式碼修改、測試執行、檔案建立均由主線程執行，確保完整上下文

#### 工作流程模式
1. **主線程建立專案上下文檔案** (`docs/context/session_contexts/`)
2. **委派任務給專業 sub-agent 進行研究規劃**
3. **Sub-agent 閱讀上下文，產出詳細實作計劃** (`docs/context/agent_plans/`)
4. **主線程閱讀計劃並執行所有實際實作工作**
5. **更新上下文檔案，記錄進度和決策**

### 🎯 Sub-agent 角色定位

#### 專案管理規劃層級

- **rosemary-project-manager** (📋): 策略規劃研究專家
  - **核心職責**: 專案策略研究、任務分解規劃、風險分析和時程規劃
  - **研究範圍**: 分析專案需求、制定工作分派策略、設計敏捷升級機制
  - **輸出成果**: 專案規劃文件、任務分解計劃、里程碑設計
  - **絕不執行**: 不進行任何實際的任務分配或專案執行

- **project-compliance-agent**: 合規檢查研究專家
  - **核心職責**: 合規標準研究、檢查流程設計、版本控制規範分析
  - **研究範圍**: 分析合規要求、設計檢查流程、規劃文件更新策略
  - **輸出成果**: 合規檢查計劃、版本控制流程設計、品質保證策略
  - **絕不執行**: 不進行實際的合規檢查或版本控制操作

#### 測試策略規劃層級

- **sage-test-architect** (🔴): 測試策略設計專家
  - **核心職責**: 測試架構研究、測試策略設計、測試覆蓋率規劃
  - **研究範圍**: 分析測試需求、設計測試架構、規劃單元測試和組件測試策略
  - **輸出成果**: 測試設計文件、測試架構規劃、測試覆蓋策略
  - **絕不執行**: 不撰寫實際測試程式碼或執行測試

- **coriander-integration-tester**: 整合測試策略專家
  - **核心職責**: 整合測試策略研究、E2E 測試規劃、系統測試設計
  - **研究範圍**: 分析整合點、設計測試場景、規劃系統層級測試
  - **輸出成果**: 整合測試計劃、E2E 測試策略、系統測試規範
  - **絕不執行**: 不實作或執行任何測試程式碼

#### UI/UX 設計規劃層級

- **lavender-interface-designer**: UI/UX 策略設計專家
  - **核心職責**: 使用者體驗研究、介面設計策略、設計規範制定
  - **研究範圍**: 分析使用者需求、設計互動流程、規劃視覺設計標準
  - **輸出成果**: UI/UX 設計規範、使用者體驗策略、設計系統文件
  - **絕不執行**: 不進行任何實際的 UI 實作或程式碼撰寫

#### 專業技術規劃層級

- **basil-event-architect**: 事件驅動架構規劃專家
  - **核心職責**: 事件系統架構研究、模組通訊設計、架構模式規劃
  - **研究範圍**: 分析現有架構、設計事件流程、規劃模組通訊協議
  - **輸出成果**: 事件架構設計文件、通訊協議規範、架構實作計劃
  - **絕不執行**: 不修改任何程式碼或實作事件系統

- **oregano-data-miner**: 資料提取策略研究專家
  - **核心職責**: 資料提取策略研究、DOM 分析規劃、資料處理流程設計
  - **研究範圍**: 分析目標網站結構、設計提取策略、規劃資料處理流程
  - **輸出成果**: 資料提取計劃、DOM 分析報告、處理流程設計
  - **絕不執行**: 不執行實際的資料提取或網頁爬蟲工作

- **ginger-performance-tuner**: 效能優化策略專家
  - **核心職責**: 效能分析研究、優化策略設計、效能監控規劃
  - **研究範圍**: 分析效能瓶頸、設計優化方案、規劃監控策略
  - **輸出成果**: 效能分析報告、優化實作計劃、監控策略設計
  - **絕不執行**: 不進行實際的程式碼優化或效能調整

#### Agent 使用原則與觸發機制

**核心原則**:

1. **100%責任制**: 每個代理人對其工作範圍負100%責任，不允許責任空隙
2. **敏捷升級機制**: 當技術困難無法突破時，必須升級給PM重新拆分任務
3. **明確職責邊界**: 避免職責重疊，建立清楚的協作和交接協議
4. **品質保證優先**: 代理人確保各階段品質標準，不得因困難而降低標準

**敏捷升級機制統一原則**:

所有代理人都必須遵循以下升級流程：
- **3次嘗試限制**: 同一問題超過3次嘗試仍無法解決時必須升級
- **工作日誌記錄**: 詳細記錄嘗試方案、失敗原因、問題複雜度
- **立即升級**: 停止無效嘗試，將問題拋回給 rosemary-project-manager
- **重新分配**: 等待PM重新拆分任務為更小、更可行的單元

**專案管理層級觸發條件**:

- **rosemary-project-manager**: 
  - 開始新開發任務或重構專案時（策略規劃階段）
  - 代理人工作升級時（任務重新拆分處理）
  - 文件先行策略監督執行時
  - 多個Agent需要協調合作時
  - 專案進度風險管理時

- **project-compliance-agent**: 
  - 完成任何小功能或TDD循環後（執行合規檢查）
  - 版本控制和文件更新驗證時
  - 在 rosemary-project-manager 指導下進行操作合規

**TDD核心代理人觸發條件（測試領域分離）**:

- **sage-test-architect**: 
  - 開始新功能開發需要單元測試設計時
  - 組件層級測試覆蓋不足時
  - TDD Red階段測試案例設計時

- **pepper-test-implementer**: 
  - sage-test-architect 測試設計完成且處於失敗狀態時
  - 需要實現讓測試100%通過的最小程式碼時

- **cinnamon-refactor-owl**: 
  - pepper-test-implementer 完成且所有測試通過後
  - 程式碼品質需要100%改善時

- **coriander-integration-tester**: 
  - 單元測試階段完成後進行系統層級測試時
  - 需要端對端測試和系統整合驗證時

**UI/UX設計實現領域觸發條件（設計實現分離）**:

- **lavender-interface-designer**: 
  - 需要UI/UX設計策略和使用者體驗規劃時
  - 設計規範和界面標準制定時

### 🔄 主線程實作整合規範

#### TDD 完整循環實作（主線程執行）

**🔴 Red 階段（主線程責任）**：
- 閱讀 sage-test-architect 提供的測試設計規劃
- 實作測試程式碼，確認測試失敗
- **實作品質要求**: 測試必須明確、具體、可驗證

**🟢 Green 階段（主線程責任）**：
- 實作最小可用程式碼讓測試通過
- **100% 測試通過要求**: 不允許任何測試失敗
- **最小實作原則**: 只寫剛好讓測試通過的程式碼
- **權宜實作允許**: 可使用暫時方案但須 `//todo:` 標註改善方向

**🔵 Refactor 階段（主線程責任）**：
- 在保持測試通過前提下優化程式碼
- **100% 重構完成**: 不允許任何已識別問題未解決
- **程式碼品質提升**: 改善可讀性、可維護性、效能
- **架構改善**: 解決技術債務、統一設計模式

#### Chrome Extension 實作規範（主線程執行）

**Manifest V3 嚴格合規**：
- 所有 API 使用必須符合 Manifest V3 規範
- Service Worker 模式而非 Background Pages
- 適當的權限請求策略

**安全性實作要求**：
- 最小權限原則：只請求必要權限
- 本地資料處理：避免外部服務傳輸
- CSP 合規：實作適當的內容安全政策

**設計規範實作**：
- 100% 實現 lavender-interface-designer 設計規範
- 遵循既定的 UI/UX 標準
- 保持設計一致性和使用者體驗

### 📁 上下文管理機制

#### 檔案系統上下文管理
- **上下文檔案**: `docs/context/session_contexts/context_session_X.md`
- **Agent 規劃**: `docs/context/agent_plans/[類別]/[檔案名稱].md`
- **標準模板**: `docs/context/templates/` 提供統一格式

#### Agent 工作流程
1. **開始前**: 閱讀最新的專案上下文檔案
2. **研究階段**: 深入分析程式碼庫和需求
3. **規劃階段**: 制定詳細的實作計劃
4. **輸出階段**: 建立規劃文件並更新上下文
5. **回報階段**: 使用標準格式通知主線程

#### 標準輸出格式
所有 sub-agent 必須使用統一的輸出格式（詳見 `docs/context/agent_output_standards.md`）：

```
我已經完成 [任務名稱] 的 [工作類型] 規劃工作。

📋 **規劃檔案**: `docs/context/agent_plans/[類別]/[檔案名稱].md`
🔄 **上下文更新**: 已更新專案上下文檔案
🔍 **主要發現**: [重要發現簡要總結]
🎯 **建議行動**: [對主線程的具體建議]

請在繼續實作前先閱讀規劃檔案。
```

### ⚠️ 嚴格禁止事項

#### Sub-agent 絕對禁止行為
- ❌ **實作程式碼**: 不得修改、建立或刪除任何程式碼檔案
- ❌ **執行測試**: 不得運行任何測試指令或驗證程式碼
- ❌ **檔案操作**: 不得建立非規劃文件的任何檔案
- ❌ **工具執行**: 不得呼叫實作相關的開發工具

#### 主線程必須負責
- ✅ **所有程式碼實作**: 包括測試、功能、重構
- ✅ **檔案系統操作**: 建立、修改、刪除程式碼檔案
- ✅ **測試執行**: 運行測試套件、驗證功能
- ✅ **工具執行**: 使用 linter、builder、部署工具
- ✅ **除錯和問題解決**: 處理所有技術問題

### 🎯 協作成功關鍵

#### 高效協作要求
- **詳細規劃**: Sub-agent 必須提供足夠詳細的實作計劃
- **即時溝通**: 透過上下文檔案保持資訊同步
- **品質保證**: 主線程嚴格按照規劃執行實作
- **持續改進**: 從每次協作中學習並優化流程

#### 升級處理機制
- **3次嘗試限制**: 同一問題超過3次無法解決時升級
- **詳細記錄**: 在工作日誌記錄嘗試和失敗原因
- **任務重新分解**: PM 重新拆分為更小可行單元
- **循環消化**: 確保所有工作最終完成

## 🔧 開發工具和指令

### 測試指令

```bash
# 執行所有測試
npm test

# 監視模式執行測試
npm run test:watch

# 執行特定類型測試
npm run test:unit
npm run test:integration
npm run test:e2e

# 執行測試並產生覆蓋率報告
npm run test:coverage
```

### 建置指令

```bash
# 安裝依賴項 (注意：使用 --legacy-peer-deps)
npm install --legacy-peer-deps

# 開發版本建置
npm run build:dev

# 生產版本建置
npm run build:prod

# 啟動開發工作流程 (建置 + 監視測試)
npm run dev
```

### 程式碼品質指令

```bash
# 執行程式碼檢查
npm run lint

# 自動修正程式碼檢查問題
npm run lint:fix

# 清理建置產物
npm run clean
```

## 📊 任務追蹤管理

### 任務管理

- 所有任務記錄在 `docs/todolist.md`
- 使用圖例追蹤進度：⭕ 待開始、🔴 紅燈、🟢 綠燈、🔵 重構、✅ 完成
- 每完成一個 TDD 循環立即更新狀態

### 里程碑追蹤

- v0.0.x: 基礎架構與測試框架
- v0.x.x: 開發階段，逐步實現功能
- v1.0.0: 完整功能，準備上架 Chrome Web Store

## 📚 重要文件參考

- `docs/architecture/event-system.md` - 詳細事件系統設計
- `docs/struct.md` - 完整專案結構說明
- `docs/todolist.md` - 開發任務追蹤
- `docs/work-logs/` - 詳細開發工作日誌
- `.cursorrules` - 完整開發規則 (此為規範來源)
- `CHANGELOG.md` - 版本變更記錄
