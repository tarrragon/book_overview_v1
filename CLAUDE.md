# CLAUDE.md

本文件為 Claude Code (claude.ai/code) 在此專案中的開發指導規範。

## 🚨 絕對不可違反的核心規則

1. **架構債務零容忍**: 一旦發現架構問題，立即停止功能開發，優先修正，絕不妥協
2. **永不放棄原則**: 複雜問題不得用 "sorry" 或 "暫時處理" 解決，必須找到根本解法
3. **絕對遵循 TDD**: 沒有測試就不寫程式碼，Red-Green-Refactor 循環不可跳步
4. **保持測試通過**: 任何時候都不能讓測試套件失敗，100% 通過率是最低標準
5. **完整執行流程**: 所有任務必須遵循標準工作執行流程，至少達到 90% 完成度
6. **工作品質要求**: 深入分析問題根因、應用系統化方法、詳細記錄思考過程
7. **文件同步更新**: 程式碼變更後立即更新相關文件，包括工作日誌和版本記錄，然後確實無論大階段或者小步驟的更新都應該提交 commit，不可節省
8. **繁體中文**: 所有溝通和文件使用台灣繁體中文，技術術語遵循台灣慣例

## 🚨 核心執行準則

**所有任務執行都必須遵循以下完整執行流程，確保工作品質和完成度**

### 標準工作執行流程

#### 1. 問題理解階段 (必須完成)

- 完整理解任務需求和技術限制
- 識別所有相關的技術要素和依賴關係
- 尋找現有程式碼中的相似實作模式
- 將複雜任務分解成具體可執行的工作項目

#### 2. 方案設計階段 (必須完成)

- 設計解決方案的整體架構
- 確定實作的優先順序和執行順序
- 建立可驗證的中間成果檢查點
- 準備必要的工具和資源

#### 3. 執行實作階段

- 按照設計方案執行具體工作
- 遇到技術問題時使用基本方法先建立可用版本
- 記錄實作過程中的決策和遇到的問題
- 建立必要的輔助功能來支援主要功能

#### 4. 完善優化階段 (在核心功能完成後執行)

- 完善技術實作細節
- 尋找和應用最佳實務
- 處理邊界情況和錯誤處理
- 優化性能和使用者體驗

### 執行品質要求

- **最低完成度**：每個任務必須達到 80%功能完整度
- **文件記錄**：記錄工作過程、決策理由和遭遇的問題
- **解決方案導向**：提供具體可用的解決方案，而非抽象說明
- **持續改進**：從每次執行中學習並改進工作方法

### 工作流程合規要求

- 不得因技術複雜度而跳過必要的工作階段
- 不得在未完成基本功能的情況下結束任務
- 必須提供足夠詳細的工作記錄以便後續維護
- 需要協助時必須已完成大部分基礎工作

### TDD 循環完成後的標準流程

此流程統一由「📋 版本控制強制要求」章節規範，避免重複。

## 🧪 TDD (測試驅動開發) 嚴格要求

### ❗ 絕對不可違反的 TDD 規則

1. **絕對不能在沒有測試的情況下寫程式碼**
2. **每次只實現讓測試通過的最小程式碼**
3. **重構時必須保持所有測試通過**
4. **定期執行完整測試套件**

### Red-Green-Refactor 循環

- **🔴 紅燈**: 必須先寫測試，確認測試失敗
- **🟢 綠燈**: 實現最小可用程式碼讓測試通過
- **🔵 重構**: 優化程式碼，保持所有測試通過

## 📋 版本控制強制要求

### 每個小功能完成後必須執行以下步驟

1. **更新 `docs/todolist.md` 進度**
2. **更新工作日誌 `docs/work-logs/vX.X.X-work-log.md`**
3. **強制更新 `CHANGELOG.md`** 記錄小版本號 (v0.X.Y)
4. **提交 git commit** (使用 Conventional Commits 格式)

### 版本號管理規範

- **小版本號 (v0.X.Y)**: 對應每個 TDD 循環完成
- **中版本號 (v0.X.0)**: 對應主要功能模組完成
- **主版本號 (v1.0.0)**: 產品完整功能，準備上架
- **每個 TDD 循環必須對應一個小版本號記錄**

### 工作日誌管理規範

- **建立時機**: 每個中版本號變更時建立新的工作日誌檔案
- **檔案命名**: `docs/work-logs/vX.X.X-work-log.md`
- **更新頻率**: 每完成一個 TDD 循環或重要修復後立即更新

#### 工作日誌必須包含內容

- TDD 循環的完整 Red-Green-Refactor 過程
- **詳細的思考過程和決策邏輯**
- **問題發現過程**: 如何檢查到錯誤、錯誤症狀描述
- **問題原因分析**: 深入分析錯誤為什麼會發生、根本原因追溯
- **解決方案過程**: 解決方法的選擇、嘗試過程、最終方案
- **重構思路**: 原程式碼的不佳問題、優化思路、改善效果
- **架構決策與專案結構調整**
- **技術棧選擇與工具變更決策**
- **除錯過程**: 包含錯誤訊息、診斷步驟、修復驗證
- **效能優化**: 效能問題識別、分析方法、優化成果

## 📁 檔案管理嚴格規則

### 檔案操作原則

- **絕對不創建非必要的檔案**
- **優先編輯現有檔案而非創建新檔案**
- **永不主動創建文件檔案 (\*.md) 或 README 檔案**，除非使用者明確要求
- 臨時檔案和輔助腳本在任務完成後必須清理

## 🏗 架構債務管理與持續改善

### 永不放棄原則 - 架構問題及早修正策略

**核心原則**: 架構問題和設計債務是第一優先修正目標，絕不可「先將就」或「之後再處理」

#### 🚨 立即處理原則

1. **架構問題發現 = 立即修正**: 一旦識別出架構債務，立即停止功能開發，優先修正
2. **修復成本會指數增長**: 架構問題拖延修復的成本隨時間呈指數增長
3. **絕不妥協的品質標準**: 寧可延遲功能發布，也不允許技術債務累積
4. **根本原因必須徹底解決**: 不接受「暫時性修正」或「症狀緩解」

#### 🔍 架構債務識別標準

**高優先級架構債務**（必須立即修正）:

- 依賴注入不一致或缺失
- 測試困難或無法測試的程式碼
- 違反 SOLID 原則的設計
- 模組間高耦合或循環依賴
- 不一致的錯誤處理模式
- 缺乏適當的抽象層

**檢查觸發條件**:

- 任何測試失敗都必須深入分析根本原因
- 程式碼重複超過 3 次必須抽象化
- 函數超過 30 行必須考慮重構
- 模組責任不明確必須重新設計

#### 🛠 修正流程與標準

**Step 1: 問題分析**

- 建立詳細的債務分析文件 (`docs/architecture/`)
- 評估影響範圍和修復複雜度
- 制定具體的修復計劃和時程

**Step 2: TDD 驅動修正**

- 使用完整的 Red-Green-Refactor 循環
- 先寫測試驗證修正目標
- 實現最小可行的修正方案
- 重構確保程式碼品質

**Step 3: 架構一致性驗證**

- 檢查相同模式在其他組件的應用
- 統一整個專案的設計模式
- 建立防止類似問題的指導原則

#### 💡 品質標準與檢查點

**在任何程式碼被標記為「完成」之前，必須驗證**:

1. **測試覆蓋率達標**: 依「測試覆蓋率要求」章節的門檻
2. **零架構債務**: 沒有已知的設計缺陷或債務
3. **一致的模式**: 與專案其他部分設計模式一致
4. **完整的錯誤處理**: 所有可能的錯誤情況都有適當處理
5. **效能基準達標**: 符合或超越效能要求
6. **文件完整性**: 程式碼意圖和使用方式都有清楚文件

#### 🚨 絕對禁止的妥協行為

- ❌ **「先這樣，之後再改」**: 架構問題必須當下解決
- ❌ **「測試之後再寫」**: 違反 TDD 原則
- ❌ **「這個 bug 不影響功能」**: 所有已知問題都必須修復
- ❌ **「複製貼上這段程式碼」**: 重複程式碼必須立即重構
- ❌ **「暫時用 try-catch 包起來」**: 錯誤處理必須有明確策略

#### 📈 持續改善機制

**每完成一個 TDD 循環後檢查**:

- 是否引入新的技術債務？
- 現有設計模式是否一致？
- 測試覆蓋率是否維持或提升？
- 程式碼複雜度是否在可接受範圍？

**每週架構健康檢查**:

- 回顧本週解決的架構問題
- 識別潛在的設計風險
- 更新架構決策文件
- 規劃下週的改善重點

## 測試覆蓋率要求

- 單元測試覆蓋率 ≥ 90%
- 整合測試覆蓋率 ≥ 80%
- 端對端測試覆蓋率 ≥ 70%

## 📝 程式碼品質規範

### 架構設計原則

#### 1. 單一責任原則

- 每個函數、類別或模組只負責一個明確定義的功能
- 判斷責任範圍：如需用"和"或"或"描述功能，考慮拆分
- 建議函數長度不超過 30 行，超過則考慮重構

#### 2. 命名規範

- 使用描述性且有意義的名稱，清楚表明用途
- 函數名稱以動詞開頭 (如: calculateTotal, validateInput)
- 變數名稱使用名詞 (如: userProfile, paymentAmount)
- 布林變數使用 is, has, can 前綴 (如: isValid, hasPermission)

#### 3. 文件規範

- 每個函數、類別或模組都必須有註解描述其目的和功能
- 註解應解釋"為什麼"這樣實作，而不只是"做了什麼"
- 核心功能必須遵循標準化註解結構：
  - 簡短的功能目的描述
  - "負責功能："列出責任清單
  - "設計考量："說明實作決策
  - "處理流程："用數字步驟記錄流程
  - "使用情境："說明何時及如何呼叫此函數

### 程式碼撰寫規範

- 優先考慮可讀性和可維護性，而非過度最佳化
- 防禦性程式設計：驗證輸入參數，處理邊界情況和例外
- 必須立即修正明顯的 linter 錯誤
- 同一檔案的 linter 錯誤修正不超過 3 次循環

### 錯誤處理規範

- 清楚定義錯誤處理策略
- 使用有意義的錯誤訊息協助問題診斷
- 在適當層級處理例外，避免例外洩漏
- 記錄關鍵錯誤訊息供後續分析

### 程式碼風格

- 使用 ES6+ 語法
- 優先使用 const/let 而非 var
- 使用模組化匯入/匯出
- 遵循 JSDoc 註解規範

## 🎭 事件驅動架構規範

### 事件命名規範

- **格式**: `MODULE.ACTION.STATE`
- **範例**: `EXTRACTOR.DATA.EXTRACTED`、`STORAGE.SAVE.COMPLETED`、`UI.POPUP.OPENED`

### 事件優先級

- `URGENT` (0-99): 系統關鍵事件
- `HIGH` (100-199): 使用者互動事件
- `NORMAL` (200-299): 一般處理事件
- `LOW` (300-399): 背景處理事件

### 事件處理原則

- 每個模組通過事件總線通訊
- 避免直接模組間依賴
- 事件處理器必須有錯誤處理機制
- 實現事件的重試與降級機制

### 模組通訊方式

- Background ↔ Content Script: Chrome Runtime 訊息傳遞
- Background ↔ Popup: Chrome Extension APIs
- 內部模組: Event Bus 模式

## 🔄 上下文管理規範

#### 循環完成後上下文管理

每完成一個 TDD 循環後，必須：

1. **對話結束宣告**: 明確告知使用者 TDD 循環已完成
4. **新對話開始**: 使用者開始新對話進行下一個循環

文件記錄與版本提交請依「📋 版本控制強制要求」執行。

**技術實現方式**:

- 由於 Claude Code 沒有 `clear` 指令功能
- 透過明確的對話結束和新對話開始來達成上下文隔離
- 每個循環的程式碼設計必須獨立，不依賴上下文記憶

#### 獨立功能設計原則

每個 TDD 循環必須：

- **可獨立測試**: 不依賴其他模組的實作細節
- **明確邊界**: 清楚定義輸入輸出接口
- **領域隔離**: 符合 DDD 的有界上下文概念
- **事件解耦**: 透過事件系統與其他模組通訊

## 🌐 語言規範

**所有回應必須使用繁體中文 (zh-TW)**

- 產品使用者和開發者為台灣人，使用台灣特有的程式術語
- 程式碼中的中文註解和變數命名嚴格遵循台灣語言慣例
- 如不確定用詞，優先使用英文而非中國用語

## 🏗 Chrome Extension 特定要求

### Manifest V3 規範

- 嚴格遵循 Manifest V3 API
- 使用 Service Worker 而非 Background Pages
- 實現適當的權限請求策略

### 安全性要求

- 所有資料處理在本地進行
- 避免將敏感資料傳送到外部服務
- 實現適當的 CSP (Content Security Policy)
- 最小權限原則：只請求必要的權限

### 技術規格

- **測試框架**: Jest + Chrome Extension API Mocks
- **建置工具**: npm scripts
- **程式碼檢查**: ESLint
- **版本控制**: Git
- **無外部依賴**: 為了安全性和效能考量

## 🏗 專案概覽

這是一個基於 **Chrome Extension (Manifest V3)** 的 Readmoo 電子書平台資料提取和管理工具。專案嚴格遵循 **TDD (測試驅動開發)** 和 **事件驅動架構**。

### 核心架構原則

1. **事件驅動架構**: 所有模組通過中央化事件系統通訊
2. **單一責任原則**: 每個模組、處理器和組件只有一個明確目的
3. **TDD 優先**: 所有程式碼必須先寫測試，使用 Red-Green-Refactor 循環
4. **Chrome Extension 最佳實踐**: 遵循 Manifest V3 規範

### 主要組件

- **Background Service Worker** (`src/background/`): 處理擴展生命週期和跨上下文事件
- **Content Scripts** (`src/content/`): 從 Readmoo 頁面提取資料
- **Popup 界面** (`src/popup/`): 主要使用者互動界面
- **儲存系統** (`src/storage/`): 管理資料持久化，支援多種適配器
- **事件系統** (`src/core/`): 模組通訊的中央事件總線

### 專案結構

```
src/
├── background/         # Service Worker 和背景事件
├── content/           # Readmoo 頁面的 Content Scripts
├── popup/             # 擴展 Popup 界面
├── storage/           # 資料持久化層
│   ├── adapters/      # 儲存適配器 (Chrome, Local, IndexedDB)
│   └── handlers/      # 儲存事件處理器
├── core/              # 核心事件系統
└── extractors/        # 資料提取邏輯

tests/
├── unit/              # 單元測試
├── integration/       # 整合測試
└── e2e/               # 端對端測試

docs/
├── architecture/      # 架構設計文件
├── work-logs/         # 開發工作日誌
├── todolist.md        # 任務追蹤清單
└── struct.md          # 完整專案結構
```

## 🤖 Agent 協作規範

本專案使用多個專業代理人來確保開發品質：

#### TDD 核心代理人

- **sage-test-architect** (🔴): Red 階段測試設計專家
- **pepper-test-implementer** (🟢): Green 階段實現專家
- **cinnamon-refactor-owl** (🔵): Refactor 階段重構專家

#### 專業領域代理人

- **project-compliance-agent**: 版本控制和工作流程合規性
- **basil-event-architect**: 事件驅動架構設計
- **thyme-extension-engineer**: Chrome Extension 開發專家
- **lavender-interface-designer**: UI/UX 設計專家
- **oregano-data-miner**: 資料提取專家
- **ginger-performance-tuner**: 性能優化專家
- **coriander-integration-tester**: 整合測試專家

#### Agent 使用原則與觸發機制

**核心原則**:

1. **明確觸發**: 每個代理人都有具體的觸發條件和時機
2. **專業分工**: 每個代理人專注於特定領域，避免職責重疊
3. **品質保證**: 代理人確保各階段品質標準
4. **流程合規**: project-compliance-agent 強制執行工作流程

**TDD 核心代理人觸發條件**:

- **sage-test-architect**:
  - 開始新功能開發時
  - 需要設計測試案例時
  - 測試覆蓋率不足時
- **pepper-test-implementer**:
  - 測試已設計完成且處於失敗狀態
  - 需要實現讓測試通過的最小程式碼時
- **cinnamon-refactor-owl**:
  - 所有測試通過後進行重構時
  - 程式碼品質需要改善時

**專業領域代理人觸發條件**:

- **project-compliance-agent**: 完成任何小功能或 TDD 循環後
- **basil-event-architect**: 設計或修改事件系統時
- **thyme-extension-engineer**: Chrome Extension 相關技術問題時
- **lavender-interface-designer**: UI/UX 設計和使用者體驗問題時
- **oregano-data-miner**: 資料提取和處理問題時
- **ginger-performance-tuner**: 效能分析和優化需求時
- **coriander-integration-tester**: 整合測試和端對端測試時

## 🔧 開發工具和指令

### 測試指令

```bash
# 執行所有測試
npm test

# 監視模式執行測試
npm run test:watch

# 執行特定類型測試
npm run test:unit
npm run test:integration
npm run test:e2e

# 執行測試並產生覆蓋率報告
npm run test:coverage
```

### 建置指令

```bash
# 安裝依賴項 (注意：使用 --legacy-peer-deps)
npm install --legacy-peer-deps

# 開發版本建置
npm run build:dev

# 生產版本建置
npm run build:prod

# 啟動開發工作流程 (建置 + 監視測試)
npm run dev
```

### 程式碼品質指令

```bash
# 執行程式碼檢查
npm run lint

# 自動修正程式碼檢查問題
npm run lint:fix

# 清理建置產物
npm run clean
```

## 📊 任務追蹤管理

### 任務管理

- 所有任務記錄在 `docs/todolist.md`
- 使用圖例追蹤進度：⭕ 待開始、🔴 紅燈、🟢 綠燈、🔵 重構、✅ 完成
- 每完成一個 TDD 循環立即更新狀態

### 里程碑追蹤

- v0.0.x: 基礎架構與測試框架
- v0.x.x: 開發階段，逐步實現功能
- v1.0.0: 完整功能，準備上架 Chrome Web Store

## 📚 重要文件參考

- `docs/architecture/event-system.md` - 詳細事件系統設計
- `docs/struct.md` - 完整專案結構說明
- `docs/todolist.md` - 開發任務追蹤
- `docs/work-logs/` - 詳細開發工作日誌
- `.cursorrules` - 完整開發規則 (此為規範來源)
- `CHANGELOG.md` - 版本變更記錄
