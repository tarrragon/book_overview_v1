# CLAUDE.md

本文件為 Claude Code (claude.ai/code) 在此專案中的開發指導規範。

## 🚨 絕對不可違反的核心規則

1. **架構債務零容忍**: 一旦發現架構問題，立即停止功能開發，優先修正，絕不妥協
2. **永不放棄原則**: 複雜問題不得用 "sorry" 或 "暫時處理" 解決，必須找到根本解法
3. **絕對遵循 TDD**: 沒有測試就不寫程式碼，Red-Green-Refactor 循環不可跳步
4. **保持測試通過**: 任何時候都不能讓測試套件失敗，100% 通過率是最低標準
5. **最低完成策略**: 以可用為目標，允許權宜實作，但必須以 `//todo:` 註記後續重構方向
6. **工作品質要求**: 深入分析問題根因、應用系統化方法、詳細記錄思考過程
7. **文件同步更新**: 程式碼變更後立即更新相關文件，包括工作日誌和版本記錄，然後確實無論大階段或者小步驟的更新都應該提交 commit，不可節省
8. **繁體中文**: 所有溝通和文件使用台灣繁體中文，技術術語遵循台灣慣例
9. **版本管理嚴格要求**: 必須明確區分專案版本與架構版本，任何版本變更前必須確認當前版本狀態

## 🚨 核心執行準則

**所有任務執行都必須遵循以下完整執行流程，確保工作品質和完成度**

### 標準工作執行流程

#### 1. 問題理解階段 (必須完成)

- 完整理解任務需求和技術限制
- 識別所有相關的技術要素和依賴關係
- 尋找現有程式碼中的相似實作模式
- 將複雜任務分解成具體可執行的工作項目

#### 2. 方案設計階段 (必須完成)

- 設計解決方案的整體架構
- 確定實作的優先順序和執行順序
- 建立可驗證的中間成果檢查點
- 準備必要的工具和資源
- **文件先行**：必須先撰寫設計文件、架構規範、API 接口定義後才開始實作

#### 3. 文件撰寫階段 (必須在實作前完成)

- 撰寫詳細的技術設計文件
- 定義明確的 API 接口和資料結構
- 建立架構決策記錄（ADR）
- 撰寫重構計劃和風險評估文件
- 更新相關的工作日誌作為站立會議記錄
- **文件驗證**：確保設計方案可行且符合既有架構

#### 4. 執行實作階段

- 按照設計文件執行具體工作
- 遇到技術問題時使用基本方法先建立可用版本
- 在必要時可先以權宜實作完成功能，但必須於相關程式碼以 `//todo:` 註記後續重構方向
- 記錄實作過程中的決策和遇到的問題
- 建立必要的輔助功能來支援主要功能
- **嚴禁**在沒有設計文件的情況下開始編碼

#### 5. 完善優化階段 (在核心功能完成後執行)

- 完善技術實作細節
- 尋找和應用最佳實務
- 處理邊界情況和錯誤處理
- 優化性能和使用者體驗

### 執行品質要求

- **最低完成策略**：允許以暫時較差的架構或設計先讓功能可用；所有已知的架構/設計問題必須在程式碼以 `//todo:` 註記，簡要說明後續修正方向
- **註記格式**：使用 `//todo: <修正方向>`，例如 `//todo: 重構資料流，改用事件總線以移除直接依賴`
- **文件記錄**：記錄工作過程、決策理由和遭遇的問題
- **解決方案導向**：提供具體可用的解決方案，而非抽象說明
- **持續改進**：從每次執行中學習並改進工作方法

### 工作流程合規要求

- 不得因技術複雜度而跳過必要的工作階段
- 不得在未完成基本功能的情況下結束任務
- 必須提供足夠詳細的工作記錄以便後續維護
- 需要協助時必須已完成大部分基礎工作

### 文件撰寫監督檢視規範

#### 💼 務實監督報告風格要求

**撰寫工作日誌、技術報告和架構文件時，必須採用監督檢視的客觀評估角度**：

#### ❌ 絕對禁止的誇飾用語
- **過度讚譽詞彙**: 企業級、完美、太棒了、卓越、優秀、驚艷
- **誇大成就用語**: 突破性、革命性、劃時代、史上最佳
- **情緒化描述**: 令人興奮、振奮人心、激動人心
- **絕對化表述**: 完全解決、徹底消除、百分百成功

#### ✅ 必須採用的務實記錄方式

**功能性描述**:
- ❌ "完美實現了企業級架構" 
- ✅ "實作了 5層驗證策略，支援配置檢查、事件轉換、功能驗證"

**效果記錄**:
- ❌ "效能提升令人驚艷"
- ✅ "測試執行時間從 45秒 降低至 23秒，提升 49%"

**問題處理**:
- ❌ "完美解決了所有架構問題"
- ✅ "修正了 3個主要架構問題：循環依賴、錯誤處理不一致、測試覆蓋不足"

**風險評估**:
- ❌ "沒有任何風險"
- ✅ "識別風險：跨模組通訊延遲可能影響響應時間，需持續監控"

#### 📊 標準報告結構要求

**技術實現記錄**：
- 具體功能列表和技術規格
- 實際測試覆蓋率數字和通過狀態
- 程式碼行數、模組數量等量化指標
- 實作時間和資源消耗記錄

**問題與解決方案**：
- 具體問題描述和發生情境
- 嘗試的解決方案和效果評估
- 最終採用方案的選擇理由
- 殘留問題和後續工作項目

**品質指標客觀評估**：
- 測試通過率具體數字
- 效能指標的實際數據對比
- 程式碼複雜度和維護性評估
- 架構債務存在狀況和影響程度

#### 🎯 監督檢視核心原則

1. **客觀事實報告**: 記錄實際發生的事情和具體成果
2. **量化成果展示**: 使用具體數字和可驗證的指標
3. **風險誠實揭露**: 不隱瞞潛在問題和技術限制
4. **改善空間識別**: 主動指出可以優化的領域
5. **成本效益分析**: 評估投入資源與產出成果的合理性

### 敏捷開發機制作業規範

#### 📋 文件先行策略（Document-First Strategy）

- **設計文件優先**：任何架構變更、重構或新功能開發前，必須先撰寫完整的設計文件
- **API 接口定義**：明確定義所有接口、資料結構和行為契約後才開始編碼
- **架構決策記錄（ADR）**：重要的技術決策必須以文件形式記錄，包含決策背景、選項比較和理由
- **風險評估文件**：任何可能影響現有功能的變更都必須撰寫風險評估和緩解策略

#### 📊 最小分派最快交付（MVP Strategy）

- **任務設計與分派**：預設目標為「最小、最快可交付」（MVP）
- **文件驗證點**：設計文件完成後必須經過可行性驗證，確認符合既有架構
- **階段性交付**：將大型重構分解成多個小型、可驗證的交付階段
- **即時回饋循環**：每個階段完成後立即驗證和回饋，快速調整方向

#### 📝 高頻工作日誌更新（Stand-up via Logs）

- **工作日誌即站立會議**：每位任務執行者須高頻更新工作日誌，作為同步進度、阻礙與決策之主要管道
- **主動文件更新責任**：依照敏捷開發原則，必須更頻繁且主動的更新工作日誌和相關文件，向下一個接手的人說明當前任務進度和預計計畫
- **決策透明化**：所有架構決策、問題發現、解決方案都必須記錄在工作日誌中
- **阻礙及時回報**：遇到技術阻礙或需要決策支援時立即更新工作日誌
- **進度可視化**：透過工作日誌讓所有協作者了解當前進度和狀態
- **交接文件完整性**：每個任務完成後必須更新或建立相關文件，確保知識傳承和工作連續性

#### 🔄 協作標註與重構循環

- **程式碼協作標註**：於程式碼使用 `//todo:` 作為協作溝通管道，明確描述後續改善方向與依賴
- **重構循環**：先達成最小可交付，於重構階段依據工作日誌與 `//todo:` 標註重新評估優先順序與工作量，安排優化與重構
- **文件同步更新**：程式碼變更後必須同步更新相關設計文件，保持文件與實作一致
- **與既有規範對齊**：本機制與「最低完成策略」「📋 版本控制強制要求」「工作日誌管理規範」共同運作

#### 🎯 敏捷文件更新強制要求

- **開始任何開發工作前**：必須先建立或更新對應版本的工作日誌，記錄規劃思路、技術方案和預期目標
- **開發過程中同步記錄**：工作日誌必須與開發思考同步進行，即時記錄：
  - 技術決策的思考過程和選擇理由
  - 遇到的問題、錯誤和解決過程
  - 架構設計的演進和調整
  - 測試設計思路和發現的問題
  - 重構決策和效果評估
- **每個 TDD 循環完成後**：立即更新工作日誌記錄具體進度和成果
- **功能模組完成後**：必須更新架構文件、API 文件和使用說明
- **版本變更時**：必須同步更新 CHANGELOG.md、todolist.md 和版本記錄
- **絕對禁止事後補寫**：工作日誌不得在完成後才補寫，必須反映真實的開發思考過程
- **知識傳承責任**：記錄技術發現、最佳實踐、陷阱和後續改善建議

### TDD 循環完成後的標準流程

此流程統一由「📋 版本控制強制要求」章節規範，避免重複。

## 🤝 TDD 協作開發流程：設計師導向的團隊協作

**TDD 不只是開發方法，更是一個完整的團隊協作流程**，包含：
- 🎨 **功能設計師**: 負責功能規劃和需求分析
- 🧪 **測試工程師**: 負責測試設計和測試案例撰寫
- 💻 **實作工程師**: 負責功能實作和測試通過
- 🏗️ **重構設計師**: 負責程式碼品質改善和架構優化

### 🎯 TDD 協作核心原則

1. **工作日誌驅動**: 每個階段都有對應的工作日誌，記錄思考過程和交接資訊
2. **角色明確分工**: 每個角色有明確的職責和交付物
3. **文件化交接**: 透過工作日誌進行角色間的知識傳遞
4. **測試先行**: 絕對不在沒有測試的情況下寫程式碼
5. **品質不妥協**: 每個階段都有品質門檻，不達標不進入下一階段

### 🔄 TDD 完整協作流程

TDD 協作流程分為四個明確的階段，每個階段都有專門的角色負責：

#### 🎨 Phase 1: 功能設計師 - 需求分析與功能規劃

**負責角色**: 功能設計師  
**目標**: 建立清楚的功能需求和設計規範，為後續測試和實作奠定基礎

**必須建立新工作日誌**: `docs/work-logs/vX.X.X-feature-design.md`

**工作日誌必須包含內容**:

```markdown
## 功能設計規劃

### 功能需求分析：
- 這個功能要解決什麼問題？
- 使用者的具體使用場景是什麼？
- 功能的核心價值和期望效果是什麼？

### 功能規格設計：
- 功能的輸入是什麼？（參數、資料、使用者互動）
- 功能的輸出是什麼？（回傳值、副作用、使用者回饋）
- 正常流程的步驟是什麼？
- 異常情況的處理方式是什麼？

### 邊界條件分析：
- 極端輸入情況（空值、超大值、無效值）
- 系統限制和約束條件
- 錯誤情況和例外狀況

### API/介面設計：
- 函數簽名或 API 接口定義
- 資料結構和類型定義
- 與其他模組的互動方式

### 驗收標準：
- 功能正確性的驗證方法
- 效能要求和品質標準
- 使用者體驗的期望標準
```

**交接給測試工程師**:
- [ ] 功能需求清楚且具體
- [ ] API 介面定義完整
- [ ] 邊界條件和異常情況已識別
- [ ] 驗收標準明確可驗證

#### 🧪 Phase 2: 測試工程師 - 測試案例設計與實作

**負責角色**: 測試工程師  
**目標**: 根據功能設計，設計並實作完整的測試案例

**在原工作日誌中新增測試設計章節**:

```markdown
## 測試案例設計

### 測試策略規劃：
基於功能設計師的需求分析，設計以下測試策略：
- 單元測試：測試核心邏輯和邊界條件
- 整合測試：測試與其他模組的互動
- 端對端測試：測試完整的使用者流程

### 具體測試案例：

#### 正常流程測試：
- [測試案例1]: Given [前置條件], When [執行動作], Then [預期結果]
- [測試案例2]: Given [前置條件], When [執行動作], Then [預期結果]

#### 邊界條件測試：
- [邊界測試1]: Given [邊界情況], When [執行動作], Then [預期結果]
- [邊界測試2]: Given [極端輸入], When [執行動作], Then [預期結果]

#### 異常情況測試：
- [異常測試1]: Given [錯誤條件], When [執行動作], Then [預期錯誤處理]
- [異常測試2]: Given [無效輸入], When [執行動作], Then [預期錯誤回應]

### 測試環境設置：
- Mock 物件設計：[列出需要的 Mock]
- 測試資料準備：[列出測試所需資料]
- 測試清理策略：[說明測試後的清理方法]

### 測試實作記錄：
- 實作的測試檔案：[列出建立的測試檔案]
- 測試覆蓋的功能點：[記錄測試涵蓋範圍]
- 發現的設計問題：[記錄在設計測試過程中發現的問題]
```

**實際執行工作**:
1. **撰寫失敗的測試**: 根據設計實作具體的測試程式碼
2. **驗證測試失敗**: 確保測試在沒有實作時會失敗
3. **測試品質檢查**: 確保測試程式碼品質和覆蓋率

**交接給實作工程師**:
- [ ] 所有測試案例已實作為程式碼
- [ ] 測試在沒有功能實作時會失敗（紅燈狀態）
- [ ] 測試覆蓋率達到設計要求
- [ ] 測試程式碼品質良好且可維護

#### 💻 Phase 3: 實作工程師 - 功能實作與測試通過

**負責角色**: 實作工程師  
**目標**: 實作功能讓所有測試通過，並記錄開發過程

**在原工作日誌中新增實作記錄章節**:

```markdown
## 功能實作記錄

### 實作策略：
基於測試工程師提供的測試案例，採用以下實作策略：
- 最小實作原則：只實作讓測試通過的最小程式碼
- 漸進式開發：一次讓一個或一組相關測試通過
- 權宜實作允許：可使用暫時方案，但須標註 //todo: 改善方向

### 實作過程記錄：

#### 第一輪實作：
- 目標測試：[列出這輪要通過的測試]
- 實作內容：[具體描述實作的程式碼]
- 遇到的問題：[記錄開發過程中遇到的技術問題]
- 權宜解決方案：[記錄暫時性的解決方法和後續改善計劃]

#### 第二輪實作：
- 目標測試：[下一組要通過的測試]
- 實作內容：[繼續實作的功能]
- 設計改善：[改善前一輪權宜方案的記錄]

### 測試通過驗證：
- 單元測試通過率：[具體數字]
- 整合測試通過率：[具體數字]
- 測試覆蓋率：[具體數字]
- 效能基準測試：[如有必要記錄效能數據]

### 實作中發現的問題：
- 設計規格的疑問：[記錄實作過程中對原設計的疑問]
- 測試案例的建議：[對測試設計的改善建議]
- 架構相關發現：[實作過程中發現的架構問題]

### 技術債務記錄：
- //todo: 標註的改善項目：[列出所有需要後續改善的項目]
- 已知的限制：[記錄實作的限制和約束]
- 建議的重構方向：[為重構設計師提供的建議]
```

**實際執行工作**:
1. **實作最小可用功能**: 讓所有測試通過
2. **驗證測試套件**: 確保 100% 測試通過率
3. **程式碼品質檢查**: 通過 lint 和 build 檢查
4. **記錄開發過程**: 詳細記錄實作決策和發現

**交接給重構設計師**:
- [ ] 所有測試 100% 通過
- [ ] 功能按照設計規格正確實作
- [ ] 程式碼品質檢查通過
- [ ] 開發過程完整記錄在工作日誌中

#### 🏗️ Phase 4: 重構設計師 - 程式碼品質改善

**負責角色**: 重構設計師  
**目標**: 改善程式碼品質和架構，執行完整的重構方法論

**重要**: 重構設計師必須按照本文件「🧠 TDD 驅動重構方法論」章節的完整流程執行

**工作流程**:
1. **建立重構工作日誌**: 按照重構方法論 Phase 1 要求建立新工作日誌
2. **執行重構**: 按照重構方法論 Phase 2 執行重構並驗證預期
3. **完成重構總結**: 按照重構方法論 Phase 3 完成工作日誌總結

**在原功能工作日誌中新增重構總結章節**:

```markdown
## 重構設計師工作總結

### 重構工作日誌連結：
- 重構工作日誌：[連結到重構專用的工作日誌]
- 重構架構版本：[使用希臘字母標註，如 α、β、γ]

### 重構成果：
- 解決的 //todo: 項目：[列出解決的技術債務]
- 改善的程式碼品質：[具體描述改善內容]
- 架構一致性提升：[說明如何符合專案架構]
- 效能優化結果：[如有效能改善則記錄]

### 最終狀態確認：
- [ ] 所有測試 100% 通過
- [ ] 程式碼品質符合專案標準
- [ ] 沒有未解決的 //todo: 項目
- [ ] 功能完整性保持不變
- [ ] 建置和部署正常
```

**最終交付標準**:
- [ ] 重構方法論完整執行
- [ ] 所有技術債務已解決
- [ ] 程式碼品質達到專案標準
- [ ] 功能完整性確認無損
- [ ] 重構經驗記錄完整

### 🤝 TDD 協作流程總結

#### 📋 完整協作檢查清單

**階段完成驗證**:
- [ ] Phase 1: 功能設計師完成需求分析和功能規劃
- [ ] Phase 2: 測試工程師完成測試案例設計和實作
- [ ] Phase 3: 實作工程師完成功能實作和測試通過
- [ ] Phase 4: 重構設計師完成程式碼品質改善

**工作日誌品質**:
- [ ] 功能設計工作日誌建立且內容完整
- [ ] 測試設計章節記錄詳細且可追蹤
- [ ] 實作過程記錄完整包含所有決策
- [ ] 重構工作有獨立工作日誌並完成總結

**最終交付標準**:
- [ ] 所有測試 100% 通過
- [ ] 程式碼品質達到專案標準
- [ ] 功能完全符合原始設計規格
- [ ] 沒有未解決的技術債務
- [ ] 完整的開發過程可追蹤

#### 💡 TDD 協作的價值

**知識傳承**:
- 每個階段的思考過程都被完整記錄
- 工作日誌提供完整的開發脈絡
- 決策理由和問題解決過程可追溯

**品質保證**:
- 多個角色的專業檢查確保品質
- 每個階段都有明確的交付標準
- 測試先行確保功能正確性

**團隊協作**:
- 明確的角色分工避免責任模糊
- 標準化的交接流程提高效率
- 文件化交接避免知識流失

**持續改進**:
- 每個階段的經驗都被記錄下來
- 協作過程本身可以不斷優化
- 為未來類似功能開發提供參考

### 🧠 TDD 驅動重構方法論：預期管理與工作日誌為核心

#### 🎯 重構核心原則：預期管理與驗證

**重構是預期管理與驗證的思考框架，不是執行步驟**：
- **預期管理**: 重構前先預期哪些測試會通過、哪些會失敗、為什麼失敗
- **驗證預期**: 執行重構後檢查結果是否符合預期
- **預期偏差處理**: 若結果不符合預期，分析原因並調整計劃
- **工作日誌記錄**: 記錄整個思考和驗證過程，確保知識傳承和協作透明

#### 📝 Phase 1: 重構計劃與工作日誌建立

**必須建立新工作日誌的原因**: 確保重構思考過程可追蹤、協作透明、知識不流失

**工作日誌必須回答的問題**:

1. **🎯 重構動機與目標**:
   ```markdown
   ## 為什麼要重構？
   - 當前架構的具體問題是什麼？
   - 重構後期望達成的狀態是什麼？
   - 這個重構如何解決核心問題？
   ```

2. **🔍 影響範圍分析**:
   ```markdown
   ## 預期影響的程式碼和行為
   - 哪些檔案會被修改？
   - 哪些功能的行為會改變？
   - 哪些 API 或介面會受影響？
   ```

3. **🧪 測試預期管理**:
   ```markdown
   ## 測試結果預期
   ### 預期會通過的測試：
   - [列出具體測試檔案和測試名稱]
   - 為什麼這些測試應該繼續通過？
   
   ### 預期會失敗的測試：
   - [列出具體測試檔案和測試名稱]
   - 為什麼這些測試會失敗？失敗的原因是什麼？
   - 怎麼修正這些失敗？
   
   ### 不確定的測試：
   - [可能會受影響的測試]
   - 為什麼不確定？需要特別注意什麼？
   ```

4. **📊 成功標準設定**:
   ```markdown
   ## 重構成功的標準
   - 測試結果符合預期的標準是什麼？
   - 程式碼品質的要求是什麼？
   - 效能或使用者體驗的標準是什麼？
   ```

#### 🚀 Phase 2: 重構執行與預期驗證

**執行目的**: 驗證重構計劃中的預期是否正確，不是單純的執行步驟

**Step 1: 執行重構**
```bash
# 按照計劃執行重構
# [這裡是具體的重構動作]
```

**Step 2: 驗證測試結果**
```bash
npm test                # 執行所有測試
npm run test:unit       # 單元測試
npm run test:integration # 整合測試
```

**Step 3: 對比預期與實際結果**

**情境 A: 結果符合預期 ✅**
- 預期通過的測試都通過了
- 預期失敗的測試都失敗了，且失敗原因符合預期
- 不確定的測試結果都在可接受範圍內

**對應行動**: 更新工作日誌
```markdown
## 重構結果驗證 - 符合預期 ✅
### 測試結果記錄：
- [具體記錄測試結果]
### 重構過程發現：
- [記錄重構過程中的發現和決策]
### 下一步：
- 重構目標已達成，繼續後續優化
```

**情境 B: 結果不符合預期 ❌**
- 預期通過的測試失敗了
- 預期失敗的測試通過了，或失敗原因與預期不符
- 出現了預期之外的測試失敗

**對應行動**: 更新工作日誌，分析偏差
```markdown
## 重構結果驗證 - 不符合預期 ❌
### 預期偏差分析：
- [具體記錄哪些預期出現偏差]
- [分析為什麼會有偏差]
- [記錄意外發現的問題]

### 下一步行動決策：
- ☀️ 選擇1: 修正當前問題，繼續原計劃
- 🔄 選擇2: 調整重構計劃，縮小範圍
- 🏠 選擇3: 回到穩定狀態，重新設計
```

#### 📝 Phase 3: 重構完成與工作日誌總結

**完成驗證目的**: 確保重構達成目標，並記錄學習成果供未來參考

**最終驗證檢查**:
```bash
# 基本功能驗證
npm test                # 所有測試必須通過
npm run test:unit       # 單元測試必須通過  
npm run test:integration # 整合測試必須通過

# 品質與效能驗證
npm run lint            # Linter 檢查必須通過
npm run build           # 建置必須成功
npm run test:coverage   # 測試覆蓋率檢查
```

**工作日誌總結更新**:
```markdown
## 重構總結與學習

### 目標達成情況：
- [ ] 原定目標是否達成？
- [ ] 架構問題是否得到解決？
- [ ] 程式碼品質是否符合預期？

### 預期管理的學習：
- 哪些預期是正確的？為什麼？
- 哪些預期是錯誤的？為什麼？
- 下次類似重構應該注意什麼？

### 方法論的改進：
- 重構計劃的哪些部分需要改進？
- 測試預期的方法可以怎麼優化？
- 未來類似問題的預防策略是什麼？
```

**重構計劃調整機制**:

**中斷重構的情況**:
- 預期偏差太大，需要重新評估
- 發現了重大的架構問題
- 測試結果顯示重構範圍太大

**調整計劃的程序**:
1. **更新工作日誌**: 記錄中斷的原因和發現
2. **重新評估目標**: 是否需要縮小範圍或改變方法
3. **建立新計劃**: 基於新的理解建立調整後的計劃
4. **繼續執行**: 按照新計劃重新開始

#### 📋 重構方法論檢查清單

**重構開始前**:
- [ ] 已建立新的工作日誌
- [ ] 明確記錄重構動機和目標
- [ ] 詳細分析影響範圍
- [ ] 建立測試結果預期
- [ ] 設定成功標準

**重構過程中**:
- [ ] 測試結果與預期對比
- [ ] 預期偏差的立即分析
- [ ] 工作日誌的即時更新

**重構完成後**:
- [ ] 目標達成情況的總結
- [ ] 預期管理的學習記錄
- [ ] 方法論改進建議
- [ ] 未來預防策略建立

#### 💡 重構方法論的協作價值

**架構規劃師與 RD 協作**:
- 架構規劃師負責 Phase 1 的計劃建立，明確目標和預期
- RD 負責 Phase 2 的執行和驗證，回報實際結果
- 兩者共同參與 Phase 3 的總結和學習

**多個 RD 協作**:
- 工作日誌提供完整的思考脈絡，便於知識交接
- 預期管理機制確保每個人都清楚目標和標準
- 檢查清單確保工作品質的一致性

**知識累積與傳承**:
- 每次重構的經驗都被完整記錄
- 預期偏差分析幫助團隊改進預期能力
- 方法論本身根據實際使用經驗持續改進

## 📋 版本控制與合規自主管理

### 🔍 主線程自主合規原則

基於 Claude Code 最佳實踐，**主線程擁有完整實作上下文**，因此最適合執行合規檢查和文件更新，確保資訊準確性和即時同步。

#### 核心理念
- **第一手資訊**：基於實際實作過程進行檢查
- **即時同步**：開發過程中即時更新文件
- **完整上下文**：了解所有技術決策和問題解決過程
- **自我負責**：對工作品質承擔完全責任

### 🔄 TDD 循環整合合規檢查

#### 每個 TDD 階段後的合規檢查

**🔴 Red 階段後**：
```bash
npm test        # 確認新測試失敗
```
- [ ] 測試命名清晰，描述測試場景
- [ ] 測試確實失敗（紅燈狀態）
- [ ] 記錄測試設計的思考過程

**🟢 Green 階段後**：
```bash
npm test              # 確認所有測試通過
npm run test:coverage # 檢查測試覆蓋率
```
- [ ] 所有測試通過（綠燈狀態）
- [ ] 暫時實作已標註 `//todo:` 註記
- [ ] 記錄實作過程中的重要決策

**🔵 Refactor 階段後**：
```bash
npm test        # 確認重構後測試仍通過
npm run lint    # 確認程式碼品質
npm run build   # 確認建置成功
```
- [ ] 消除了所有 `//todo:` 標註的問題
- [ ] 程式碼符合專案編碼規範
- [ ] 記錄重構的原因和效果

### 每個 TDD 循環完成後必須執行以下步驟

#### 1. 完整合規檢查
```bash
# 執行完整檢查套件
npm test && npm run test:coverage && npm run lint && npm run build
```

**品質標準驗證**：
- [ ] 測試覆蓋率達到 100%
- [ ] 所有 linter 檢查通過
- [ ] 建置成功無錯誤
- [ ] 效能沒有明顯退化

#### 2. Git 操作驗證
```bash
git status      # 檢查變更狀態
git diff        # 確認變更內容
```

**變更驗證**：
- [ ] 變更範圍與功能描述一致
- [ ] 沒有不相關的程式碼變更
- [ ] 沒有敏感資訊洩漏

#### 3. 文件同步更新（主線程執行）

**必須更新的文件**：
1. **更新 `docs/todolist.md` 進度**
2. **更新工作日誌 `docs/work-logs/vX.X.X-work-log.md`**
3. **強制更新 `CHANGELOG.md`** 記錄小版本號 (v0.X.Y)

**文件品質標準**：
- [ ] 工作日誌反映真實開發過程
- [ ] 技術決策有清楚的理由說明
- [ ] 問題發現和解決過程詳細記錄
- [ ] 重構思路和效果有具體描述

#### 4. Git Commit 提交
```bash
git add .
git commit -m "$(cat <<'EOF'
[commit message here]

EOF
)"
```

**Commit 品質標準**：
- [ ] 使用 Conventional Commits 格式
- [ ] 訊息清楚描述變更內容和原因
- [ ] 包含必要的 co-author 資訊

### 版本號管理規範

- **小版本號 (v0.X.Y)**: 對應每個 TDD 循環完成
- **中版本號 (v0.X.0)**: 對應主要功能模組完成
- **主版本號 (v1.0.0)**: 產品完整功能，準備上架
- **每個 TDD 循環必須對應一個小版本號記錄**

### 工作日誌管理規範

- **建立時機**: 每個中版本號變更時建立新的工作日誌檔案
- **檔案命名**: `docs/work-logs/vX.X.X-work-log.md`
- **更新頻率**: 每完成一個 TDD 循環或重要修復後立即更新

#### 工作日誌必須包含內容

- TDD 循環的完整 Red-Green-Refactor 過程
- **詳細的思考過程和決策邏輯**
- **問題發現過程**: 如何檢查到錯誤、錯誤症狀描述
- **問題原因分析**: 深入分析錯誤為什麼會發生、根本原因追溯
- **解決方案過程**: 解決方法的選擇、嘗試過程、最終方案
- **重構思路**: 原程式碼的不佳問題、優化思路、改善效果
- **架構決策與專案結構調整**
- **技術棧選擇與工具變更決策**
- **除錯過程**: 包含錯誤訊息、診斷步驟、修復驗證
- **效能優化**: 效能問題識別、分析方法、優化成果

## 📋 版本管理嚴格規範

### 🎯 版本確認檢查點

**任何版本相關工作前，必須先確認當前專案狀態**：

#### 必須檢查的檔案（按優先順序）：
1. **`docs/todolist.md`** - 查看「🎯 專案當前狀態」章節的版本號
2. **`CHANGELOG.md`** - 確認最新版本記錄 
3. **`package.json`** - 查看專案版本號
4. **最新工作日誌** - 在 `docs/work-logs/` 中找到最新的 `vX.X.X-work-log.md`

#### 版本類型明確區分：

**🎯 專案版本（數字版本號）**：
- **格式**: v0.9.x, v1.0.0（影響整個產品發布）
- **用途**: 實際的產品發布版本，面向使用者
- **範例**: v0.9.18, v1.0.0, v1.2.5

**🏗 架構版本（希臘字母）**：
- **格式**: α (Alpha), β (Beta), γ (Gamma), δ (Delta), ε (Epsilon), ζ (Zeta), η (Eta), θ (Theta)
- **用途**: 內部技術架構演進標記，不影響產品版本號
- **範例**: 事件系統架構-α, BookSearchFilter重構-β, Content模組化-γ
- **排序**: α → β → γ → δ → ε → ζ → η → θ → ι → κ → λ → μ

**🔧 功能版本（模組內部）**：
- **格式**: API v1.2, Engine v3.1（特定功能模組版本）
- **用途**: 模組內部版本追蹤，與專案版本無關

#### 版本號規則：
- **v0.9.x 階段**：重構和準備階段，為 v1.0 做準備
- **v1.0.0**：第一個正式發布版本
- **v1.x.x**：功能更新和改進
- **v2.0.0**：重大架構變更或突破性更新

#### 版本變更流程：
1. 確認當前版本號
2. 判斷變更類型（patch/minor/major）
3. 更新 CHANGELOG.md
4. 建立對應的工作日誌
5. 提交時使用正確的版本號

### 🎯 希臘字母架構版本命名系統

#### 核心原則
- **明確分離**: 架構版本與專案版本完全分離
- **循序漸進**: 按希臘字母順序標記架構演進
- **語意明確**: 每個希臘字母代表一個重大架構階段

#### 希臘字母對應表
```
α (Alpha)   - 初始架構設計或重大重構開始
β (Beta)    - 核心架構實現完成
γ (Gamma)   - 架構整合與優化
δ (Delta)   - 架構驗證與測試完善
ε (Epsilon) - 架構穩定與效能優化
ζ (Zeta)    - 架構擴展與彈性設計
η (Eta)     - 架構成熟與最佳化
θ (Theta)   - 架構完善與文件化
```

#### 命名格式範例
- **BookSearchFilter重構-β**: BookSearchFilter 模組重構的第二階段
- **事件系統架構-γ**: 事件驅動架構的第三次重大演進
- **Content模組化-δ**: Content Script 模組化的驗證階段

### ⚠️ 版本混淆防範機制

#### 絕對禁止的行為
- ❌ **將架構版本當作專案版本**: 不可將 "α, β, γ" 用於專案發布
- ❌ **跳過版本確認步驟**: 任何版本變更前必須確認當前狀態
- ❌ **版本號自動提升**: 不可未經確認自動提升大版本號
- ❌ **混合使用版本系統**: 同一文件中不可混用不同版本系統

#### 強制檢查機制
- ✅ **工作日誌強制標註**: 必須明確標註版本類型（專案/架構/功能）
- ✅ **TODO 更新前確認**: 更新 TODO 前必須確認當前專案版本
- ✅ **架構文件版本分離**: 架構文件使用希臘字母，工作日誌使用專案版本
- ✅ **Commit 訊息版本正確**: 提交訊息必須使用正確的版本號類型

## 📁 檔案管理嚴格規則

### 檔案操作原則

- **絕對不創建非必要的檔案**
- **優先編輯現有檔案而非創建新檔案**
- **永不主動創建文件檔案 (\*.md) 或 README 檔案**，除非使用者明確要求
- 臨時檔案和輔助腳本在任務完成後必須清理

## 🏗 架構債務管理與持續改善

### 永不放棄原則 - 架構問題及早修正策略

**核心原則**: 架構問題和設計債務是第一優先修正目標，絕不可「先將就」或「之後再處理」

#### 🚨 立即處理原則

1. **架構問題發現 = 立即修正**: 一旦識別出架構債務，立即停止功能開發，優先修正
2. **修復成本會指數增長**: 架構問題拖延修復的成本隨時間呈指數增長
3. **絕不妥協的品質標準**: 寧可延遲功能發布，也不允許技術債務累積
4. **根本原因必須徹底解決**: 不接受「暫時性修正」或「症狀緩解」

#### 🔍 架構債務識別標準

**高優先級架構債務**（必須立即修正）:

- 依賴注入不一致或缺失
- 測試困難或無法測試的程式碼
- 違反 SOLID 原則的設計
- 模組間高耦合或循環依賴
- 不一致的錯誤處理模式
- 缺乏適當的抽象層

**檢查觸發條件**:

- 任何測試失敗都必須深入分析根本原因
- 程式碼重複超過 3 次必須抽象化
- 函數超過 30 行必須考慮重構
- 模組責任不明確必須重新設計

#### 🛠 修正流程與標準

**Step 1: 問題分析**

- 建立詳細的債務分析文件 (`docs/architecture/`)
- 評估影響範圍和修復複雜度
- 制定具體的修復計劃和時程

**Step 2: TDD 驅動修正**

- 使用完整的 Red-Green-Refactor 循環
- 先寫測試驗證修正目標
- 實現最小可行的修正方案
- 重構確保程式碼品質

**Step 3: 架構一致性驗證**

- 檢查相同模式在其他組件的應用
- 統一整個專案的設計模式
- 建立防止類似問題的指導原則

#### 💡 品質標準與檢查點

**在任何程式碼被標記為「完成」之前，必須驗證**:

1. **測試覆蓋率達標**: 依「測試覆蓋率要求」章節的門檻
2. **零架構債務**: 沒有已知的設計缺陷或債務
3. **一致的模式**: 與專案其他部分設計模式一致
4. **完整的錯誤處理**: 所有可能的錯誤情況都有適當處理
5. **效能基準達標**: 符合或超越效能要求
6. **文件完整性**: 程式碼意圖和使用方式都有清楚文件

#### 🚨 絕對禁止的妥協行為

- ❌ **「先這樣，之後再改」**: 架構問題必須當下解決
- ❌ **「測試之後再寫」**: 違反 TDD 原則
- ❌ **「這個 bug 不影響功能」**: 所有已知問題都必須修復
- ❌ **「複製貼上這段程式碼」**: 重複程式碼必須立即重構
- ❌ **「暫時用 try-catch 包起來」**: 錯誤處理必須有明確策略

#### 📈 持續改善機制

**每完成一個 TDD 循環後檢查**:

- 是否引入新的技術債務？
- 現有設計模式是否一致？
- 測試覆蓋率是否維持或提升？
- 程式碼複雜度是否在可接受範圍？

**每週架構健康檢查**:

- 回顧本週解決的架構問題
- 識別潛在的設計風險
- 更新架構決策文件
- 規劃下週的改善重點

## 測試覆蓋率要求

- 所有測試類型覆蓋率必須達到 100%

## 📝 程式碼品質規範

### 架構設計原則

#### 1. Five Lines 規則與單一責任原則

**Five Lines 規則 (強制要求)**:
- 每個方法不應超過5行程式碼，排除大括號 `{` 和 `}`
- 一行指任何以分號結尾的語句：if、for、while、賦值、方法呼叫、return等
- 空白行和大括號不計算在內

**單一職責原則**:
- 每個函數只負責一個明確定義的功能
- 判斷責任範圍：如需用"和"或"或"描述功能，必須拆分
- 函數命名必須清楚表達其單一職責和行為目的

#### 2. 命名規範

- 使用描述性且有意義的名稱，清楚表明用途
- 函數名稱以動詞開頭 (如: calculateTotal, validateInput)
- 變數名稱使用名詞 (如: userProfile, paymentAmount)
- 布林變數使用 is, has, can 前綴 (如: isValid, hasPermission)

#### 3. 文件規範

- 每個函數、類別或模組都必須有註解描述其目的和功能
- 註解應解釋"為什麼"這樣實作，而不只是"做了什麼"
- 核心功能必須遵循標準化註解結構：
  - 簡短的功能目的描述
  - "負責功能："列出責任清單
  - "設計考量："說明實作決策
  - "處理流程："用數字步驟記錄流程
  - "使用情境："說明何時及如何呼叫此函數

### 程式碼撰寫規範

- 優先考慮可讀性和可維護性，而非過度最佳化
- 防禦性程式設計：驗證輸入參數，處理邊界情況和例外
- 必須立即修正明顯的 linter 錯誤
- 同一檔案的 linter 錯誤修正不超過 3 次循環

### 重構專屬原則

#### TDD重構階段的核心原則

**重構策略轉換**:
- **最小實現階段 (Green)**: 以可用為目標，允許權宜實作
- **重構階段 (Refactor)**: 秉持Five Lines規則和單一職責原則進行拆分

**語意化重構方法**:
- **行為導向命名**: 每個函數名稱必須明確描述其行為目的
- **單檔核心概念**: 每個檔案基於一個核心概念組織相關行為
- **任務觸發設計**: 每個case基於單一任務去觸發對應行為

**函數拆分策略**:
- **超過5行立即拆分**: 任何超過5行的函數必須拆分為語意化的輔助函數
- **職責明確分離**: 每個拆分後的函數只負責一個明確的操作
- **組合勝於複雜**: 透過小函數組合實現複雜邏輯，而非單一複雜函數

**重構執行標準**:
- **語意化命名**: 函數名稱必須清楚表達「做什麼」而非「怎麼做」
- **參數語意化**: 函數參數名稱必須表達其在操作中的角色
- **單一入口出口**: 每個函數有明確的輸入輸出，避免副作用
- **可測試設計**: 重構後的每個小函數都應該容易進行單元測試

#### 重構範例參考

**實際範例**: `docs/refactoring-examples/color-library-refactoring-example.js`

此範例展示如何將複雜的顏色轉換函數重構為語意化的小函數：
- **重構前**: 單一長函數混合多種職責
- **重構後**: 每個函數不超過5行，職責單一明確
  - `calcHRotation()`: 計算色相旋轉值
  - `calcH()`: 計算HSL色相值  
  - `calcL()`: 計算HSL亮度值
  - `calcS()`: 計算HSL飽和度值
  - `rgb2hsl_internal()`: 組合HSL計算結果

### 錯誤處理規範

- 清楚定義錯誤處理策略
- 使用有意義的錯誤訊息協助問題診斷
- 在適當層級處理例外，避免例外洩漏
- 記錄關鍵錯誤訊息供後續分析

### 程式碼風格

- 使用 ES6+ 語法
- 優先使用 const/let 而非 var
- 使用模組化匯入/匯出
- 遵循 JSDoc 註解規範

## 🎭 事件驅動架構規範

### 事件命名規範

- **格式**: `MODULE.ACTION.STATE`
- **範例**: `EXTRACTOR.DATA.EXTRACTED`、`STORAGE.SAVE.COMPLETED`、`UI.POPUP.OPENED`

### 事件優先級

- `URGENT` (0-99): 系統關鍵事件
- `HIGH` (100-199): 使用者互動事件
- `NORMAL` (200-299): 一般處理事件
- `LOW` (300-399): 背景處理事件

### 事件處理原則

- 每個模組通過事件總線通訊
- 避免直接模組間依賴
- 事件處理器必須有錯誤處理機制
- 實現事件的重試與降級機制

### 模組通訊方式

- Background ↔ Content Script: Chrome Runtime 訊息傳遞
- Background ↔ Popup: Chrome Extension APIs
- 內部模組: Event Bus 模式

## 🔄 上下文管理規範

#### 循環完成後上下文管理

每完成一個 TDD 循環後，必須：

1. **對話結束宣告**: 明確告知使用者 TDD 循環已完成
4. **新對話開始**: 使用者開始新對話進行下一個循環

文件記錄與版本提交請依「📋 版本控制強制要求」執行。

**技術實現方式**:

- 由於 Claude Code 沒有 `clear` 指令功能
- 透過明確的對話結束和新對話開始來達成上下文隔離
- 每個循環的程式碼設計必須獨立，不依賴上下文記憶

#### 獨立功能設計原則

每個 TDD 循環必須：

- **可獨立測試**: 不依賴其他模組的實作細節
- **明確邊界**: 清楚定義輸入輸出接口
- **領域隔離**: 符合 DDD 的有界上下文概念
- **事件解耦**: 透過事件系統與其他模組通訊

## 🌐 語言規範

**所有回應必須使用繁體中文 (zh-TW)**

- 產品使用者和開發者為台灣人，使用台灣特有的程式術語
- 程式碼中的中文註解和變數命名嚴格遵循台灣語言慣例
- 如不確定用詞，優先使用英文而非中國用語

## 🏗 Chrome Extension 特定要求

### Manifest V3 規範

- 嚴格遵循 Manifest V3 API
- 使用 Service Worker 而非 Background Pages
- 實現適當的權限請求策略

### 安全性要求

- 所有資料處理在本地進行
- 避免將敏感資料傳送到外部服務
- 實現適當的 CSP (Content Security Policy)
- 最小權限原則：只請求必要的權限

### 技術規格

- **測試框架**: Jest + Chrome Extension API Mocks
- **建置工具**: npm scripts
- **程式碼檢查**: ESLint
- **版本控制**: Git
- **無外部依賴**: 為了安全性和效能考量

## 🏗 專案概覽

這是一個基於 **Chrome Extension (Manifest V3)** 的 Readmoo 電子書平台資料提取和管理工具。專案嚴格遵循 **TDD (測試驅動開發)** 和 **事件驅動架構**。

### 核心架構原則

1. **事件驅動架構**: 所有模組通過中央化事件系統通訊
2. **單一責任原則**: 每個模組、處理器和組件只有一個明確目的
3. **TDD 優先**: 所有程式碼必須先寫測試，使用 Red-Green-Refactor 循環
4. **Chrome Extension 最佳實踐**: 遵循 Manifest V3 規範

### 主要組件

- **Background Service Worker** (`src/background/`): 處理擴展生命週期和跨上下文事件
- **Content Scripts** (`src/content/`): 從 Readmoo 頁面提取資料
- **Popup 界面** (`src/popup/`): 主要使用者互動界面
- **儲存系統** (`src/storage/`): 管理資料持久化，支援多種適配器
- **事件系統** (`src/core/`): 模組通訊的中央事件總線

### 專案結構

```
src/
├── background/         # Service Worker 和背景事件
├── content/           # Readmoo 頁面的 Content Scripts
├── popup/             # 擴展 Popup 界面
├── storage/           # 資料持久化層
│   ├── adapters/      # 儲存適配器 (Chrome, Local, IndexedDB)
│   └── handlers/      # 儲存事件處理器
├── core/              # 核心事件系統
└── extractors/        # 資料提取邏輯

tests/
├── unit/              # 單元測試
├── integration/       # 整合測試
└── e2e/               # 端對端測試

docs/
├── architecture/      # 架構設計文件
├── work-logs/         # 開發工作日誌
├── todolist.md        # 任務追蹤清單
└── struct.md          # 完整專案結構
```

## 🤖 Agent 協作規範

根據 Claude Code sub-agent 最佳實踐，本專案採用**文件先行的研究規劃模式**，所有 sub-agent 均為純研究員和規劃者，主線程負責所有實際實作工作。

### 📋 核心設計原則

#### Sub-agent 最佳實踐應用
- **純研究規劃角色**: Sub-agent 專注於分析現有程式碼庫，提出實作計劃，絕不執行實際實作
- **上下文優化**: 透過檔案系統管理上下文，避免大量 token 消耗和上下文壓縮問題
- **主線程實作**: 所有程式碼修改、測試執行、檔案建立均由主線程執行，確保完整上下文

#### 工作流程模式
1. **主線程建立專案上下文檔案** (`docs/context/session_contexts/`)
2. **委派任務給專業 sub-agent 進行研究規劃**
3. **Sub-agent 閱讀上下文，產出詳細實作計劃** (`docs/context/agent_plans/`)
4. **主線程閱讀計劃並執行所有實際實作工作**
5. **更新上下文檔案，記錄進度和決策**

### 🎯 Sub-agent 角色定位

#### 專案管理規劃層級

- **rosemary-project-manager** (📋): 策略規劃研究專家
  - **核心職責**: 專案策略研究、任務分解規劃、風險分析和時程規劃
  - **研究範圍**: 分析專案需求、制定工作分派策略、設計敏捷升級機制
  - **輸出成果**: 專案規劃文件、任務分解計劃、里程碑設計
  - **絕不執行**: 不進行任何實際的任務分配或專案執行

- **project-compliance-agent**: 合規檢查研究專家
  - **核心職責**: 合規標準研究、檢查流程設計、版本控制規範分析
  - **研究範圍**: 分析合規要求、設計檢查流程、規劃文件更新策略
  - **輸出成果**: 合規檢查計劃、版本控制流程設計、品質保證策略
  - **絕不執行**: 不進行實際的合規檢查或版本控制操作

#### 測試策略規劃層級

- **sage-test-architect** (🔴): 測試策略設計專家
  - **核心職責**: 測試架構研究、測試策略設計、測試覆蓋率規劃
  - **研究範圍**: 分析測試需求、設計測試架構、規劃單元測試和組件測試策略
  - **輸出成果**: 測試設計文件、測試架構規劃、測試覆蓋策略
  - **絕不執行**: 不撰寫實際測試程式碼或執行測試

- **coriander-integration-tester**: 整合測試策略專家
  - **核心職責**: 整合測試策略研究、E2E 測試規劃、系統測試設計
  - **研究範圍**: 分析整合點、設計測試場景、規劃系統層級測試
  - **輸出成果**: 整合測試計劃、E2E 測試策略、系統測試規範
  - **絕不執行**: 不實作或執行任何測試程式碼

#### UI/UX 設計規劃層級

- **lavender-interface-designer**: UI/UX 策略設計專家
  - **核心職責**: 使用者體驗研究、介面設計策略、設計規範制定
  - **研究範圍**: 分析使用者需求、設計互動流程、規劃視覺設計標準
  - **輸出成果**: UI/UX 設計規範、使用者體驗策略、設計系統文件
  - **絕不執行**: 不進行任何實際的 UI 實作或程式碼撰寫

#### 專業技術規劃層級

- **basil-event-architect**: 事件驅動架構規劃專家
  - **核心職責**: 事件系統架構研究、模組通訊設計、架構模式規劃
  - **研究範圍**: 分析現有架構、設計事件流程、規劃模組通訊協議
  - **輸出成果**: 事件架構設計文件、通訊協議規範、架構實作計劃
  - **絕不執行**: 不修改任何程式碼或實作事件系統

- **oregano-data-miner**: 資料提取策略研究專家
  - **核心職責**: 資料提取策略研究、DOM 分析規劃、資料處理流程設計
  - **研究範圍**: 分析目標網站結構、設計提取策略、規劃資料處理流程
  - **輸出成果**: 資料提取計劃、DOM 分析報告、處理流程設計
  - **絕不執行**: 不執行實際的資料提取或網頁爬蟲工作

- **ginger-performance-tuner**: 效能優化策略專家
  - **核心職責**: 效能分析研究、優化策略設計、效能監控規劃
  - **研究範圍**: 分析效能瓶頸、設計優化方案、規劃監控策略
  - **輸出成果**: 效能分析報告、優化實作計劃、監控策略設計
  - **絕不執行**: 不進行實際的程式碼優化或效能調整

#### Agent 使用原則與觸發機制

**核心原則**:

1. **100%責任制**: 每個代理人對其工作範圍負100%責任，不允許責任空隙
2. **敏捷升級機制**: 當技術困難無法突破時，必須升級給PM重新拆分任務
3. **明確職責邊界**: 避免職責重疊，建立清楚的協作和交接協議
4. **品質保證優先**: 代理人確保各階段品質標準，不得因困難而降低標準

**敏捷升級機制統一原則**:

所有代理人都必須遵循以下升級流程：
- **3次嘗試限制**: 同一問題超過3次嘗試仍無法解決時必須升級
- **工作日誌記錄**: 詳細記錄嘗試方案、失敗原因、問題複雜度
- **立即升級**: 停止無效嘗試，將問題拋回給 rosemary-project-manager
- **重新分配**: 等待PM重新拆分任務為更小、更可行的單元

**專案管理層級觸發條件**:

- **rosemary-project-manager**: 
  - 開始新開發任務或重構專案時（策略規劃階段）
  - 代理人工作升級時（任務重新拆分處理）
  - 文件先行策略監督執行時
  - 多個Agent需要協調合作時
  - 專案進度風險管理時

- **project-compliance-agent**: 
  - 完成任何小功能或TDD循環後（執行合規檢查）
  - 版本控制和文件更新驗證時
  - 在 rosemary-project-manager 指導下進行操作合規

**TDD核心代理人觸發條件（測試領域分離）**:

- **sage-test-architect**: 
  - 開始新功能開發需要單元測試設計時
  - 組件層級測試覆蓋不足時
  - TDD Red階段測試案例設計時

- **pepper-test-implementer**: 
  - sage-test-architect 測試設計完成且處於失敗狀態時
  - 需要實現讓測試100%通過的最小程式碼時

- **cinnamon-refactor-owl**: 
  - pepper-test-implementer 完成且所有測試通過後
  - 程式碼品質需要100%改善時

- **coriander-integration-tester**: 
  - 單元測試階段完成後進行系統層級測試時
  - 需要端對端測試和系統整合驗證時

**UI/UX設計實現領域觸發條件（設計實現分離）**:

- **lavender-interface-designer**: 
  - 需要UI/UX設計策略和使用者體驗規劃時
  - 設計規範和界面標準制定時

### 🔄 主線程實作整合規範

#### TDD 完整循環實作（主線程執行）

**🔴 Red 階段（主線程責任）**：
- 閱讀 sage-test-architect 提供的測試設計規劃
- 實作測試程式碼，確認測試失敗
- **實作品質要求**: 測試必須明確、具體、可驗證

**🟢 Green 階段（主線程責任）**：
- 實作最小可用程式碼讓測試通過
- **100% 測試通過要求**: 不允許任何測試失敗
- **最小實作原則**: 只寫剛好讓測試通過的程式碼
- **權宜實作允許**: 可使用暫時方案但須 `//todo:` 標註改善方向

**🔵 Refactor 階段（主線程責任）**：
- 在保持測試通過前提下優化程式碼
- **100% 重構完成**: 不允許任何已識別問題未解決
- **程式碼品質提升**: 改善可讀性、可維護性、效能
- **架構改善**: 解決技術債務、統一設計模式

#### Chrome Extension 實作規範（主線程執行）

**Manifest V3 嚴格合規**：
- 所有 API 使用必須符合 Manifest V3 規範
- Service Worker 模式而非 Background Pages
- 適當的權限請求策略

**安全性實作要求**：
- 最小權限原則：只請求必要權限
- 本地資料處理：避免外部服務傳輸
- CSP 合規：實作適當的內容安全政策

**設計規範實作**：
- 100% 實現 lavender-interface-designer 設計規範
- 遵循既定的 UI/UX 標準
- 保持設計一致性和使用者體驗

### 📁 上下文管理機制

#### 檔案系統上下文管理
- **上下文檔案**: `docs/context/session_contexts/context_session_X.md`
- **Agent 規劃**: `docs/context/agent_plans/[類別]/[檔案名稱].md`
- **標準模板**: `docs/context/templates/` 提供統一格式

#### Agent 工作流程
1. **開始前**: 閱讀最新的專案上下文檔案
2. **研究階段**: 深入分析程式碼庫和需求
3. **規劃階段**: 制定詳細的實作計劃
4. **輸出階段**: 建立規劃文件並更新上下文
5. **回報階段**: 使用標準格式通知主線程

#### 標準輸出格式
所有 sub-agent 必須使用統一的輸出格式（詳見 `docs/context/agent_output_standards.md`）：

```
我已經完成 [任務名稱] 的 [工作類型] 規劃工作。

📋 **規劃檔案**: `docs/context/agent_plans/[類別]/[檔案名稱].md`
🔄 **上下文更新**: 已更新專案上下文檔案
🔍 **主要發現**: [重要發現簡要總結]
🎯 **建議行動**: [對主線程的具體建議]

請在繼續實作前先閱讀規劃檔案。
```

### ⚠️ 嚴格禁止事項

#### Sub-agent 絕對禁止行為
- ❌ **實作程式碼**: 不得修改、建立或刪除任何程式碼檔案
- ❌ **執行測試**: 不得運行任何測試指令或驗證程式碼
- ❌ **檔案操作**: 不得建立非規劃文件的任何檔案
- ❌ **工具執行**: 不得呼叫實作相關的開發工具

#### 主線程必須負責
- ✅ **所有程式碼實作**: 包括測試、功能、重構
- ✅ **檔案系統操作**: 建立、修改、刪除程式碼檔案
- ✅ **測試執行**: 運行測試套件、驗證功能
- ✅ **工具執行**: 使用 linter、builder、部署工具
- ✅ **除錯和問題解決**: 處理所有技術問題

### 🎯 協作成功關鍵

#### 高效協作要求
- **詳細規劃**: Sub-agent 必須提供足夠詳細的實作計劃
- **即時溝通**: 透過上下文檔案保持資訊同步
- **品質保證**: 主線程嚴格按照規劃執行實作
- **持續改進**: 從每次協作中學習並優化流程

#### 升級處理機制
- **3次嘗試限制**: 同一問題超過3次無法解決時升級
- **詳細記錄**: 在工作日誌記錄嘗試和失敗原因
- **任務重新分解**: PM 重新拆分為更小可行單元
- **循環消化**: 確保所有工作最終完成

## 🔧 開發工具和指令

### 測試指令

```bash
# 執行所有測試
npm test

# 監視模式執行測試
npm run test:watch

# 執行特定類型測試
npm run test:unit
npm run test:integration
npm run test:e2e

# 執行測試並產生覆蓋率報告
npm run test:coverage
```

### 建置指令

```bash
# 安裝依賴項 (注意：使用 --legacy-peer-deps)
npm install --legacy-peer-deps

# 開發版本建置
npm run build:dev

# 生產版本建置
npm run build:prod

# 啟動開發工作流程 (建置 + 監視測試)
npm run dev
```

### 程式碼品質指令

```bash
# 執行程式碼檢查
npm run lint

# 自動修正程式碼檢查問題
npm run lint:fix

# 清理建置產物
npm run clean
```

## 📊 任務追蹤管理

### 任務管理

- 所有任務記錄在 `docs/todolist.md`
- 使用圖例追蹤進度：⭕ 待開始、🔴 紅燈、🟢 綠燈、🔵 重構、✅ 完成
- 每完成一個 TDD 循環立即更新狀態

### 里程碑追蹤

- v0.0.x: 基礎架構與測試框架
- v0.x.x: 開發階段，逐步實現功能
- v1.0.0: 完整功能，準備上架 Chrome Web Store

## 📚 重要文件參考

- `docs/architecture/event-system.md` - 詳細事件系統設計
- `docs/struct.md` - 完整專案結構說明
- `docs/todolist.md` - 開發任務追蹤
- `docs/work-logs/` - 詳細開發工作日誌
- `.cursorrules` - 完整開發規則 (此為規範來源)
- `CHANGELOG.md` - 版本變更記錄
